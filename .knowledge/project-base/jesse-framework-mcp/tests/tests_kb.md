<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/tests/

## Global Summary

#### Functional Intent & Features

Comprehensive test suite validating the Jesse Framework MCP Server's knowledge base indexing system, HTTP formatting infrastructure, and resource endpoint functionality through isolated unit tests, integration testing, and real-world validation scenarios. Provides extensive testing capabilities for hierarchical dependency planning, cache integration, configuration management, project root detection, and MCP resource protocol compliance. Enables developers to verify system reliability through targeted validation of `HierarchicalIndexer`, `RebuildDecisionEngine`, `FileAnalysisCache`, `XAsyncHttpPath`, `IndexingConfig`, session initialization resources, and gitignore compliance functionality. Key semantic entities include `pytest`, `asyncio`, `tempfile`, `MockContext`, `TestContext`, `unwrap_fastmcp_function`, `pathlib.Path`, `FastMCP` protocol simulation, `jesse://session/init-context`, `jesse://project/gitignore-files`, `StrandsClaude4Driver`, `Claude4SonnetConfig`, boundary marker validation (`--JESSE_FRAMEWORK_BOUNDARY_2025--`), HTTP status code testing, and comprehensive decision outcome validation through `DecisionOutcome`, `DecisionReason`, and `DecisionReport` structures.

##### Main Components

Core test categories include session initialization validation through `test_session_init_resource.py` and `test_new_resources.py` for MCP resource endpoint testing, hierarchical indexing validation through `test_hierarchical_dependency_planning.py`, `test_centralized_decision_engine.py`, and `test_project_indexing_integration.py` for system-wide integration testing. HTTP infrastructure testing encompasses `test_http_formatting.py` (reference file), `test_http_core_functionality.py`, `test_http_section_formatting.py`, and `test_http_path_integration.py` for comprehensive HTTP response validation. Cache and performance testing includes `test_file_analysis_cache_integration.py` and `test_upfront_cache_structure_preparation.py` for optimization validation. Configuration and project structure testing covers `test_configuration_template_system.py`, `test_project_root.py`, `test_default_knowledge_directory.py`, and specialized validation through `test_root_kb_generation.py`, `test_project_base_indexing_rule.py`, and `test_scratchpad_exclusion.py`.

###### Architecture & Design

Implements comprehensive testing architecture with mock-based isolation patterns using `MockContext` and `TestContext` classes for FastMCP protocol simulation without external dependencies. Uses temporary filesystem isolation through `tempfile.TemporaryDirectory()` for reproducible test environments and realistic file system operations. Employs parametric testing patterns with `pytest` fixtures for configuration validation across multiple handler types (`project-base`, `git-clones`, `pdf-knowledge`). Implements dual-mode testing strategies supporting both unit testing for isolated component validation and integration testing for end-to-end system verification. Uses assertion-based validation with comprehensive edge case coverage, error condition simulation, and boundary marker compliance verification for MCP resource protocol adherence.

####### Implementation Approach

Executes async testing patterns throughout using `asyncio.run()` and `await` syntax for compatibility with MCP server async interfaces. Implements FastMCP decorator unwrapping through `unwrap_fastmcp_function()` utility enabling direct function testing without protocol overhead. Uses realistic project structure simulation with nested directory hierarchies, file content generation, and timestamp manipulation for comprehensive staleness testing. Employs comprehensive validation strategies including HTTP response parsing, boundary marker counting, content-length verification, and multi-section response assembly testing. Implements performance testing through concurrent operation simulation, cache hit rate measurement, and race condition detection for optimization validation.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.hierarchical_indexer:HierarchicalIndexer` - core indexing system validation
- `jesse_framework_mcp.knowledge_bases.indexing.rebuild_decision_engine:RebuildDecisionEngine` - decision logic testing
- `jesse_framework_mcp.knowledge_bases.indexing.file_analysis_cache:FileAnalysisCache` - cache functionality validation
- `jesse_framework_mcp.knowledge_bases.indexing.plan_generator:PlanGenerator` - execution planning testing
- `jesse_framework_mcp.helpers.async_http_formatter:format_http_section` - HTTP formatting validation
- `jesse_framework_mcp.helpers.async_http_formatter:XAsyncHttpPath` - dual-path functionality testing
- `jesse_framework_mcp.resources.session_init:get_session_init_context` - session initialization resource testing
- `jesse_framework_mcp.resources.project_resources:get_project_gitignore_files` - gitignore resource validation
- `jesse_framework_mcp.llm.strands_agent_driver:StrandsClaude4Driver` - LLM driver integration testing
- `pytest` (external library) - comprehensive testing framework with fixtures and parametric testing
- `asyncio` (external library) - async execution framework for MCP protocol compatibility
- `tempfile` (external library) - isolated test environment creation and cleanup
- `pathlib.Path` (external library) - cross-platform path manipulation and validation

**← Outbound:**
- `CI/CD pipeline systems` - automated test execution consuming test results for deployment validation
- `development workflows` - manual test execution for component validation and debugging
- `test coverage reports` - comprehensive validation metrics for system reliability monitoring
- `debug artifact directories/` - structured output for post-test analysis and troubleshooting

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation infrastructure ensuring Jesse Framework MCP Server reliability through comprehensive testing of knowledge base indexing, HTTP formatting, resource endpoints, and configuration management systems
- **Ecosystem Position**: Core testing foundation validating all major system components from low-level HTTP formatting through high-level knowledge base processing workflows, preventing regression and ensuring deployment readiness
- **Integration Pattern**: Executed by developers during development cycles and CI/CD systems for continuous validation, consuming actual project files and MCP protocol implementations while generating comprehensive validation reports and debug artifacts

######### Edge Cases & Error Handling

Comprehensive error scenario validation includes missing project root detection with setup guidance generation, FastMCP decorator unwrapping failures with graceful fallback, and filesystem permission issues with appropriate error mapping. Tests validate empty directory handling preventing infinite rebuild loops, orphaned file detection with safety validation, and concurrent operation race condition prevention. HTTP error handling covers automatic status code detection from Python exceptions (`FileNotFoundError` to 404, `PermissionError` to 403), boundary marker validation, and content-length accuracy with UTF-8 encoding. Configuration error handling includes invalid handler type validation, missing configuration file auto-generation, and Pydantic model validation with descriptive error messages. Cache error handling validates timestamp tolerance scenarios, cache invalidation accuracy, and performance optimization under various load conditions.

########## Internal Implementation Details

Mock context implementations maintain separate message lists (`info_messages`, `debug_messages`, `warning_messages`, `error_messages`) with real-time console output for debugging. Temporary directory management uses context managers with automatic cleanup and realistic file system operations including permission manipulation and timestamp control. HTTP validation employs string parsing with regular expressions for RFC 7231 timestamp format validation and byte-perfect content-length calculation. Configuration testing uses dictionary-based validation with nested structure access and immutability verification through deep copy testing. Performance testing implements concurrent operation simulation with `asyncio.gather()` and race condition detection through error message pattern analysis.

########### Usage Examples

Essential test execution patterns demonstrate comprehensive system validation workflows. These patterns provide structured approaches for validating different aspects of the Jesse Framework MCP Server testing infrastructure.

```python
# Execute comprehensive session initialization validation
python test_session_init_resource.py
# Validates jesse://session/init-context resource with boundary marker compliance

# Run hierarchical dependency planning tests
python test_hierarchical_dependency_planning.py  
# Validates selective cascading and horizontal dependency management

# Execute real-world integration testing
python test_project_indexing_integration.py --full-rebuild
# Comprehensive system validation with actual project files
```

Specialized testing patterns enable component isolation and targeted validation. These approaches focus on specific system components while maintaining comprehensive coverage of functionality and edge cases.

```python
# HTTP formatting validation with temporary files
python test_http_path_integration.py
# Validates XAsyncHttpPath dual-path functionality and content loading

# Cache integration testing with performance validation
python test_file_analysis_cache_integration.py
# Validates cache-first processing and optimization benefits

# Configuration template system validation
python test_configuration_template_system.py
# Validates handler-specific configurations and auto-generation
```

## Subdirectory Knowledge Integration

*No subdirectories processed*

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_centralized_decision_engine.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test file validates the centralized `RebuildDecisionEngine` addressing two critical scattered decision logic issues: infinite rebuilding of empty directories (like "image" directory) and missing global project summaries (`root_kb.md`). The file provides comprehensive test coverage for decision engine functionality through `test_empty_directory_decision()`, `test_project_root_decision()`, `test_regular_directory_decision()`, and `test_comprehensive_decision_analysis()` functions. Key semantic entities include `RebuildDecisionEngine`, `IndexingConfig`, `DirectoryContext`, `FileContext`, `DecisionOutcome`, `DecisionReason`, `MockContext`, `IndexingMode.INCREMENTAL`, `OutputConfig`, `ChangeDetectionConfig`, and `DecisionReport` enabling rapid navigation of knowledge base indexing decision logic. The test suite validates that empty directories receive `SKIP` decisions with `EMPTY_DIRECTORY` reasoning, project roots get `REBUILD` decisions with `PROJECT_ROOT_FORCED` reasoning, and regular directories use staleness-based `COMPREHENSIVE_STALENESS` logic.

##### Main Components

The test file contains four primary test functions: `test_empty_directory_decision()` validates empty directory handling preventing infinite rebuilds, `test_project_root_decision()` ensures project root processing for `root_kb.md` generation, `test_regular_directory_decision()` verifies standard staleness-based decision logic, and `test_comprehensive_decision_analysis()` tests complete hierarchy analysis. The `MockContext` class provides FastMCP Context simulation with message capture capabilities through `info()`, `debug()`, `warning()`, and `error()` methods. The `main()` function orchestrates test execution with comprehensive result reporting and error isolation.

###### Architecture & Design

The test architecture follows a mock-based testing pattern with `MockContext` simulating the FastMCP Context interface for decision engine interaction. Each test function creates isolated temporary directory structures using `tempfile.TemporaryDirectory()` to simulate real filesystem scenarios. The design employs comprehensive assertion-based validation checking both decision outcomes (`DecisionOutcome.SKIP`, `DecisionOutcome.REBUILD`) and reasoning (`DecisionReason.EMPTY_DIRECTORY`, `DecisionReason.PROJECT_ROOT_FORCED`, `DecisionReason.COMPREHENSIVE_STALENESS`). Test isolation ensures individual test failures don't affect other test execution through try-catch error handling.

####### Implementation Approach

The implementation uses `asyncio` for asynchronous test execution matching the decision engine's async interface. Each test creates specific directory contexts using `DirectoryContext` and `FileContext` models to simulate different scenarios: empty directories with no file contexts, project roots with content, and regular directories with processable files. The testing strategy employs comprehensive verification checking decision outcomes, reasoning text content, and debug message patterns. Test data generation uses real file creation with `Path.write_text()` and `Path.mkdir()` for authentic filesystem simulation.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.rebuild_decision_engine:RebuildDecisionEngine` - core decision engine being tested
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration model for decision engine setup
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:DirectoryContext` - directory context modeling
- `jesse_framework_mcp.knowledge_bases.models.rebuild_decisions:DecisionOutcome` - decision outcome enumeration
- `asyncio` (external library) - asynchronous test execution framework
- `tempfile` (external library) - temporary directory creation for test isolation
- `pathlib.Path` (external library) - filesystem path manipulation

**← Outbound:**
- `pytest` or direct execution - test runner consuming this test suite
- `CI/CD pipeline` - automated testing consuming test results
- `development workflow` - manual test execution for decision engine validation

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring decision engine correctness within the Jesse Framework MCP knowledge base indexing system
- **Ecosystem Position**: Core testing infrastructure preventing regression in decision logic that could cause infinite rebuilds or missing project summaries
- **Integration Pattern**: Executed by developers and CI/CD systems to validate decision engine behavior before deployment, ensuring knowledge base indexing reliability

######### Edge Cases & Error Handling

The test suite handles multiple edge cases including completely empty directories with no files or subdirectories, project root directories requiring forced processing regardless of staleness, and mixed hierarchies combining empty directories with content-bearing directories. Error handling uses comprehensive try-catch blocks in each test function preventing individual test failures from stopping overall execution. The `MockContext` captures all message types (`info`, `debug`, `warning`, `error`) enabling verification of proper error communication. Test assertions include specific error message pattern matching ensuring decision engine provides appropriate feedback for different scenarios.

########## Internal Implementation Details

The `MockContext` class maintains separate message lists (`info_messages`, `debug_messages`, `warning_messages`, `error_messages`) for categorized message verification and real-time console output for debugging. Test functions use specific assertion patterns checking decision outcome enums, reasoning text content matching, and debug message emoji patterns (`📁 EMPTY`, `🏗️ PROJECT ROOT`). The comprehensive analysis test builds complex directory hierarchies with `subdirectory_contexts` nesting to validate recursive decision making. File timestamp simulation uses `datetime.fromtimestamp(file.stat().st_mtime)` for realistic staleness testing scenarios.

########### Code Usage Examples

**Basic decision engine test setup:**
```python
# Create test configuration for decision engine
config = IndexingConfig(
    output_config=OutputConfig(knowledge_output_directory=temp_path / ".knowledge"),
    change_detection=ChangeDetectionConfig(
        indexing_mode=IndexingMode.INCREMENTAL,
        timestamp_tolerance_seconds=1.0
    )
)

# Create decision engine and mock context
decision_engine = RebuildDecisionEngine(config)
ctx = MockContext()
```

**Empty directory decision testing:**
```python
# Create empty directory context (no files, no subdirectories)
empty_directory_context = DirectoryContext(
    directory_path=empty_dir,
    file_contexts=[],  # No files
    subdirectory_contexts=[]  # No subdirectories
)

# Make decision and verify outcome
decision = await decision_engine.should_rebuild_directory(
    empty_directory_context, temp_path, ctx
)
assert decision.outcome == DecisionOutcome.SKIP
assert decision.reason == DecisionReason.EMPTY_DIRECTORY
```

**Comprehensive hierarchy analysis:**
```python
# Perform comprehensive analysis on directory hierarchy
report = await decision_engine.analyze_hierarchy(root_context, temp_path, ctx)

# Verify report structure and decisions
assert report.total_decisions >= 3
root_decision = report.get_decision_for_path(temp_path)
stats = report.get_summary_statistics()
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_configuration_template_system.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test suite validates the Configuration Template System for the Jesse Framework MCP knowledge base indexing system, providing comprehensive testing of centralized defaults, JSON configuration auto-generation, and Pydantic validation mechanisms. The test suite ensures proper integration between configuration templates and the `IndexingConfig` system through hierarchical validation patterns. Key semantic entities include `get_default_config`, `get_supported_handler_types`, `validate_handler_type`, `IndexingConfigManager`, `IndexingConfigModel`, `HandlerType`, `PROJECT_BASE_DEFAULT_CONFIG`, `GIT_CLONES_DEFAULT_CONFIG`, `PDF_KNOWLEDGE_DEFAULT_CONFIG`, `pytest`, `tempfile`, `pathlib.Path`, and `unittest.mock.patch`. The testing framework validates handler type support (`project-base`, `git-clones`, `pdf-knowledge`), hierarchical configuration structures, auto-generation of missing configuration files, and Pydantic model validation with specific exclusion patterns for different handler types.

##### Main Components

The test suite contains four primary test classes: `TestDefaultConfigurations` validates centralized default configurations for all handler types, `TestPydanticValidation` tests Pydantic model validation with hierarchical configuration structures, `TestConfigurationManager` validates the `IndexingConfigManager` functionality including auto-generation and caching, and `TestIndexingConfigIntegration` tests integration between the configuration system and `IndexingConfig` class. Additional components include `TestHierarchicalExclusions` for testing exclusion system validation, fixture methods like `temp_knowledge_dir()` for isolated testing environments, and comprehensive validation methods for handler-specific configuration parameters and hierarchical content filtering rules.

###### Architecture & Design

The testing architecture follows a class-based organization pattern with each test class focusing on a specific component of the configuration template system. The design uses `pytest` fixtures for temporary directory management and isolated test environments, ensuring no cross-test contamination. Each test class validates different aspects of the hierarchical configuration system: default configuration templates, Pydantic validation rules, configuration manager operations, and integration patterns. The architecture includes comprehensive validation of handler-specific configurations with different file processing parameters, content filtering rules, and LLM configuration settings for each supported handler type.

####### Implementation Approach

The implementation uses parametric testing patterns to validate multiple handler types (`project-base`, `git-clones`, `pdf-knowledge`) with different configuration parameters and validation rules. Tests validate hierarchical configuration structures by checking nested dictionary values for file processing, content filtering, and LLM configuration sections. The approach includes immutability testing through deep copy validation, caching behavior verification through instance comparison, and error handling validation using `pytest.raises()` context managers. Configuration auto-generation testing uses temporary directories and JSON file validation to ensure proper file creation and content structure.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.defaults:get_default_config` - centralized default configuration retrieval
- `jesse_framework_mcp.knowledge_bases.indexing.config_manager:IndexingConfigManager` - configuration management and auto-generation
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - core configuration model integration
- `pytest` (external library) - testing framework and fixture management
- `tempfile` (standard library) - isolated test environment creation
- `unittest.mock.patch` (standard library) - mocking for project root detection testing

**← Outbound:**
- Test execution results consumed by CI/CD validation systems
- Configuration template validation reports for deployment verification
- Pydantic model validation metrics for configuration reliability monitoring

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring configuration template system reliability and proper integration with Jesse Framework MCP knowledge base indexing workflow
- **Ecosystem Position**: Core testing infrastructure validating the foundation of configuration management, auto-generation, and hierarchical validation patterns
- **Integration Pattern**: Executed by developers and CI systems to validate configuration template system before deployment, ensuring proper handler type support and configuration file generation

######### Edge Cases & Error Handling

The tests validate unsupported handler type scenarios (should raise `ValueError` with specific error messages), invalid JSON configuration files (should handle parsing errors gracefully), missing project root detection (should raise appropriate errors), and invalid Pydantic model validation (should provide descriptive validation errors). Error handling includes comprehensive validation of configuration immutability through deep copy testing, cache clearing behavior verification, and invalid configuration parameter handling. The tests specifically validate that `project-base` handlers require `project_base_exclusions` while other handlers do not, ensuring proper validation rules for different handler types.

########## Internal Implementation Details

Internal mechanisms include temporary directory fixture management using `pytest.fixture` with `tempfile.TemporaryDirectory()` context managers, configuration file path generation using handler-specific naming patterns (`{handler_type}.indexing-config.json`), and hierarchical configuration validation through nested dictionary access patterns. The testing framework includes comprehensive parameter validation for file processing settings (max_file_size, batch_size, max_concurrent_operations), content filtering exclusions (excluded_extensions, excluded_directories, project_base_exclusions), and LLM configuration parameters (temperature, max_tokens, llm_model). Cache behavior testing uses instance identity comparison to validate proper caching and cache clearing functionality.

########### Code Usage Examples

Essential default configuration validation pattern for handler-specific settings:

```python
# This pattern demonstrates validation of hierarchical default configurations for different handler types
# Each handler type has specific file processing, content filtering, and LLM configuration parameters
config = get_default_config("project-base")

assert config["handler_type"] == "project-base"
assert config["file_processing"]["max_file_size"] == 2 * 1024 * 1024  # 2MB
assert config["file_processing"]["batch_size"] == 7
assert config["content_filtering"]["project_base_exclusions"] is not None
assert ".knowledge" in config["content_filtering"]["project_base_exclusions"]
```

Configuration manager auto-generation testing pattern:

```python
# This pattern validates automatic generation of missing configuration files with proper JSON structure
# The manager creates configuration files on-demand when they don't exist
manager = IndexingConfigManager(temp_knowledge_dir)
config_file = temp_knowledge_dir / "project-base.indexing-config.json"

# Config file shouldn't exist initially
assert not config_file.exists()

# Load config should auto-generate the file
config = manager.load_config("project-base")

# File should now exist with valid JSON content
assert config_file.exists()
with open(config_file, 'r') as f:
    json_config = json.load(f)
assert json_config["handler_type"] == "project-base"
```

Pydantic validation testing for hierarchical configuration structures:

```python
# This pattern validates Pydantic model validation with hierarchical configuration data
# The validation ensures proper structure and handler-specific requirements
config_data = get_default_config("project-base")

# Should validate without errors for valid configuration
config_model = IndexingConfigModel(**config_data)

assert config_model.handler_type == HandlerType.PROJECT_BASE
assert config_model.file_processing.max_file_size == 2 * 1024 * 1024
assert ".knowledge" in config_model.content_filtering.project_base_exclusions
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_default_knowledge_directory.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test script validates the default knowledge directory configuration behavior within the JESSE Framework MCP Server knowledge base system, specifically designed to verify that `IndexingConfig` automatically defaults to `{PROJECT_ROOT}/.knowledge/` directory when no explicit path is specified. The script provides comprehensive testing capabilities for configuration default behavior, explicit override functionality, and serialization validation. Key semantic entities include `IndexingConfig`, `OutputConfig`, `get_project_root`, `knowledge_output_directory` property, `to_dict()` serialization method, and `.knowledge/` default directory structure. The testing framework implements three-phase validation through default behavior testing, explicit specification override testing, and configuration serialization verification with emoji-based status reporting.

##### Main Components

The script contains two primary test functions: `test_default_knowledge_directory()` for comprehensive configuration default behavior validation with three sub-tests, and `test_project_root_integration()` for project root detection verification. The main execution block orchestrates sequential test execution with success tracking and exit code management. Each test function implements assertion-based validation with detailed console output including expected versus actual value comparisons and conditional test skipping for missing project root scenarios.

###### Architecture & Design

The architecture follows a structured testing pattern with isolated test functions for different configuration aspects, utilizing direct class instantiation and property inspection. The design implements graceful degradation for missing project root detection, treating it as a skippable condition rather than failure. Error handling is structured with assertion-based validation and conditional test execution based on project root availability. The testing framework uses explicit value comparison with detailed logging for debugging configuration behavior.

####### Implementation Approach

The implementation uses direct `IndexingConfig()` instantiation to test default behavior and `OutputConfig(knowledge_output_directory=custom_path)` for explicit override testing. Project root detection employs `get_project_root()` utility function with conditional validation based on return value availability. Configuration serialization testing uses `to_dict()` method with nested dictionary access for `output_config.knowledge_output_directory` validation. The testing strategy implements both positive path validation and fallback behavior verification through conditional assertion logic.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - primary configuration class
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:OutputConfig` - output configuration component
- `jesse_framework_mcp.helpers.path_utils:get_project_root` - project root detection utility
- `pathlib:Path` (external library) - path manipulation and validation
- `sys` (external library) - system path manipulation and exit code management

**← Outbound:**
- Console test output with emoji-based status indicators
- Test result validation for knowledge base configuration integrity
- Exit code reporting for CI/CD pipeline integration

**⚡ System role and ecosystem integration:**
- **System Role**: Configuration validation component ensuring knowledge base directory defaults are properly established within the JESSE Framework MCP Server ecosystem
- **Ecosystem Position**: Critical testing utility for knowledge base configuration integrity, validating the bridge between project structure detection and knowledge storage location defaults
- **Integration Pattern**: Executed by developers and CI/CD systems to verify knowledge base configuration behavior before deployment, ensuring consistent knowledge storage location across different environments

######### Edge Cases & Error Handling

Error handling covers missing project root detection with graceful test skipping and fallback behavior validation, invalid configuration scenarios through assertion-based validation, and serialization failures with conditional test execution. The script handles missing `.knowledge/` directory scenarios through default path construction validation. Edge cases include project root detection failures in different environments, custom path override conflicts, and serialization format changes. The testing framework provides differentiated reporting through emoji indicators and maintains test execution continuity with conditional assertion logic.

########## Internal Implementation Details

Default behavior testing uses direct property access on `IndexingConfig()` instances with `Path` object comparison against expected project root plus `.knowledge/` suffix. Explicit override testing creates `OutputConfig` instances with custom paths and validates property inheritance through `IndexingConfig(output_config=output_config)` constructor. Serialization validation accesses nested dictionary structures through `config_dict.get('output_config', {}).get('knowledge_output_directory')` with string comparison against expected path representations. Test orchestration uses boolean success tracking with conditional execution and exit code management.

########### Code Usage Examples

**Basic default configuration testing with project root validation:**

This example demonstrates how to test the default knowledge directory behavior and validate project root integration. The test verifies that `IndexingConfig` automatically sets the knowledge output directory to the project root plus `.knowledge/` suffix.

```python
# Test default knowledge directory configuration behavior
config = IndexingConfig()
expected_project_root = get_project_root()
if expected_project_root:
    expected_knowledge_dir = expected_project_root / '.knowledge'
    assert config.knowledge_output_directory == expected_knowledge_dir
```

**Explicit configuration override with custom path validation:**

This snippet shows how to test explicit knowledge directory specification and verify that custom paths properly override default behavior. The test ensures that explicit configuration takes precedence over automatic defaults.

```python
# Test explicit knowledge directory override functionality
custom_path = Path("/tmp/custom_knowledge")
output_config = OutputConfig(knowledge_output_directory=custom_path)
config = IndexingConfig(output_config=output_config)
assert config.knowledge_output_directory == custom_path
```

**Configuration serialization validation with nested dictionary access:**

This example demonstrates how to validate configuration serialization behavior and ensure that knowledge directory paths are properly preserved in dictionary format. The test verifies that serialized configurations maintain path information correctly.

```python
# Test configuration serialization and dictionary representation
config = IndexingConfig()
config_dict = config.to_dict()
knowledge_dir_str = config_dict.get('output_config', {}).get('knowledge_output_directory')
expected_str = str(get_project_root() / '.knowledge')
assert knowledge_dir_str == expected_str
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_discovery_debug.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This file provides debug testing capabilities for the Jesse Framework MCP's directory discovery phase, specifically investigating why the `HierarchicalIndexer` component fails to properly exclude certain directories during project indexing. The file implements comprehensive discovery phase validation through the `test_discovery_debug()` async function, enabling developers to diagnose directory exclusion failures in knowledge base indexing workflows. Key semantic entities include `HierarchicalIndexer`, `IndexingConfig`, `get_default_config`, `should_process_directory()`, `_discover_directory_structure()`, project-base exclusions (`.coding_assistant/`, `.knowledge/`, `.clinerules/`, `scratchpad/`), `AsyncMock` context simulation, and tempfile-based test environment creation. The implementation uses structured test project creation with realistic directory hierarchies to validate exclusion logic against expected behavior patterns.

##### Main Components

The file contains the primary `test_discovery_debug()` async function that orchestrates the complete debug workflow, a `main()` function serving as the CLI entry point with result reporting, and comprehensive test infrastructure including temporary directory creation, mock context setup, and validation logic. The debug test creates a realistic project structure with both excluded directories (`.coding_assistant/`, `.knowledge/`, `.clinerules/`, `scratchpad/`) and included directories (`src/`, `docs/`) to simulate real-world indexing scenarios. The validation system compares expected versus actual discovery results through set operations and provides detailed diagnostic output including mock call analysis and final determination logic.

###### Architecture & Design

The debug test follows a structured validation architecture with distinct phases: test environment setup, configuration loading, individual directory exclusion testing, discovery phase execution, and comprehensive result analysis. The design uses temporary filesystem isolation through `tempfile.TemporaryDirectory` to ensure test reproducibility and cleanup. The validation approach employs set-based comparison logic to identify wrongly included or excluded directories, with comprehensive diagnostic reporting including mock context call analysis. The architecture separates concerns between test setup, execution, validation, and reporting phases for clear debugging workflow.

####### Implementation Approach

The implementation uses async/await patterns for compatibility with the `HierarchicalIndexer._discover_directory_structure()` method, employing `AsyncMock` objects to simulate the indexing context without actual logging infrastructure. The test creates a realistic project structure programmatically, then validates both individual directory exclusion logic through `config.should_process_directory()` and the complete discovery phase behavior. The validation strategy uses set operations (`excluded_expected & discovered_names`, `included_expected - discovered_names`) to identify discrepancies between expected and actual behavior. Diagnostic output includes structured reporting with emoji indicators, detailed mock call analysis, and final determination logic for root cause identification.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.hierarchical_indexer:HierarchicalIndexer` - core indexing component under test
- `jesse_framework_mcp.knowledge_bases.indexing.defaults:get_default_config` - configuration factory for project-base settings
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration model with exclusion logic
- `asyncio` (external library) - async execution runtime for test orchestration
- `tempfile` (external library) - temporary filesystem creation for isolated testing
- `pathlib:Path` (external library) - filesystem path manipulation and directory operations
- `unittest.mock:AsyncMock` (external library) - mock context simulation for indexer testing

**← Outbound:**
- `console output` - structured diagnostic reporting for developers debugging discovery issues
- `test results` - boolean validation results for CI/CD integration or manual testing workflows
- `temporary filesystem artifacts` - test project structure creation for validation scenarios

**⚡ System role and ecosystem integration:**

- **System Role**: This debug test serves as a diagnostic tool for the Jesse Framework MCP's knowledge base indexing system, specifically targeting directory discovery phase failures that prevent proper exclusion of configuration and temporary directories
- **Ecosystem Position**: Peripheral debugging utility that validates core indexing functionality, essential for maintaining proper knowledge base creation workflows but not part of the production indexing pipeline
- **Integration Pattern**: Used by developers experiencing directory exclusion issues, executed manually or through test runners to diagnose `HierarchicalIndexer` behavior and validate configuration effectiveness

######### Edge Cases & Error Handling

The debug test handles scenarios where excluded directories are wrongly discovered or expected directories are missed during the discovery phase. The validation logic identifies both false positives (excluded directories appearing in results) and false negatives (expected directories missing from results) through comprehensive set-based comparison. The test provides detailed diagnostic output for debugging scenarios including empty discovery results, configuration loading failures, and mock context call analysis. Error scenarios include temporary directory creation failures, configuration parsing issues, and async execution problems, with structured reporting to identify whether issues originate in the discovery phase or elsewhere in the execution flow.

########## Internal Implementation Details

The test creates a specific directory structure with `.coding_assistant/workspace.json`, `.knowledge/kb.md`, `.clinerules/rules.md`, `scratchpad/notes.txt`, `src/main.py`, and `docs/README.md` files to simulate realistic project layouts. The configuration uses `project-base` defaults with custom knowledge output directory pointing to the temporary test location. Mock context setup includes `info`, `debug`, `warning`, and `error` methods as `AsyncMock` objects to capture indexer logging behavior. The validation logic uses `wrongly_included = excluded_expected & discovered_names` and `wrongly_excluded = included_expected - discovered_names` for precise discrepancy identification. Final determination combines both validation results to determine if the discovery phase is functioning correctly.

########### Code Usage Examples

**Running the debug test to diagnose directory exclusion issues:**

```python
# Execute the debug test directly
result = asyncio.run(test_discovery_debug())
if result:
    print("Discovery phase working correctly")
else:
    print("Discovery phase has issues")
```

**Using the CLI interface for manual debugging:**

```bash
# Run the debug test from command line
python test_discovery_debug.py
```

**Integrating debug validation into test workflows:**

```python
# Example integration for automated testing
async def validate_indexer_discovery():
    debug_result = await test_discovery_debug()
    assert debug_result, "Discovery phase validation failed"
    return debug_result
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_file_analysis_cache_integration.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This comprehensive test suite validates the `FileAnalysisCache` integration within the JESSE Framework MCP Server knowledge building system, specifically designed to verify cache-first processing, metadata stripping, freshness checking, and performance optimization capabilities. The test suite provides extensive validation for cache storage and retrieval, timestamp-based staleness detection, and seamless integration with the knowledge building workflow. Key semantic entities include `FileAnalysisCache`, `KnowledgeBuilder`, `IndexingConfig`, `FileContext`, `ProcessingStatus`, `MockContext`, `MockKnowledgeBuilder`, `test_cache_basic_functionality`, `test_cache_freshness_checking`, `test_cache_integration_with_knowledge_builder`, `test_cache_performance_simulation`, `StrandsClaude4Driver`, `Claude4SonnetConfig`, `OutputConfig`, `ChangeDetectionConfig`, `LLMConfig`, `DebugConfig`, `METADATA_START`, `METADATA_END` delimiters, and `asyncio` async execution patterns. The testing framework implements four-phase validation through basic functionality testing, freshness checking validation, knowledge builder integration testing, and performance simulation with multiple file scenarios.

##### Main Components

The test suite contains four primary async test functions: `test_cache_basic_functionality()` implementing cache storage, retrieval, and metadata validation, `test_cache_freshness_checking()` validating timestamp-based cache invalidation, `test_cache_integration_with_knowledge_builder()` testing end-to-end integration with mock LLM responses, and `test_cache_performance_simulation()` demonstrating cache hit rate optimization across multiple files. The `MockContext` class provides simplified logging without actual LLM integration, while `MockKnowledgeBuilder` extends `KnowledgeBuilder` with simulated LLM responses for realistic testing. The `run_all_cache_tests()` function orchestrates sequential test execution with comprehensive result reporting and success rate calculation.

###### Architecture & Design

The architecture follows a comprehensive testing pattern with isolated test functions for different cache integration aspects, utilizing temporary directory structures and realistic file scenarios for validation. The design implements mock-based testing through `MockKnowledgeBuilder` to simulate LLM interactions without external API dependencies, enabling reliable and fast test execution. Error handling is structured with assertion-based validation and detailed console output for debugging. The testing framework uses realistic file content and directory structures combined with actual `FileAnalysisCache` and `KnowledgeBuilder` integration to validate end-to-end caching behavior.

####### Implementation Approach

The implementation uses temporary directory creation with `tempfile.TemporaryDirectory()` for isolated testing environments and realistic file system operations. Cache testing employs direct method calls to `get_cached_analysis()`, `cache_analysis()`, and `get_cache_stats()` for targeted validation. Mock LLM integration uses class inheritance with `MockKnowledgeBuilder` overriding `_process_single_file()` to provide deterministic responses. The testing strategy implements both positive path validation and edge case testing through file modification scenarios, cache invalidation testing, and performance measurement with multiple file processing cycles.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.knowledge_builder:KnowledgeBuilder` - primary knowledge building class
- `jesse_framework_mcp.knowledge_bases.indexing.file_analysis_cache:FileAnalysisCache` - cache implementation
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration management
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:OutputConfig` - output configuration
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:ChangeDetectionConfig` - change detection settings
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:LLMConfig` - LLM configuration
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:DebugConfig` - debug configuration
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:FileContext` - file context modeling
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:ProcessingStatus` - processing status tracking
- `jesse_framework_mcp.llm.strands_agent_driver:StrandsClaude4Driver` - LLM driver integration
- `jesse_framework_mcp.llm.strands_agent_driver:Claude4SonnetConfig` - LLM configuration
- `asyncio` (external library) - async execution framework
- `tempfile` (external library) - temporary directory and file management
- `pathlib:Path` (external library) - cross-platform path manipulation
- `datetime` (external library) - timestamp handling for cache freshness validation

**← Outbound:**
- Console test output with detailed cache validation reporting
- Test result validation for cache integration functionality
- Performance metrics for cache hit rate optimization
- Exit code reporting for CI/CD pipeline integration

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive validation component ensuring FileAnalysisCache reliability and performance optimization within the JESSE Framework MCP Server knowledge building ecosystem
- **Ecosystem Position**: Critical testing utility for cache integration functionality, validating the bridge between file analysis caching and knowledge building workflows with performance optimization
- **Integration Pattern**: Executed by developers and CI/CD systems to verify cache-first processing behavior, metadata handling, and performance benefits before knowledge building system deployment

######### Edge Cases & Error Handling

Error handling covers temporary directory creation failures with automatic cleanup, cache file access permission issues, and timestamp tolerance validation for freshness checking. The test suite handles file modification scenarios through sleep delays and timestamp comparison validation, ensuring cache invalidation works correctly. Edge cases include missing cache files with null return validation, metadata delimiter presence verification, content stripping accuracy, and cache statistics validation. The testing framework provides comprehensive error scenario coverage through assertion-based validation, detailed console output for debugging, and graceful handling of mock LLM response variations.

########## Internal Implementation Details

Cache functionality testing uses direct file system operations with temporary directories and realistic file content creation. Freshness checking employs `asyncio.sleep()` for timestamp manipulation and file modification simulation. Mock LLM integration overrides `_process_single_file()` method with predetermined responses while maintaining actual cache integration behavior. Performance testing creates multiple files with iterative processing cycles to measure cache hit rates and validate optimization benefits. Test orchestration uses tuple-based test definition with function references and comprehensive result aggregation through success rate calculation.

########### Code Usage Examples

**Basic cache functionality testing with storage and retrieval:**

This example demonstrates how to test fundamental cache operations including storage, retrieval, and metadata handling. The test validates that cache files are created in correct locations with proper metadata delimiters.

```python
# Test basic cache storage and retrieval functionality
cache = FileAnalysisCache(config)
test_analysis = "## Test Analysis\n\nThis is a test Python file analysis."
await cache.cache_analysis(test_file, test_analysis, source_root)
retrieved_analysis = await cache.get_cached_analysis(test_file, source_root)
assert retrieved_analysis == test_analysis
```

**Cache freshness validation with file modification scenarios:**

This snippet shows how to test cache invalidation based on file timestamps and modification detection. The test verifies that modified files correctly invalidate cached analysis results.

```python
# Test cache freshness checking with file modification
await cache.cache_analysis(test_file, original_analysis, source_root)
await asyncio.sleep(2)  # Ensure timestamp difference
test_file.write_text("# Modified content")
stale_retrieval = await cache.get_cached_analysis(test_file, source_root)
assert stale_retrieval is None  # Cache should be invalidated
```

**Mock knowledge builder integration with cache validation:**

This example demonstrates how to test cache integration with knowledge building workflows using mock LLM responses. The test validates that cache hits and misses are handled correctly during file processing.

```python
# Test knowledge builder integration with cache-first processing
class MockKnowledgeBuilder(KnowledgeBuilder):
    async def _process_single_file(self, file_path, content, ctx, source_root=None):
        cached_analysis = await self.analysis_cache.get_cached_analysis(file_path, source_root)
        if cached_analysis:
            await ctx.info(f"📄 CACHE HIT: Using cached analysis for {file_path.name}")
            return cached_analysis
        return self._mock_llm_response
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_gitignore_resource.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

Test script for validating JESSE Framework MCP server gitignore files resource functionality through direct function testing and HTTP response validation. Provides comprehensive testing of `jesse://project/gitignore-files` resource endpoint with boundary marker verification, writable content validation, and multi-directory gitignore file detection. Features mock context implementation for isolated testing, `FastMCP` decorator unwrapping for direct function access, and detailed response structure analysis. Key semantic entities include `test_gitignore_resource()` function, `MockContext` class, `unwrap_fastmcp_function()` utility, `project_resources.get_project_gitignore_files` resource function, `--JESSE_FRAMEWORK_BOUNDARY_2025--` boundary markers, `X-ASYNC-Content-Writable: true` headers, `X-ASYNC-Content-Section: gitignore-file` section types, `asyncio.run()` execution pattern, and `sys.path.insert()` import configuration. Technical implementation focuses on FastMCP resource testing pattern ensuring boundary marker compliance and HTTP formatting validation.

##### Main Components

- `test_gitignore_resource()` async function implementing comprehensive gitignore resource validation testing
- `MockContext` class providing test context with `info()` and `error()` message logging methods
- `main()` async function handling test execution orchestration and working directory configuration
- `unwrap_fastmcp_function()` utility integration for direct FastMCP decorated function testing
- Response validation logic checking boundary markers, writable headers, and content sections
- Directory presence verification for "Project Root Directory", "Coding Assistant Artifacts", "Knowledge Management System", "Project-Specific Rules"
- Exit code handling with success/failure reporting and detailed test result output

###### Architecture & Design

Implements isolated testing architecture using mock context pattern to avoid external MCP server dependencies. Design separates test execution from validation logic through dedicated verification functions. Uses FastMCP decorator unwrapping strategy enabling direct function testing without MCP protocol overhead. Architecture implements comprehensive response analysis validating HTTP boundary markers, content headers, and section types. Test structure follows async/await patterns matching MCP resource function signatures. Design includes working directory management ensuring tests run from correct project context. Implements detailed logging and verification reporting for debugging and validation transparency.

####### Implementation Approach

Uses `sys.path.insert()` for dynamic import path configuration enabling test module imports. Implements `MockContext` class with async methods matching MCP context interface for isolated testing. Uses `unwrap_fastmcp_function()` utility to extract underlying function from FastMCP decorator for direct invocation. Implements string-based response analysis using `count()` method for boundary marker and header validation. Uses `os.chdir()` for working directory management ensuring tests execute from project root context. Implements comprehensive verification logic checking specific directory sections and content types. Uses `asyncio.run()` for async test execution with proper event loop management.

######## External Dependencies & Integration Points

**→ Inbound:**
- `utils:unwrap_fastmcp_function` - FastMCP decorator unwrapping utility for direct function testing
- `jesse_framework_mcp.resources.project_resources:get_project_gitignore_files` - Target resource function under test
- `asyncio` (external library) - Async execution framework for MCP resource testing
- `pathlib.Path` (external library) - Cross-platform path manipulation for directory management
- `sys` (external library) - Python path configuration for module imports
- `os` (external library) - Working directory management for test context

**← Outbound:**
- `test_execution_reports/` - Test results consumed by CI/CD validation systems
- `development_workflows/` - Manual test execution for gitignore resource validation
- `mcp_server_validation/` - Integration testing for JESSE Framework MCP server functionality

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component for JESSE Framework MCP server gitignore resource endpoint ensuring proper HTTP formatting and content delivery
- **Ecosystem Position**: Core testing infrastructure validating MCP resource protocol compliance and boundary marker functionality
- **Integration Pattern**: Executed by developers for resource validation, CI/CD systems for automated testing, and MCP server integration verification workflows

######### Edge Cases & Error Handling

Handles FastMCP decorator unwrapping failures through exception catching and error reporting. Tests missing gitignore file scenarios through error section counting and validation. Manages working directory changes with proper context switching for test isolation. Handles async function execution errors with comprehensive exception catching and detailed error messages. Tests boundary marker absence or malformation through count-based validation. Validates writable header presence ensuring content modification capabilities are properly indicated. Handles missing directory sections through presence verification and detailed reporting of absent components.

########## Internal Implementation Details

Uses `MockContext` class with `messages` list for capturing info and error messages during testing. Implements `sys.path.insert(0, str(Path(__file__).parent))` for relative import configuration. Uses `os.chdir(Path(__file__).parent.parent)` for project root directory context establishment. Implements string counting validation with `result.count("--JESSE_FRAMEWORK_BOUNDARY_2025--")` for boundary marker verification. Uses `exit(0)` and `exit(1)` for process termination with appropriate success/failure codes. Implements detailed console output with emoji indicators for visual test progress tracking. Uses `len(ctx.messages)` for context message counting and test completion reporting.

########### Code Usage Examples

Essential patterns for MCP resource testing and FastMCP function validation. These examples demonstrate comprehensive testing approaches for gitignore resource functionality and HTTP response validation.

```python
# Mock context implementation for isolated MCP resource testing
class MockContext:
    def __init__(self):
        self.messages = []
    
    async def info(self, message: str):
        self.messages.append(f"INFO: {message}")
        print(f"📝 {message}")
    
    async def error(self, message: str):
        self.messages.append(f"ERROR: {message}")
        print(f"❌ {message}")
```

FastMCP decorator unwrapping enables direct function testing without MCP protocol overhead. This approach allows comprehensive validation of resource function behavior and response formatting.

```python
# FastMCP function unwrapping for direct testing access
print("🔧 Unwrapping FastMCP decorated function...")
unwrapped_function = unwrap_fastmcp_function(project_resources.get_project_gitignore_files)
print(f"✅ Successfully unwrapped function: {unwrapped_function.__name__}")

result = await unwrapped_function(ctx)
```

HTTP response validation ensures proper boundary marker formatting and content section identification. This pattern validates MCP resource protocol compliance and content structure.

```python
# Comprehensive HTTP response validation for MCP resource testing
boundary_count = result.count("--JESSE_FRAMEWORK_BOUNDARY_2025--")
print(f"📌 Found {boundary_count} HTTP boundary markers")

writable_count = result.count("X-ASYNC-Content-Writable: true")
print(f"✏️  Found {writable_count} writable content sections")

gitignore_sections = result.count("X-ASYNC-Content-Section: gitignore-file")
error_sections = result.count("X-ASYNC-Content-Section: gitignore-error")
print(f"📄 Found {gitignore_sections} gitignore file sections")
print(f"🚨 Found {error_sections} error sections")
```

Working directory management ensures tests execute from proper project context for accurate resource validation. This approach handles path dependencies and file system access requirements.

```python
# Working directory configuration for proper test context
os.chdir(Path(__file__).parent.parent)
print(f"📂 Working directory: {os.getcwd()}")

success = await test_gitignore_resource()

if success:
    print("\n🎉 All tests passed!")
    exit(0)
else:
    print("\n💔 Tests failed!")
    exit(1)
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_hierarchical_dependency_planning.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

Test suite validating hierarchical dependency planning architecture for the Jesse Framework MCP knowledge base system, specifically ensuring selective cascading and horizontal dependency management work correctly. Provides comprehensive validation of `RebuildDecisionEngine` selective ancestor propagation and `PlanGenerator` sibling dependency coordination through `test_selective_cascading()` and `test_horizontal_dependencies()` functions. Enables developers to verify that directory rebuild decisions correctly cascade to parent directories without affecting unrelated siblings, and that horizontal dependencies between sibling directories are properly established. Key semantic entities include `MockContext`, `RebuildDecisionEngine`, `PlanGenerator`, `DecisionReport`, `RebuildDecision`, `DirectoryContext`, `FileContext`, `IndexingConfig`, `DecisionOutcome`, `DecisionReason`, `tempfile`, `asyncio`, and `fastmcp.Context` for comprehensive dependency planning validation using async test execution patterns.

##### Main Components

Two primary test functions (`test_selective_cascading()` and `test_horizontal_dependencies()`) that validate different aspects of the hierarchical dependency system, plus a `MockContext` class for FastMCP context simulation and a `main()` orchestration function. The `MockContext` provides logging capabilities with debug, info, warning, and error methods that capture messages for test verification. Test functions create temporary directory structures, configure indexing parameters, and exercise the decision engine and plan generator components to verify correct behavior.

###### Architecture & Design

Follows async test architecture pattern with temporary filesystem setup for isolated testing environments. Uses dependency injection through mock objects to simulate FastMCP context without requiring full framework initialization. Implements comprehensive test scenarios that mirror real-world directory structures with nested hierarchies (`src/components/buttons/`, `src/components/forms/`, `src/utils/`) to validate both vertical cascading and horizontal dependency relationships. Test design separates concerns between decision-making logic and plan generation logic for focused validation.

####### Implementation Approach

Creates temporary directory structures using `tempfile.TemporaryDirectory()` context manager for clean test isolation, then populates with realistic file hierarchies to simulate actual project structures. Constructs `IndexingConfig` objects with minimal exclusions to focus testing on core logic rather than filtering behavior. Uses `DecisionReport` objects to track rebuild decisions and verify cascading propagation through `_propagate_cascading_decisions()` method calls. Implements assertion-based validation to verify ancestor directories receive `DecisionReason.CHILD_DIRECTORY_REBUILT` while sibling directories remain unaffected.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp.Context` - FastMCP framework context interface for logging operations
- `jesse_framework_mcp.knowledge_bases.models` - Core data models including `IndexingConfig`, `DirectoryContext`, `FileContext`
- `jesse_framework_mcp.knowledge_bases.models.indexing_config` - Configuration models `OutputConfig`, `ContentFilteringConfig`
- `jesse_framework_mcp.knowledge_bases.models.rebuild_decisions` - Decision tracking models `DecisionReport`, `RebuildDecision`, `DecisionOutcome`, `DecisionReason`
- `jesse_framework_mcp.knowledge_bases.indexing.rebuild_decision_engine` - `RebuildDecisionEngine` for cascading logic validation
- `jesse_framework_mcp.knowledge_bases.indexing.plan_generator` - `PlanGenerator` for horizontal dependency testing
- `asyncio` (external library) - Async execution framework for test orchestration
- `tempfile` (external library) - Temporary filesystem creation for test isolation
- `pathlib.Path` (external library) - Path manipulation utilities
- `datetime.datetime` (external library) - Timestamp generation for file contexts

**← Outbound:**
- Test execution frameworks - Provides validation results for CI/CD pipeline integration
- Development workflow - Validates architectural fixes before deployment
- Knowledge base indexing system - Ensures dependency planning logic correctness

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring the hierarchical dependency planning architecture functions correctly within the Jesse Framework MCP knowledge base system
- **Ecosystem Position**: Core testing infrastructure that validates fundamental indexing behavior, preventing regression in dependency management logic
- **Integration Pattern**: Executed by developers and CI systems to verify architectural fixes, with results feeding into deployment decisions and system reliability assurance

######### Edge Cases & Error Handling

Tests verify that sibling directories without content changes are correctly excluded from cascading rebuilds, preventing unnecessary work propagation. Validates that ancestor propagation stops at appropriate boundaries and doesn't create infinite loops or excessive cascading. Handles scenarios where decision reports contain mixed rebuild and skip decisions to ensure selective processing. Uses assertion-based validation that will raise clear exceptions if cascading logic fails, providing immediate feedback on architectural issues.

########## Internal Implementation Details

Uses `_propagate_cascading_decisions()` private method to test internal cascading logic directly, bypassing higher-level interfaces for focused validation. Employs `_collect_sibling_directory_tasks()` and `_sanitize_path_for_id()` methods to verify task ID generation and sibling relationship establishment. Creates realistic `DirectoryContext` and `FileContext` objects with proper parent-child relationships to mirror actual indexing scenarios. Implements comprehensive logging capture through `MockContext.logs` list for debugging test execution and verifying internal decision-making processes.

########### Code Usage Examples

Essential test execution pattern for validating hierarchical dependency planning:

```python
# Create isolated test environment with realistic directory structure
with tempfile.TemporaryDirectory() as temp_dir:
    source_root = Path(temp_dir)
    (source_root / "src" / "components" / "buttons").mkdir(parents=True)
    
    # Configure indexing with minimal exclusions for focused testing
    config = IndexingConfig(
        output_config=OutputConfig(knowledge_output_directory=knowledge_dir),
        content_filtering=ContentFilteringConfig(
            excluded_extensions={".pyc", ".pyo"},
            excluded_directories={".git", "__pycache__"}
        )
    )
    
    # Test selective cascading by marking specific directory for rebuild
    decision_engine = RebuildDecisionEngine(config)
    report = DecisionReport()
    buttons_decision = RebuildDecision(
        path=source_root / "src" / "components" / "buttons",
        outcome=DecisionOutcome.REBUILD,
        reason=DecisionReason.COMPREHENSIVE_STALENESS
    )
    report.add_rebuild_decision(buttons_decision)
    
    # Verify cascading propagation to ancestors only
    cascaded_count = await decision_engine._propagate_cascading_decisions(
        None, source_root, report, ctx
    )
    assert report.get_decision_for_path(source_root / "src").should_rebuild
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_http_core_functionality.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This focused test suite validates core HTTP functionality within the JESSE Framework MCP Server HTTP formatting infrastructure, specifically designed to verify HTTP status code constants, error handling mechanisms, and content criticality classification systems. The test suite provides comprehensive validation capabilities for HTTP status mapping, exception-to-status conversion, and case-insensitive criticality normalization. Key semantic entities include `XAsyncHttpStatus`, `XAsyncHttpErrorHandler`, `XAsyncContentCriticality`, `TestHttpStatus`, `TestHttpErrorHandler`, `TestContentCriticality`, `get_default_message`, `generate_error_content`, `detect_error_from_exception`, `validate`, `pytest` testing framework, `OK`, `CONTEXT_DEPENDENT`, `CONTEXT_DEPENDENT_IMMEDIATE`, `NOT_FOUND`, `FORBIDDEN`, `INTERNAL_SERVER_ERROR` status constants, `FileNotFoundError`, `PermissionError` exception mapping, and `CRITICAL`, `INFORMATIONAL` criticality levels. The testing framework implements three-phase validation through HTTP status constant verification, error handling template testing, and content criticality normalization validation with comprehensive edge case coverage.

##### Main Components

The test suite contains three primary test classes: `TestHttpStatus` with three test methods validating status code constants and default message mapping functionality, `TestHttpErrorHandler` with five test methods verifying error content generation and exception-to-status mapping behavior, and `TestContentCriticality` with four test methods testing criticality validation and case normalization. Each test class implements comprehensive assertion-based validation with specific focus areas: status code constant verification, error template formatting validation, exception mapping accuracy, and case-insensitive input handling for criticality levels.

###### Architecture & Design

The architecture follows a focused testing pattern with isolated test classes for different HTTP functionality aspects, utilizing direct method calls and assertion-based validation for comprehensive coverage. The design implements systematic testing through class-based organization with specific test methods for each functional area. Error handling validation is structured with exception simulation and template-based content generation testing. The testing framework uses realistic error scenarios combined with edge case validation to ensure robust HTTP functionality across different input conditions and error states.

####### Implementation Approach

The implementation uses direct class method invocation for status code and error handling validation with comprehensive assertion testing. Status code testing employs constant value verification and message mapping validation through `get_default_message()` method calls. Error handling testing uses exception simulation with `FileNotFoundError` and `PermissionError` instances and template-based content generation validation. Criticality testing implements case normalization validation through various input format combinations including uppercase, lowercase, and mixed case scenarios with invalid input error handling.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.helpers.async_http_formatter:XAsyncContentCriticality` - content criticality validation and normalization
- `jesse_framework_mcp.helpers.async_http_formatter:XAsyncHttpStatus` - HTTP status code constants and message mapping
- `jesse_framework_mcp.helpers.async_http_formatter:XAsyncHttpErrorHandler` - error content generation and exception mapping
- `pytest` (external library) - testing framework with assertion utilities and exception testing

**← Outbound:**
- HTTP formatting validation for JESSE Framework MCP Server resource endpoints
- Error handling verification for MCP resource protocol compliance
- Status code validation for HTTP response generation systems

**⚡ System role and ecosystem integration:**
- **System Role**: Foundation validation component ensuring HTTP core functionality reliability within the JESSE Framework MCP Server HTTP formatting infrastructure
- **Ecosystem Position**: Critical testing utility for HTTP infrastructure components, validating the foundation layer that supports HTTP section formatting and path integration functionality
- **Integration Pattern**: Executed by developers and CI/CD systems to verify HTTP status constants, error handling templates, and criticality classification before HTTP formatting system deployment

######### Edge Cases & Error Handling

Error handling covers unknown status code scenarios with graceful fallback to generic messages, invalid criticality input validation with descriptive error messages, and comprehensive exception mapping testing for various Python exception types. The test suite handles edge cases including empty string inputs, mixed case normalization, and unknown status code handling through fallback mechanisms. Exception testing validates proper mapping of `FileNotFoundError` to 404 status, `PermissionError` to 403 status, and generic exceptions to 500 status with appropriate error content generation. The testing framework provides comprehensive error scenario coverage through `pytest.raises()` context managers and detailed error message validation.

########## Internal Implementation Details

Status code testing uses direct constant value assertions with integer comparison and string message validation. Error content generation testing employs template substitution validation with parameter injection and content format verification. Exception mapping testing creates specific exception instances with message content and validates status code, status message, and error content generation accuracy. Criticality validation testing uses string input normalization with case conversion verification and invalid input error message pattern matching through exception assertion testing.

########### Code Usage Examples

**HTTP status code constant validation and message mapping:**

This example demonstrates how to test HTTP status code constants and their corresponding default messages. The test validates that status codes have correct integer values and proper message mapping functionality.

```python
# Test HTTP status code constants and default message mapping
assert XAsyncHttpStatus.OK == 200
assert XAsyncHttpStatus.NOT_FOUND == 404
assert XAsyncHttpStatus.get_default_message(200) == "OK"
assert XAsyncHttpStatus.get_default_message(404) == "Not Found"
assert XAsyncHttpStatus.get_default_message(999) == "Unknown Status"
```

**Error content generation and exception mapping validation:**

This snippet shows how to test error content generation templates and automatic exception-to-status mapping. The test verifies that different exception types map to appropriate HTTP status codes with proper error content.

```python
# Test error content generation and exception mapping
result_404 = XAsyncHttpErrorHandler.generate_error_content(404, "file://test.md")
assert "Resource not found: file://test.md" == result_404
exc = FileNotFoundError("File not found")
status_code, status_message, error_content = XAsyncHttpErrorHandler.detect_error_from_exception(exc, "file://missing.md")
assert status_code == 404 and status_message == "Not Found"
```

**Content criticality validation with case normalization:**

This example demonstrates how to test content criticality validation and case-insensitive normalization. The test validates that various input formats are properly normalized and invalid inputs raise appropriate errors.

```python
# Test content criticality validation and case normalization
assert XAsyncContentCriticality.validate("CRITICAL") == "CRITICAL"
assert XAsyncContentCriticality.validate("critical") == "CRITICAL"
assert XAsyncContentCriticality.validate("Critical") == "CRITICAL"
with pytest.raises(ValueError) as exc_info:
    XAsyncContentCriticality.validate("invalid")
assert "Invalid criticality 'invalid'" in str(exc_info.value)
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_http_formatting.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This reference file serves as an organizational hub for the split HTTP formatting test suite within the JESSE Framework MCP Server, specifically designed to maintain backward compatibility while providing clear navigation to specialized test modules. The file provides test suite organization capabilities, import aggregation for existing test runners, and comprehensive documentation of the test split architecture. Key semantic entities include `TestHttpStatus`, `TestHttpErrorHandler`, `TestContentCriticality`, `TestHttpStatusLines`, `TestHTTPSectionFormatting`, `TestMultiSectionResponse`, `TestExtractHttpSections`, `TestFormatHttpResponse`, `TestIntegrationWithConstants`, `TestPortablePathResolution`, `TestHttpPath`, `TestPathContentHandling`, `TestPerformanceAndEdgeCases`, `test_http_core_functionality.py`, `test_http_section_formatting.py`, `test_http_path_integration.py`, `ImportError` exception handling, `warnings` module integration, and `__all__` export list management. The reference architecture implements backward compatibility through re-export patterns and graceful fallback with placeholder classes for missing modules.

##### Main Components

The file contains three primary organizational sections: comprehensive docstring documentation explaining the test suite split rationale and module organization, conditional import statements with try-catch blocks for the three specialized test modules, and fallback placeholder class definitions for graceful error handling. The import section aggregates twelve test classes across three functional domains: core HTTP functionality, section formatting, and path integration. The `__all__` export list provides explicit backward compatibility for existing test runners, while the exception handling section creates empty placeholder classes with descriptive docstrings when imports fail.

###### Architecture & Design

The architecture follows a reference file pattern with clear separation of concerns through module-based organization, utilizing conditional imports and graceful degradation for missing dependencies. The design implements backward compatibility preservation through comprehensive re-exports and placeholder fallbacks, ensuring existing test runners continue functioning without modification. Error handling is structured with `ImportError` exception catching and `warnings` module integration for developer notification. The organizational framework uses docstring-based documentation combined with explicit module references to guide developers to appropriate test locations.

####### Implementation Approach

The implementation uses conditional import statements with try-catch blocks to handle missing specialized test modules gracefully. Module organization employs explicit relative imports from three specialized files covering distinct functional areas. Backward compatibility uses `__all__` list definition with comprehensive test class re-exports for existing test discovery mechanisms. The fallback strategy implements placeholder class creation with descriptive docstrings indicating actual test locations when imports fail, preventing import errors in dependent systems.

######## External Dependencies & Integration Points

**→ Inbound:**
- `tests/test_http_core_functionality.py:TestHttpStatus` - HTTP status constants and utilities testing
- `tests/test_http_core_functionality.py:TestHttpErrorHandler` - error handling and exception mapping testing
- `tests/test_http_core_functionality.py:TestContentCriticality` - content criticality validation testing
- `tests/test_http_section_formatting.py:TestHttpStatusLines` - HTTP status line functionality testing
- `tests/test_http_section_formatting.py:TestHTTPSectionFormatting` - section formatting validation testing
- `tests/test_http_section_formatting.py:TestMultiSectionResponse` - multi-section response handling testing
- `tests/test_http_section_formatting.py:TestExtractHttpSections` - section extraction functionality testing
- `tests/test_http_section_formatting.py:TestFormatHttpResponse` - response formatting integration testing
- `tests/test_http_section_formatting.py:TestIntegrationWithConstants` - constants integration testing
- `tests/test_http_path_integration.py:TestPortablePathResolution` - portable path resolution testing
- `tests/test_http_path_integration.py:TestHttpPath` - HttpPath dual-path functionality testing
- `tests/test_http_path_integration.py:TestPathContentHandling` - path content loading testing
- `tests/test_http_path_integration.py:TestPerformanceAndEdgeCases` - performance and edge case testing
- `warnings` (external library) - warning notification system for import failures

**← Outbound:**
- Test discovery systems requiring backward compatibility with original test structure
- CI/CD pipelines expecting unified test class imports from single module
- Development tools and IDEs using test class references for navigation

**⚡ System role and ecosystem integration:**
- **System Role**: Organizational reference point maintaining backward compatibility for HTTP formatting test suite after modular split within JESSE Framework MCP Server testing infrastructure
- **Ecosystem Position**: Central compatibility layer ensuring seamless transition from monolithic to modular test organization without breaking existing test runners or development workflows
- **Integration Pattern**: Used by test discovery systems, CI/CD pipelines, and development tools requiring unified access to HTTP formatting test classes across specialized modules

######### Edge Cases & Error Handling

Error handling covers missing specialized test module scenarios with `ImportError` exception catching and graceful fallback to placeholder classes. The file handles import failures through `warnings.warn()` notifications with detailed guidance for resolving missing module issues. Edge cases include partial module availability, circular import dependencies, and test runner compatibility issues with split architecture. The fallback mechanism provides empty placeholder classes with descriptive docstrings to prevent import errors while clearly indicating actual test locations for developer guidance.

########## Internal Implementation Details

Import organization uses relative import syntax with explicit test class enumeration for clear dependency tracking. Placeholder class creation employs dynamic class definition with descriptive docstrings indicating actual test module locations. The `__all__` export list maintains alphabetical organization within functional groupings for consistent test discovery. Exception handling uses `ImportWarning` category for appropriate warning classification and developer tool integration.

########### Code Usage Examples

**Backward compatible test class import pattern:**

This example demonstrates how existing test runners can continue importing test classes without modification after the test suite split. The reference file maintains all original import paths through re-exports.

```python
# Import test classes using original import pattern for backward compatibility
from test_http_formatting import (
    TestHttpStatus,
    TestHTTPSectionFormatting,
    TestHttpPath
)
# All test classes remain accessible through original import structure
```

**Graceful fallback handling for missing modules:**

This snippet shows how the reference file handles missing specialized test modules through placeholder classes and warning notifications. The fallback prevents import errors while guiding developers to resolve missing dependencies.

```python
# Graceful handling of missing specialized test modules
try:
    from .test_http_core_functionality import TestHttpStatus
except ImportError as e:
    warnings.warn(f"Could not import split test modules: {e}")
    class TestHttpStatus:
        """Placeholder - actual tests in test_http_core_functionality.py"""
        pass
```

**Comprehensive test class re-export for compatibility:**

This example demonstrates how the reference file maintains backward compatibility through explicit re-exports in the `__all__` list. The pattern ensures test discovery systems continue finding all test classes through the original module.

```python
# Comprehensive re-export pattern for backward compatibility
__all__ = [
    'TestHttpStatus', 'TestHttpErrorHandler', 'TestContentCriticality',
    'TestHttpStatusLines', 'TestHTTPSectionFormatting', 'TestMultiSectionResponse',
    'TestPortablePathResolution', 'TestHttpPath', 'TestPathContentHandling'
]
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_http_path_integration.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This comprehensive test suite validates the `XAsyncHttpPath` class and portable path resolution functionality within the JESSE Framework MCP Server, specifically designed to verify cross-platform path variable substitution, HTTP formatting integration, and file content handling. The test suite provides extensive validation capabilities for dual-path functionality, environment variable resolution, and HTTP section formatting with automatic content loading. Key semantic entities include `XAsyncHttpPath`, `format_http_section`, `resolve_portable_path`, `TestPortablePathResolution`, `TestHttpPath`, `TestPathContentHandling`, `TestPerformanceAndEdgeCases` test classes, `{PROJECT_ROOT}`, `{HOME}`, `{CLINE_RULES}`, `{CLINE_WORKFLOWS}` path variables, `pytest` testing framework, `tempfile` temporary file handling, and `CONTENT_TYPES`, `SECTION_TYPES`, `RULE_CRITICALITY_MAP` constants. The testing framework implements comprehensive validation through portable path resolution testing, dual-path storage verification, automatic Last-Modified header generation, and performance testing with large content blocks.

##### Main Components

The test suite contains four primary test classes: `TestPortablePathResolution` with six test methods for environment variable substitution validation, `TestHttpPath` with twelve test methods for dual-path functionality and HTTP integration testing, `TestPathContentHandling` with eight test methods for file content loading and error handling validation, and `TestPerformanceAndEdgeCases` with three test methods for performance and boundary condition testing. Each test class implements comprehensive assertion-based validation with temporary file creation, cross-platform path testing, and detailed error scenario coverage including missing files, invalid types, and Unicode content handling.

###### Architecture & Design

The architecture follows a comprehensive testing pattern with isolated test classes for different functional aspects, utilizing `pytest` framework conventions and temporary file management for realistic testing scenarios. The design implements cross-platform compatibility testing through environment variable resolution validation and path manipulation verification. Error handling is structured with exception testing using `pytest.raises()` context managers and assertion-based validation for expected behaviors. The testing framework uses realistic file operations combined with HTTP formatting integration to validate end-to-end functionality from path resolution through content delivery.

####### Implementation Approach

The implementation uses direct class instantiation with `XAsyncHttpPath()` for dual-path testing and `resolve_portable_path()` for variable substitution validation. File content testing employs `tempfile.NamedTemporaryFile()` with UTF-8 encoding for realistic file operations and cleanup management. HTTP integration testing uses `format_http_section()` with various parameter combinations to validate header generation and content handling. The testing strategy implements both positive path validation and comprehensive error condition testing through invalid inputs, missing files, and edge cases like empty content and Unicode characters.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.helpers.async_http_formatter:format_http_section` - HTTP section formatting function
- `jesse_framework_mcp.helpers.async_http_formatter:XAsyncHttpPath` - dual-path HTTP path class
- `jesse_framework_mcp.helpers.path_utils:resolve_portable_path` - portable path resolution utility
- `jesse_framework_mcp.constants:CONTENT_TYPES` - content type constants
- `jesse_framework_mcp.constants:SECTION_TYPES` - section type constants
- `jesse_framework_mcp.constants:RULE_CRITICALITY_MAP` - criticality mapping constants
- `pytest` (external library) - testing framework and assertion utilities
- `tempfile` (external library) - temporary file creation and management
- `pathlib:Path` (external library) - cross-platform path manipulation
- `re` (external library) - regular expression pattern matching for RFC 7231 validation

**← Outbound:**
- Test validation reports for CI/CD pipeline integration
- Cross-platform compatibility verification for deployment systems
- HTTP formatting validation for MCP server resource endpoints

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive validation component ensuring XAsyncHttpPath class reliability and portable path resolution accuracy within the JESSE Framework MCP Server ecosystem
- **Ecosystem Position**: Critical testing utility for HTTP path integration functionality, validating the bridge between cross-platform path resolution and HTTP content delivery mechanisms
- **Integration Pattern**: Executed by developers and CI/CD systems to verify portable path functionality, HTTP formatting integration, and file content handling before MCP server deployment across different operating systems

######### Edge Cases & Error Handling

Error handling covers missing file scenarios with automatic 404 HTTP response generation, invalid content type parameters with `TypeError` exceptions, empty file content with `ValueError` validation, and Unicode character preservation with accurate byte-length calculation. The test suite handles cross-platform path resolution failures through environment variable validation and temporary file cleanup through try-finally blocks. Edge cases include multiple variable combinations in single paths, partial variable resolution with literal text preservation, filesystem permission issues, and RFC 7231 timestamp format validation. The testing framework provides comprehensive error scenario coverage through exception testing and assertion-based validation with detailed error message verification.

########## Internal Implementation Details

Path resolution testing uses direct comparison between original and resolved paths with `get_original_path()` and `get_resolved_path()` method validation. File content testing creates temporary files with specific encodings and validates automatic cleanup through context managers and explicit `unlink()` calls. HTTP integration testing inspects generated headers through string parsing and regular expression matching for timestamp format validation. Performance testing uses large content generation through string multiplication and validates content-length accuracy through UTF-8 byte encoding calculations.

########### Code Usage Examples

**Basic portable path resolution with environment variables:**

This example demonstrates how to test portable path variable resolution across different environments. The test validates that environment variables are properly substituted while preserving original path structure.

```python
# Test PROJECT_ROOT variable resolution to current working directory
location = "file://{PROJECT_ROOT}/.knowledge/test.md"
resolved = resolve_portable_path(location)
assert "{PROJECT_ROOT}" not in resolved
assert str(Path.cwd()) in resolved
```

**XAsyncHttpPath dual-path functionality with HTTP integration:**

This snippet shows how to test XAsyncHttpPath dual-path storage and HTTP formatting integration. The test verifies that original portable paths are preserved for headers while resolved paths enable filesystem operations.

```python
# Test HttpPath dual-path functionality with format_http_section integration
original_path = "file://{HOME}/Cline/Rules/JESSE_HINTS.md"
http_path = XAsyncHttpPath(original_path)
result = format_http_section(
    content="# Test Content",
    content_type="text/markdown",
    criticality="CRITICAL",
    location=http_path
)
assert f"Content-Location: {original_path}" in result
```

**File content handling with automatic Last-Modified headers:**

This example demonstrates how to test automatic file content loading and Last-Modified header generation. The test validates that XAsyncHttpPath objects automatically read file content and generate appropriate HTTP headers.

```python
# Test automatic Last-Modified header generation with file content
with tempfile.NamedTemporaryFile(mode='w', delete=False, suffix='.md', encoding='utf-8') as tmp_file:
    tmp_file.write("# Test Content")
    tmp_http_path = XAsyncHttpPath(tmp_file.name)
result = format_http_section(content=tmp_http_path, content_type="text/markdown")
assert "Last-Modified:" in result
assert "# Test Content" in result
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_http_section_formatting.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This file provides comprehensive test coverage for HTTP section formatting and multi-section response functionality within the JESSE Framework MCP server, validating HTTP/1.1-like status line generation, content-length accuracy, and multi-part response assembly. The file ensures proper HTTP response generation through testing of `format_http_section` with automatic error detection, `format_multi_section_response` for combining sections, `extract_http_sections_from_multi_response` for content extraction, and `format_http_response` for simple API responses. Key semantic entities include `format_http_section` for individual section formatting, `XAsyncHttpPath` for file-based content loading, `XAsyncContentCriticality` for content priority validation, `HTTP_BOUNDARY_MARKER` for section separation, `CONTENT_TYPES` for media type validation, and `pytest` framework for comprehensive test execution. The testing architecture validates HTTP infrastructure through status code verification (200, 240, 241, 403, 404, 500), byte-perfect content-length calculation, and multi-section protocol definition integration.

##### Main Components

The file contains six primary test classes: `TestHttpStatusLines` validates HTTP/1.1 status line functionality with automatic error detection and manual overrides, `TestHTTPSectionFormatting` tests comprehensive HTTP section formatting with parameter validation, `TestMultiSectionResponse` validates combining multiple sections with protocol definitions, `TestExtractHttpSections` tests extraction of HTTP sections from multi-responses, `TestFormatHttpResponse` validates simple HTTP response formatting for API integration, and `TestIntegrationWithConstants` ensures proper integration with JESSE Framework constants. Each test class focuses on specific HTTP formatting aspects, providing comprehensive coverage of status handling, content formatting, section combination, and framework integration.

###### Architecture & Design

The test architecture follows pytest class-based organization with clear separation of HTTP formatting concerns across different functional layers. `TestHttpStatusLines` validates the foundation layer of HTTP status code handling with automatic error detection from filesystem exceptions, while `TestHTTPSectionFormatting` tests the core formatting layer with comprehensive parameter validation. `TestMultiSectionResponse` focuses on the aggregation layer that combines individual sections with protocol definitions, and `TestExtractHttpSections` tests the parsing layer for content extraction. The design emphasizes comprehensive edge case coverage, realistic filesystem testing with temporary files, and integration validation with framework constants for real-world compatibility.

####### Implementation Approach

Tests utilize temporary file creation with `tempfile.NamedTemporaryFile` for realistic filesystem error scenarios, ensuring proper cleanup with try-finally blocks and permission restoration. HTTP status line testing validates automatic error detection by creating actual Python exceptions (`FileNotFoundError`, `PermissionError`) and verifying appropriate status code mapping. Content-length accuracy testing employs UTF-8 encoding validation with international characters to ensure byte-perfect calculations. Multi-section response testing combines pre-formatted sections and validates protocol definition inclusion with XML-wrapped preambule functionality. The implementation strategy emphasizes comprehensive parameter validation, realistic error condition simulation, and integration testing with actual framework constants.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.helpers.async_http_formatter:format_http_section` - core HTTP section formatting with status line generation
- `jesse_framework_mcp.helpers.async_http_formatter:format_multi_section_response` - multi-section response assembly with protocol definitions
- `jesse_framework_mcp.helpers.async_http_formatter:XAsyncHttpPath` - file-based content loading with automatic error detection
- `jesse_framework_mcp.helpers.async_http_formatter:extract_http_sections_from_multi_response` - content extraction from multi-responses
- `jesse_framework_mcp.constants:HTTP_BOUNDARY_MARKER` - section separation marker for multi-part responses
- `jesse_framework_mcp.constants:CONTENT_TYPES` - media type constants for integration validation
- `pytest` (external library) - testing framework for comprehensive HTTP functionality validation
- `tempfile` (external library) - temporary file creation for filesystem error testing
- `stat` (external library) - file permission manipulation for access control testing

**← Outbound:**
- `test_http_formatting.py` - originally contained these tests before file split for organization
- `CI/CD pipeline/` - automated validation of HTTP section formatting reliability
- `development workflow/` - ensures HTTP response generation consistency across JESSE Framework MCP server

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring JESSE Framework MCP server HTTP section formatting operates correctly with proper status codes, content-length accuracy, and multi-section response assembly
- **Ecosystem Position**: Core testing infrastructure validating fundamental HTTP response generation, error handling, and multi-part content formatting mechanisms
- **Integration Pattern**: Executed by developers during development and CI/CD systems for continuous validation of HTTP formatting functionality across different content types and error scenarios

######### Edge Cases & Error Handling

Error handling validation includes automatic status code detection with `FileNotFoundError` mapping to 404, `PermissionError` mapping to 403, and generic exceptions mapping to 500 status codes. Content validation tests empty content raises `ValueError`, empty header names/values raise descriptive errors, and whitespace-only parameters trigger appropriate validation failures. Multi-section response testing validates empty section arrays raise errors, whitespace-only sections are rejected, and protocol definition inclusion works correctly. UTF-8 content-length calculation testing ensures byte-perfect accuracy with international characters, emoji, and special characters. Permission testing handles system-dependent behavior with `pytest.skip()` for unreliable permission enforcement scenarios.

########## Internal Implementation Details

The test implementation uses `tempfile.NamedTemporaryFile` with explicit `encoding='utf-8'` and `delete=False` for controlled file lifecycle management. Permission testing employs `stat.S_IWRITE` for write-only permissions and `chmod()` for access control simulation. Content-length validation compares `len(content.encode('utf-8'))` against header values for byte-perfect accuracy verification. Multi-section response testing validates XML tag wrapping for preambule content and protocol definition positioning. Status line testing accesses internal `_resolved_path` attribute for cleanup operations and validates three-tuple return format from error detection methods. Header ordering validation uses line-by-line parsing to verify Content-Location and Content-Length appear before other headers.

########### Code Usage Examples

Basic HTTP section formatting demonstrates standard parameter usage with automatic 200 OK status generation. This pattern provides the foundation for all HTTP section formatting in the JESSE Framework.

```python
# Basic HTTP section formatting with automatic status detection
result = format_http_section(
    content="# Test Content\nThis is a test.",
    content_type="text/markdown",
    criticality="CRITICAL",
    description="Test Content",
    section_type="framework-rule",
    location="file://{HOME}/test.md"
)
# Generates: X-ASYNC-HTTP/1.1 200 OK with proper headers and content
```

Manual status override functionality allows complete control over HTTP status codes and error content generation. This approach enables custom error handling and specialized status scenarios.

```python
# Manual status override with custom error content
result = format_http_section(
    content="Original content",
    content_type="text/plain",
    criticality="CRITICAL",
    description="Custom Error Test",
    section_type="error-section",
    location="service://maintenance/",
    status_code=503,
    status_message="Service Unavailable",
    error_content="Service is temporarily unavailable due to maintenance."
)
# Generates: X-ASYNC-HTTP/1.1 503 Service Unavailable with custom error content
```

Multi-section response assembly combines individual HTTP sections with automatic protocol definition inclusion. This pattern enables complex multi-part responses with proper section separation and documentation.

```python
# Multi-section response with protocol definition and preambule
section1 = format_http_section(content="Content 1", content_type="text/plain", 
                              criticality="CRITICAL", description="Section 1",
                              section_type="framework-rule", location="file://{HOME}/section1.txt")

section2 = format_http_section(content="Content 2", content_type="text/markdown",
                              criticality="INFORMATIONAL", description="Section 2", 
                              section_type="knowledge-base", location="file://{HOME}/section2.md")

result = format_multi_section_response(section1, section2, 
                                     preambule="Important contextual information")
# Generates: Multi-part response with XML-wrapped preambule and protocol definition
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_new_resources.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test script validates README.md resource functionality within the JESSE Framework MCP Server knowledge management system, specifically designed to verify knowledge base resource registration and file accessibility. The script provides automated testing capabilities for knowledge resource validation, file existence verification, and content structure analysis. Key semantic entities include `register_knowledge_resources`, `test_git_clones_readme`, `test_pdf_knowledge_readme`, `asyncio` async execution, `fastmcp.Context` integration, and `.knowledge/` directory structure with `git-clones/README.md` and `pdf-knowledge/README.md` paths. The testing framework implements emoji-based status reporting and graceful handling of missing knowledge directories for new installations.

##### Main Components

The script contains three primary async test functions: `test_git_clones_readme()` for git clones knowledge base validation, `test_pdf_knowledge_readme()` for PDF knowledge directory testing, and `test_resource_registration()` for resource registration verification. The `main()` function orchestrates sequential test execution with formatted output headers. Each test function implements file existence checking, content loading with UTF-8 encoding, and expected content pattern matching for knowledge base validation.

###### Architecture & Design

The architecture follows a sequential testing pattern with individual resource validation followed by registration testing. The design implements graceful degradation for missing directories, treating them as expected conditions for new installations rather than failures. Error handling is structured with try-catch blocks around each test function, providing isolated failure reporting. The testing framework uses file system operations combined with content analysis to validate both resource availability and structural integrity.

####### Implementation Approach

The implementation uses direct file system access through `os.path.exists()` for file validation and standard file reading with UTF-8 encoding for content analysis. Content validation employs string containment checks for expected headers like "Git Clone Knowledge Bases Index" and knowledge base references including "FastMCP" and "Cline". The testing strategy differentiates between critical failures (file access errors) and expected conditions (missing directories in new installations) through warning versus error status indicators.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.resources.knowledge:register_knowledge_resources` - knowledge resource registration function
- `jesse_framework_mcp.main:server` - MCP server instance import
- `fastmcp:Context` (external library) - MCP context interface
- `asyncio` (external library) - async execution framework
- `.knowledge/git-clones/README.md` - git clones knowledge base index file
- `.knowledge/pdf-knowledge/README.md` - PDF knowledge base index file
- `os` (external library) - file system operations
- `pathlib:Path` (external library) - path manipulation utilities

**← Outbound:**
- Console test output for validation reporting
- Test status indicators for CI/CD pipeline integration
- Knowledge resource validation reports for deployment verification

**⚡ System role and ecosystem integration:**
- **System Role**: Validation component ensuring knowledge base resources are properly accessible and registered within the MCP server ecosystem
- **Ecosystem Position**: Testing utility for knowledge management system integrity, validating the bridge between file system knowledge bases and MCP resource endpoints
- **Integration Pattern**: Executed by developers and deployment systems to verify knowledge resource availability before MCP server activation

######### Edge Cases & Error Handling

Error handling covers missing knowledge directories (treated as warnings for new installations), file access permission issues, UTF-8 encoding failures, and resource registration exceptions. The script handles missing expected content patterns through conditional validation reporting. Edge cases include partial knowledge directory structures, corrupted README files, and resource registration conflicts. The testing framework provides differentiated status reporting using emoji indicators to distinguish between critical errors, warnings, and successful validations.

########## Internal Implementation Details

File existence checking uses `os.path.exists()` with relative path resolution from the script execution directory. Content validation reads entire files into memory using UTF-8 encoding with automatic error handling. String pattern matching uses case-sensitive containment checks for specific headers and knowledge base names. The resource registration test performs function invocation without parameter validation, focusing on execution success rather than functional correctness.

########### Code Usage Examples

**Basic knowledge resource testing execution:**

This code snippet demonstrates how to execute all knowledge resource validation tests in sequence. The main function orchestrates comprehensive testing of git clones, PDF knowledge, and registration components.

```python
# Execute all knowledge resource validation tests
await main()
# Runs git clones, PDF knowledge, and registration tests sequentially
```

**Individual git clones README validation:**

This example shows how to test specific knowledge base accessibility and content structure validation. The function validates both file existence and expected content patterns for git clones knowledge base.

```python
# Test git clones knowledge base accessibility and content structure
await test_git_clones_readme()
# Validates .knowledge/git-clones/README.md existence and expected content patterns
```

**Resource registration verification:**

This snippet demonstrates how to verify knowledge resources register without errors in the MCP server. The registration function confirms that knowledge base resources are accessible through MCP endpoints.

```python
# Verify knowledge resources register without errors
register_knowledge_resources()
print("✅ Knowledge resources registered successfully")
# Confirms MCP server can access knowledge base resources
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_project_base_indexing_rule.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test script validates the project-base indexing business rule implementation for the Jesse Framework MCP system, specifically testing that knowledge files are stored in `{PROJECT_ROOT}/.knowledge/project-base/` with directory structure mirroring when `handler_type="project-base"`. The script provides comprehensive validation of mandatory project-base subdirectory usage, configuration detection, and fallback behavior mechanisms. Key semantic entities include `KnowledgeBuilder`, `IndexingConfig`, `OutputConfig`, `handler_type`, `project-base`, `git-clones`, `tempfile`, `pathlib.Path`, `_get_knowledge_file_path`, and `.knowledge/project-base/` directory structure. The testing framework validates that all configurations now use the project-base/ subdirectory regardless of handler type, eliminating backward compatibility for consistent knowledge file organization.

##### Main Components

The script contains three primary test functions: `test_project_base_indexing_path_rule()` validates correct directory structure usage with project-base indexing, `test_business_rule_configuration_detection()` tests configuration detection between project-base and git-clones handler types, and `test_mandatory_project_base_subdirectory()` validates that project-base/ subdirectory is mandatory regardless of configuration. Supporting components include temporary directory creation using `tempfile.TemporaryDirectory()`, path validation logic comparing expected vs actual knowledge file paths, and comprehensive test result reporting with pass/fail status indicators.

###### Architecture & Design

The testing architecture follows an isolated environment pattern using `tempfile.TemporaryDirectory()` for each test scenario, ensuring no cross-test contamination. The design validates business rule enforcement by creating realistic project structures with nested directories (`src/components/ui/buttons/`) and verifying knowledge file path generation follows the mandatory project-base/ pattern. Each test creates `KnowledgeBuilder` instances with different `IndexingConfig` settings to validate that all configurations produce identical project-base/ subdirectory paths, confirming the elimination of backward compatibility.

####### Implementation Approach

The implementation uses direct path comparison validation by calling `_get_knowledge_file_path()` method on `KnowledgeBuilder` instances and comparing results against expected paths. Tests validate multi-level directory structure preservation within project-base/, fallback behavior when relative path calculation fails, and flat structure handling when no source_root is provided. The approach includes comprehensive edge case testing with unrelated directory paths and various configuration combinations to ensure consistent project-base/ subdirectory usage across all scenarios.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.knowledge_builder:KnowledgeBuilder` - core knowledge file path generation testing
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration model validation
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:OutputConfig` - output configuration testing
- `tempfile` (standard library) - isolated test environment creation
- `pathlib.Path` (standard library) - file system path manipulation and validation

**← Outbound:**
- Test execution results consumed by CI/CD validation systems
- Business rule compliance reports for deployment verification
- Configuration validation metrics for system reliability monitoring

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring project-base indexing business rule compliance across the Jesse Framework MCP knowledge base system
- **Ecosystem Position**: Core testing infrastructure validating the foundation of knowledge file organization and directory structure consistency
- **Integration Pattern**: Executed by developers and CI systems to validate business rule enforcement before deployment, ensuring all knowledge files follow mandatory project-base/ subdirectory structure

######### Edge Cases & Error Handling

The tests validate missing source_root scenarios (should use flat structure in project-base/), unrelated directory paths (should use fallback naming in project-base/), multi-level nested directories (should preserve structure within project-base/), and different handler_type configurations (should all use project-base/ subdirectory). Error handling includes assertion failures with descriptive messages for incorrect paths, comprehensive path comparison logging, and detailed test result reporting with specific expected vs actual path information. The tests specifically validate that no backward compatibility exists and all configurations produce consistent project-base/ subdirectory usage.

########## Internal Implementation Details

Internal mechanisms include temporary directory structure creation with nested paths like `src/components/ui/buttons/`, direct method invocation on `KnowledgeBuilder._get_knowledge_file_path()` for path generation testing, and comprehensive path validation comparing expected project-base/ patterns against actual results. The testing framework creates multiple `IndexingConfig` instances with different `handler_type` values to validate consistent behavior, while path comparison logic ensures exact matching of expected `.knowledge/project-base/` subdirectory structures with proper knowledge base file naming conventions.

########### Code Usage Examples

Essential project-base indexing path validation pattern:

```python
# This pattern demonstrates validation of mandatory project-base subdirectory usage regardless of handler type
# All configurations must produce paths within .knowledge/project-base/ directory structure
output_config = OutputConfig(knowledge_output_directory=knowledge_dir)
config_with_project_base = IndexingConfig(
    handler_type="project-base",
    description="Test configuration with project-base indexing",
    output_config=output_config
)

builder = KnowledgeBuilder(config_with_project_base)
knowledge_path = builder._get_knowledge_file_path(test_directory, source_root)
expected_path = knowledge_dir / "project-base" / "src" / "components" / "components_kb.md"
```

Configuration detection and validation testing:

```python
# This pattern validates that different handler types still use project-base subdirectory (no backward compatibility)
# Both project-base and git-clones configurations produce identical path structures
project_base_config = IndexingConfig(handler_type="project-base")
regular_config = IndexingConfig(handler_type="git-clones")

builder_project_base = KnowledgeBuilder(project_base_config)
builder_regular = KnowledgeBuilder(regular_config)

project_base_path = builder_project_base._get_knowledge_file_path(test_directory, source_root)
regular_path = builder_regular._get_knowledge_file_path(test_directory, source_root)

# Both paths should be identical and use project-base/ subdirectory
assert project_base_path == regular_path
```

Multi-level directory structure validation:

```python
# This pattern validates that complex nested directory structures are preserved within project-base subdirectory
# Deep directory hierarchies maintain their structure under the mandatory project-base/ root
deep_directory = source_root / "src" / "components" / "ui" / "buttons"
deep_path = builder._get_knowledge_file_path(deep_directory, source_root)

expected_deep_path = knowledge_dir / "project-base" / "src" / "components" / "ui" / "buttons" / "buttons_kb.md"
assert deep_path == expected_deep_path
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_project_indexing_integration.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This file provides comprehensive integration testing for the `HierarchicalIndexer` system by executing real-world project indexing on the actual JESSE Framework codebase. It validates the knowledge base indexing system's ability to handle authentic project complexity, file structures, and processing scenarios through direct execution against the live project root. The integration test offers configurable rebuild modes (`--full-rebuild`, `--kb-only-rebuild`) enabling targeted testing strategies from complete system rebuilds to surgical KB regeneration. Key semantic entities include `HierarchicalIndexer`, `IndexingConfig`, `MockContext`, `ProcessingStatus`, `ensure_project_root`, `get_default_config`, `IndexingMode`, `ProcessingStats`, and `FastMCP` protocol simulation, enabling comprehensive validation of the knowledge base hierarchical indexing pipeline with real project data and authentic edge cases.

##### Main Components

The test suite centers around the `MockContext` class that simulates `FastMCP` Context interface for message capture and monitoring, the `test_real_project_indexing` async function that orchestrates the complete integration test workflow, and utility functions `delete_kb_files` and `delete_analysis_files` for managing rebuild scenarios. The `main` function provides command-line interface with argument parsing for different rebuild modes. The integration leverages `HierarchicalIndexer` as the primary system under test, configured through `IndexingConfig` with project-specific settings and exclusions.

###### Architecture & Design

The architecture follows a comprehensive integration testing pattern with mock context simulation, real project targeting, and configurable rebuild strategies. The design separates concerns between message capture (`MockContext`), file management utilities, and the main test orchestration. The system employs a three-tier rebuild approach: incremental mode for normal operation, KB-only rebuild for surgical testing, and full rebuild for complete system validation. Debug artifact preservation enables post-test analysis through dedicated temporary directories with structured output organization.

####### Implementation Approach

The implementation uses async/await patterns throughout for compatibility with the `HierarchicalIndexer` async interface. Project root detection employs `ensure_project_root()` with comprehensive error handling for dynamic environment adaptation. Configuration management leverages `get_default_config('project-base')` with targeted overrides for integration testing parameters including file size limits, batch processing, and concurrency controls. Success criteria evaluation uses multiple validation checkpoints including completion status, file processing statistics, message analysis, and debug artifact generation.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.hierarchical_indexer:HierarchicalIndexer` - core indexing system under test
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration management
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:ProcessingStatus` - status enumeration
- `jesse_framework_mcp.helpers.path_utils:ensure_project_root` - dynamic project root detection
- `jesse_framework_mcp.knowledge_bases.indexing.defaults:get_default_config` - default configuration provider
- `argparse` (external library) - command-line argument parsing
- `asyncio` (external library) - async execution framework
- `pathlib.Path` (external library) - path manipulation utilities

**← Outbound:**
- `/tmp/jesse_project_indexing_integration_test/` - debug artifact directory for analysis
- `project_root/.knowledge/` - knowledge base output directory structure
- `stdout` - comprehensive test progress and result reporting
- `exit codes` - process exit status for CI/CD integration

**⚡ System role and ecosystem integration:**
- **System Role**: Critical integration validation component ensuring the knowledge base indexing system functions correctly with real-world project complexity and file structures
- **Ecosystem Position**: Core testing infrastructure component validating the entire indexing pipeline from configuration through execution to output generation
- **Integration Pattern**: Executed by developers and CI/CD systems for comprehensive system validation, consuming actual project files and generating debug artifacts for analysis

######### Edge Cases & Error Handling

The test handles project root detection failures with specific error messages and graceful degradation. File processing errors are captured through the `MockContext` message system with categorized error collection and analysis. The system accommodates partial failures through success rate calculations allowing up to 50% file processing failures while maintaining overall test validity. Configuration errors, indexing exceptions, and setup failures are caught with detailed traceback reporting. Debug directory creation failures and cleanup issues are handled with appropriate fallback mechanisms.

########## Internal Implementation Details

The `MockContext` class maintains separate message lists (`info_messages`, `debug_messages`, `warning_messages`, `error_messages`) with real-time console output for monitoring. File deletion utilities use `rglob` patterns for comprehensive file discovery with relative path reporting for user feedback. Configuration overrides target specific integration testing requirements including 2MB file size limits, batch size of 5, and single concurrent operation for stability. Success criteria evaluation uses dictionary-based validation with boolean logic for clear pass/fail determination. Debug artifact preservation uses temporary directory structures with systematic file organization for post-test analysis.

########### Code Usage Examples

**Basic integration test execution with incremental processing:**
```python
# Run standard integration test with existing cache
python test_project_indexing_integration.py
```

**KB-only rebuild for testing synthesis improvements:**
```python
# Fast rebuild preserving analysis files, regenerating only KB files
python test_project_indexing_integration.py --kb-only-rebuild
```

**Complete system rebuild for comprehensive validation:**
```python
# Nuclear rebuild deleting all cached files and regenerating everything
python test_project_indexing_integration.py --full-rebuild
```

**Programmatic test execution with custom configuration:**
```python
# Execute integration test programmatically
success = await test_real_project_indexing(
    full_rebuild=False,
    kb_only_rebuild=True
)
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_project_root.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This comprehensive test script validates project root detection functionality within the JESSE Framework MCP Server, specifically designed to verify project structure identification, environment variable detection, and session initialization capabilities. The script provides extensive testing capabilities for project root discovery mechanisms, Git repository detection, setup guidance generation, and session context initialization with dual-mode operation supporting both testing and content dumping. Key semantic entities include `get_project_root`, `ensure_project_root`, `get_project_relative_path`, `validate_project_setup`, `get_project_setup_guidance`, `get_session_init_context`, `test_project_root_detection`, `test_session_init_with_project_root`, `TestContext`, `unwrap_fastmcp_function`, `JESSE_PROJECT_ROOT` environment variable, `argparse.ArgumentParser`, `asyncio` async execution, and `.git/` directory detection patterns. The testing framework implements five-phase validation through project root detection, environment variable verification, Git repository discovery, setup guidance generation, and project validation with comprehensive session initialization testing.

##### Main Components

The script contains two primary async test functions: `test_project_root_detection()` implementing comprehensive project root validation with five distinct test phases, and `test_session_init_with_project_root()` validating session initialization with project context and dual-mode operation. The `TestContext` class provides mock context functionality with async logging methods for session testing. The `main()` function orchestrates test execution with mode switching, while `parse_arguments()` handles command-line argument processing for dump mode operation. Each test function implements detailed console output with emoji-based status indicators and comprehensive validation reporting.

###### Architecture & Design

The architecture follows a comprehensive testing pattern with isolated test functions for different project detection aspects, utilizing mock context objects and dual-mode operation for both testing and content dumping. The design implements systematic validation through sequential test phases and detailed result inspection with console output formatting. Session initialization testing is structured with FastMCP function unwrapping and context mocking for dependency satisfaction. The testing framework uses realistic project detection scenarios combined with session context validation to ensure proper project root identification and initialization behavior.

####### Implementation Approach

The implementation uses direct function calls to project utility functions for validation and systematic testing through sequential phases with detailed console output. Project root detection employs multiple detection mechanisms including environment variable checking, Git repository discovery, and directory hierarchy traversal. Session initialization testing uses `unwrap_fastmcp_function` for FastMCP decorator removal and mock context creation for dependency injection. The testing strategy implements both positive path validation and comprehensive error handling with detailed result analysis including content length measurement and section counting.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.helpers.path_utils:get_project_root` - primary project root detection function
- `jesse_framework_mcp.helpers.path_utils:ensure_project_root` - project root validation utility
- `jesse_framework_mcp.helpers.path_utils:get_project_relative_path` - relative path calculation
- `jesse_framework_mcp.helpers.path_utils:validate_project_setup` - project validation function
- `jesse_framework_mcp.helpers.project_setup:get_project_setup_guidance` - setup guidance generation
- `jesse_framework_mcp.resources.session_init:get_session_init_context` - session initialization resource
- `utils:unwrap_fastmcp_function` - FastMCP decorator removal utility
- `asyncio` (external library) - async execution framework
- `argparse` (external library) - command-line argument parsing
- `pathlib:Path` (external library) - cross-platform path manipulation
- `os` (external library) - environment variable access

**← Outbound:**
- Console test output with detailed project detection validation reporting
- Session initialization content dumping for resource inspection
- Project validation results for development environment verification

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring project root detection reliability and session initialization functionality within the JESSE Framework MCP Server ecosystem
- **Ecosystem Position**: Essential testing utility for project structure validation, supporting development workflow and deployment verification through comprehensive project detection testing
- **Integration Pattern**: Executed by developers for project setup validation and CI/CD systems for deployment verification, providing dual-mode operation for both testing and content inspection of session initialization resources

######### Edge Cases & Error Handling

Error handling covers missing project root scenarios with setup guidance generation, environment variable detection failures with informational reporting, and Git repository detection issues with hierarchy traversal validation. The script handles session initialization failures through comprehensive exception catching with traceback reporting and mock context dependency satisfaction. Edge cases include missing FastMCP dependencies, invalid project structures, and session initialization timeout scenarios. The testing framework provides comprehensive error scenario coverage through try-catch blocks, detailed console output for debugging, and graceful handling of missing project components.

########## Internal Implementation Details

Project root detection testing uses direct function calls with result validation and detailed console output formatting using emoji prefixes. Environment variable detection employs `os.getenv()` calls with conditional reporting based on variable presence. Git repository detection implements directory hierarchy traversal with `.git/` directory existence checking. Session initialization testing uses FastMCP function unwrapping with mock context creation and comprehensive result analysis including content length measurement and section counting for HTTP response validation.

########### Code Usage Examples

**Basic project root detection with comprehensive validation:**

This example demonstrates how to test project root detection functionality with multiple validation phases. The test validates project root discovery, environment variables, Git repository detection, and project validation.

```python
# Test comprehensive project root detection with validation phases
project_root = get_project_root()
if project_root:
    print(f"✅ Project root detected: {project_root}")
    validation = validate_project_setup()
    for key, value in validation.items():
        print(f"   {key}: {value}")
```

**Session initialization testing with mock context and content analysis:**

This snippet shows how to test session initialization with project root detection and comprehensive result analysis. The test validates session context generation and content structure inspection.

```python
# Test session initialization with mock context and result analysis
class TestContext:
    async def info(self, message): print(f"ℹ️  {message}")
    async def error(self, message): print(f"❌ {message}")
ctx = TestContext()
session_init_func = unwrap_fastmcp_function(get_session_init_context)
result = await session_init_func(ctx)
section_count = result.count("Content-Type:")
print(f"📊 HTTP sections: {section_count}")
```

**Dual-mode operation with argument parsing and content dumping:**

This example demonstrates how to implement dual-mode operation for both testing and content dumping functionality. The script supports command-line arguments for different operational modes.

```python
# Implement dual-mode operation with argument parsing
def parse_arguments():
    parser = argparse.ArgumentParser(description="Test project root detection")
    parser.add_argument("--dump", action="store_true", help="Dump complete resource content")
    return parser.parse_args()
args = parse_arguments()
await main(dump_content=args.dump)
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_root_kb_generation.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This focused test script validates the knowledge base filename generation fix within the JESSE Framework MCP Server hierarchical indexing system, specifically designed to verify that root directories generate `root_kb.md` files instead of `{directory_name}_kb.md` files. The test provides comprehensive validation capabilities for root directory detection, knowledge file path generation, and handler root identification logic. Key semantic entities include `KnowledgeBuilder`, `IndexingConfig`, `DirectoryContext`, `FileContext`, `ProcessingStatus`, `MockContext`, `test_root_kb_filename_generation`, `_get_knowledge_file_path`, `_is_handler_root_directory`, `asyncio` async execution, `tempfile` temporary directory management, and `project-base` handler type configuration. The testing framework implements four-phase validation through project root testing, subdirectory testing, git clone `.kb` directory testing, and root detection logic verification with detailed console output and assertion-based validation.

##### Main Components

The test script contains two primary components: `MockContext` class providing simplified logging functionality without LLM integration, and `test_root_kb_filename_generation()` async function implementing comprehensive filename generation validation. The main execution function `main()` orchestrates test execution with error handling and result reporting. The test function implements four distinct test phases: project root directory validation, regular subdirectory validation, git clone `.kb` directory validation, and root detection logic verification with detailed console output and boolean success tracking.

###### Architecture & Design

The architecture follows a focused testing pattern with isolated validation of specific knowledge base filename generation functionality, utilizing temporary directory structures for realistic testing scenarios. The design implements comprehensive root directory detection testing through multiple directory type scenarios including project roots, subdirectories, and git clone `.kb` directories. Error handling is structured with try-catch blocks and detailed console logging for debugging. The testing framework uses realistic directory structures combined with `KnowledgeBuilder` integration to validate end-to-end filename generation behavior.

####### Implementation Approach

The implementation uses temporary directory creation with `tempfile.TemporaryDirectory()` for isolated testing environments and realistic file system operations. Knowledge builder testing employs direct method calls to `_get_knowledge_file_path()` and `_is_handler_root_directory()` for targeted validation. Configuration setup uses dictionary-based `IndexingConfig.from_dict()` construction with minimal required parameters for testing focus. The testing strategy implements both positive and negative validation through different directory types and root detection scenarios with detailed path comparison and boolean assertion validation.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.knowledge_builder:KnowledgeBuilder` - primary knowledge building class
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration management
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:DirectoryContext` - directory context modeling
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:FileContext` - file context modeling
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:ProcessingStatus` - processing status tracking
- `asyncio` (external library) - async execution framework
- `tempfile` (external library) - temporary directory and file management
- `pathlib:Path` (external library) - cross-platform path manipulation
- `datetime` (external library) - timestamp handling for testing

**← Outbound:**
- Console test output with detailed validation reporting
- Test result validation for knowledge base filename generation integrity
- Exit code reporting for CI/CD pipeline integration

**⚡ System role and ecosystem integration:**
- **System Role**: Focused validation component ensuring knowledge base filename generation correctness within the JESSE Framework MCP Server hierarchical indexing system
- **Ecosystem Position**: Critical testing utility for knowledge builder functionality, validating the fix for root directory filename generation that addresses missing global summary issues
- **Integration Pattern**: Executed by developers and CI/CD systems to verify knowledge base filename generation behavior after bug fixes, ensuring consistent root_kb.md generation for handler root directories

######### Edge Cases & Error Handling

Error handling covers temporary directory creation failures with automatic cleanup, knowledge builder initialization errors with detailed error reporting, and path generation validation failures with specific assertion messages. The test handles different directory type scenarios including project roots, subdirectories, and git clone `.kb` directories through conditional validation logic. Edge cases include missing source root parameters, invalid configuration dictionaries, and filesystem permission issues during temporary directory operations. The testing framework provides comprehensive error scenario coverage through exception handling and detailed console output for debugging failed assertions.

########## Internal Implementation Details

Root directory detection uses `_is_handler_root_directory()` method calls with different parameter combinations for project roots versus git clone directories. Knowledge file path generation employs `_get_knowledge_file_path()` with source root and directory path parameters for different scenarios. Configuration creation uses minimal dictionary structures with required fields including `handler_type`, `file_processing`, `content_filtering`, `llm_config`, `change_detection`, `error_handling`, `output_config`, and `debug_config` sections. Test validation uses direct path comparison with expected path construction and boolean assertion logic for success tracking.

########### Code Usage Examples

**Basic root directory filename generation testing:**

This example demonstrates how to test knowledge base filename generation for root directories. The test validates that project root directories generate `root_kb.md` files instead of directory-specific names.

```python
# Test project root directory filename generation
config = IndexingConfig.from_dict(config_dict)
knowledge_builder = KnowledgeBuilder(config)
root_kb_path = knowledge_builder._get_knowledge_file_path(project_root, project_root)
expected_root_path = knowledge_dir / "project-base" / "root_kb.md"
assert root_kb_path == expected_root_path
```

**Root detection logic validation with different directory types:**

This snippet shows how to test root directory detection logic for different scenarios. The test verifies that root detection works correctly for project roots, subdirectories, and git clone `.kb` directories.

```python
# Test root detection logic for different directory types
is_project_root = knowledge_builder._is_handler_root_directory(project_root, project_root)
is_subdir_root = knowledge_builder._is_handler_root_directory(subdir, project_root)
is_kb_root = knowledge_builder._is_handler_root_directory(git_clone_kb_dir, None)
assert is_project_root and not is_subdir_root and is_kb_root
```

**Comprehensive test configuration with minimal required fields:**

This example demonstrates how to create minimal test configuration for knowledge builder testing. The configuration includes all required sections with minimal values for focused testing scenarios.

```python
# Create minimal configuration for knowledge builder testing
config_dict = {
    "handler_type": "project-base",
    "file_processing": {"max_file_size": 1024, "batch_size": 1},
    "content_filtering": {"excluded_extensions": [], "excluded_directories": []},
    "llm_config": {"llm_model": "claude-4-sonnet", "temperature": 0.3},
    "output_config": {"knowledge_output_directory": str(knowledge_dir)}
}
config = IndexingConfig.from_dict(config_dict)
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_scratchpad_exclusion.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test suite validates the exclusion of scratchpad directories from all indexing handlers within the JESSE Framework MCP Server knowledge base system, specifically designed to verify that temporary workspace directories are consistently excluded across all supported handler types. The test suite provides comprehensive validation capabilities for directory exclusion configuration, handler type coverage verification, and path structure testing with various directory hierarchies. Key semantic entities include `test_scratchpad_in_base_exclusions`, `test_scratchpad_excluded_in_all_handlers`, `test_indexing_config_excludes_scratchpad`, `test_scratchpad_exclusion_with_different_paths`, `get_default_config`, `get_supported_handler_types`, `BASE_EXCLUDED_DIRECTORIES`, `IndexingConfig`, `should_process_directory`, `tempfile.TemporaryDirectory`, `pathlib.Path`, and `content_filtering.excluded_directories` configuration structure. The testing framework implements four-phase validation through base exclusion verification, handler type coverage testing, configuration behavior validation, and path structure testing with comprehensive directory hierarchy scenarios.

##### Main Components

The test suite contains four primary test functions: `test_scratchpad_in_base_exclusions()` verifying scratchpad presence in base excluded directories constant, `test_scratchpad_excluded_in_all_handlers()` validating exclusion across all supported handler types, `test_indexing_config_excludes_scratchpad()` testing configuration behavior with directory processing decisions, and `test_scratchpad_exclusion_with_different_paths()` validating exclusion across various path structures. The main execution block orchestrates sequential test execution with detailed console output and success reporting. Each test function implements assertion-based validation with specific focus areas: constant verification, handler coverage, configuration behavior, and path structure testing.

###### Architecture & Design

The architecture follows a comprehensive testing pattern with isolated test functions for different exclusion validation aspects, utilizing temporary directory structures and realistic path scenarios for validation. The design implements systematic testing through handler type iteration and configuration validation across all supported indexing handlers. Directory exclusion validation is structured with temporary directory creation and path manipulation testing. The testing framework uses realistic directory structures combined with configuration behavior validation to ensure consistent scratchpad exclusion across different handler types and path configurations.

####### Implementation Approach

The implementation uses direct constant inspection for base exclusion verification and handler type iteration through `get_supported_handler_types()` for comprehensive coverage testing. Configuration testing employs `IndexingConfig.from_dict()` construction with default configurations and `should_process_directory()` method validation. Path structure testing uses `tempfile.TemporaryDirectory()` for isolated directory creation and various path hierarchy construction including nested and absolute path scenarios. The testing strategy implements both positive validation through exclusion verification and comprehensive coverage testing across all supported handler types.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.defaults:get_default_config` - default configuration retrieval
- `jesse_framework_mcp.knowledge_bases.indexing.defaults:get_supported_handler_types` - handler type enumeration
- `jesse_framework_mcp.knowledge_bases.indexing.defaults:BASE_EXCLUDED_DIRECTORIES` - base exclusion constants
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration model with directory processing logic
- `tempfile` (external library) - temporary directory creation and management
- `pathlib:Path` (external library) - cross-platform path manipulation

**← Outbound:**
- Console test output with detailed exclusion validation reporting
- Test result validation for scratchpad exclusion configuration integrity
- Handler coverage verification for consistent exclusion behavior

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring scratchpad directory exclusion consistency across all indexing handlers within the JESSE Framework MCP Server knowledge base system
- **Ecosystem Position**: Essential testing utility for indexing configuration integrity, validating that temporary workspace directories are properly excluded from knowledge base processing across all handler types
- **Integration Pattern**: Executed by developers and CI/CD systems to verify scratchpad exclusion behavior across all supported indexing handlers, ensuring consistent temporary directory handling before knowledge base system deployment

######### Edge Cases & Error Handling

Error handling covers missing handler types through iteration validation, configuration creation failures with detailed error reporting, and temporary directory creation issues with automatic cleanup. The test suite handles edge cases including nested directory structures, various path formats, and handler type configuration variations through comprehensive path testing. Directory creation scenarios validate exclusion behavior across different path hierarchies including project-relative, nested, and deep directory structures. The testing framework provides comprehensive error scenario coverage through assertion-based validation and detailed console output for debugging failed exclusion checks.

########## Internal Implementation Details

Base exclusion testing uses direct constant inspection with string containment validation for scratchpad presence verification. Handler type testing employs iteration through `get_supported_handler_types()` with configuration dictionary access and excluded directories list validation. Configuration behavior testing uses `IndexingConfig.from_dict()` construction with `should_process_directory()` method calls and boolean result validation. Path structure testing creates temporary directories with various hierarchy patterns and validates exclusion behavior through directory processing decision testing.

########### Code Usage Examples

**Base exclusion constant verification with handler coverage:**

This example demonstrates how to verify scratchpad exclusion in base constants and across all handler types. The test validates that scratchpad is consistently excluded in both base configuration and all supported handler configurations.

```python
# Verify scratchpad in base exclusions and all handler types
assert 'scratchpad' in BASE_EXCLUDED_DIRECTORIES
handler_types = get_supported_handler_types()
for handler_type in handler_types:
    config_dict = get_default_config(handler_type)
    excluded_dirs = config_dict['content_filtering']['excluded_directories']
    assert 'scratchpad' in excluded_dirs
```

**Configuration behavior testing with directory processing validation:**

This snippet shows how to test IndexingConfig behavior for scratchpad directory processing decisions. The test validates that configuration properly excludes scratchpad directories through should_process_directory method calls.

```python
# Test configuration behavior for scratchpad directory processing
config = IndexingConfig.from_dict(get_default_config('project-base'))
with tempfile.TemporaryDirectory() as temp_dir:
    scratchpad_path = Path(temp_dir) / 'scratchpad'
    scratchpad_path.mkdir()
    should_process = config.should_process_directory(scratchpad_path)
    assert not should_process
```

**Path structure testing with various directory hierarchies:**

This example demonstrates how to test scratchpad exclusion across different path structures and directory hierarchies. The test validates that scratchpad directories are excluded regardless of their location in the directory tree.

```python
# Test scratchpad exclusion with various path structures
test_paths = ['scratchpad', 'project/scratchpad', 'deep/nested/scratchpad']
for path_str in test_paths:
    with tempfile.TemporaryDirectory() as temp_dir:
        full_path = Path(temp_dir) / path_str
        full_path.mkdir(parents=True)
        should_process = config.should_process_directory(full_path)
        assert not should_process
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_session_init_resource.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test script validates the `jesse://session/init-context` meta-resource functionality within the JESSE Framework MCP Server, specifically designed to verify comprehensive session initialization for Cline IDE integration. The script provides automated testing capabilities for multi-section HTTP response validation, resource aggregation verification, and individual component isolation testing. Key semantic entities include `get_session_init_context`, `TestContext` class, `unwrap_fastmcp_function` utility, `asyncio` async execution, `fastmcp.Context` integration, and `jesse_framework_mcp.resources` module imports. The testing framework implements progress reporting through emoji-based status indicators and detailed section analysis with criticality level validation (`CRITICAL`, `INFORMATIONAL`).

##### Main Components

The script contains three primary async functions: `test_session_init_resource()` for comprehensive meta-resource testing, `test_individual_sections()` for isolated component validation, and `main()` for orchestrated test execution. A custom `TestContext` class provides mock context implementation with logging methods (`info`, `error`, `warning`, `debug`, `report_progress`). The testing logic includes result analysis functionality for HTTP section counting, key section verification against expected patterns, and sample output display for debugging purposes.

###### Architecture & Design

The architecture follows an async testing pattern with mock context injection and progressive validation layers. The design implements separation of concerns through individual section testing followed by comprehensive integration testing. Error handling is structured with graceful degradation and detailed traceback reporting. The testing framework uses a hierarchical approach where individual components are validated before testing the complete meta-resource aggregation functionality.

####### Implementation Approach

The implementation uses `unwrap_fastmcp_function()` to handle FastMCP decorator removal before function execution, enabling direct async function calls. Section verification employs pattern matching against predefined tuples containing section identifiers, criticality levels, and display names. Progress reporting utilizes percentage calculation for visual feedback during resource loading. The testing strategy implements both positive path validation and error isolation through individual component testing with exception handling and traceback capture.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.main:server` - MCP server instance import
- `jesse_framework_mcp.resources.session_init:get_session_init_context` - primary meta-resource function
- `jesse_framework_mcp.resources.framework_rules:get_available_rule_names` - framework rules testing
- `jesse_framework_mcp.resources.project_resources:get_project_context_summary` - project context validation
- `jesse_framework_mcp.resources.wip_tasks:get_wip_tasks_inventory` - WIP tasks verification
- `utils:unwrap_fastmcp_function` - FastMCP function wrapper utility
- `fastmcp:Context` (external library) - MCP context interface
- `asyncio` (external library) - async execution framework

**← Outbound:**
- Console output for test results and debugging information
- Test validation reports for CI/CD pipeline integration
- Error logs and tracebacks for debugging workflows

**⚡ System role and ecosystem integration:**
- **System Role**: Validation gateway ensuring session initialization meta-resource reliability before Cline IDE deployment
- **Ecosystem Position**: Critical testing component for MCP server resource protocol compliance and multi-section HTTP response validation
- **Integration Pattern**: Executed by developers and CI/CD systems to verify resource aggregation functionality and individual component isolation

######### Edge Cases & Error Handling

Error handling covers FastMCP function unwrapping failures, missing resource sections, empty result responses, and individual component failures. The script handles `KeyboardInterrupt` for graceful user termination and captures unexpected exceptions with full traceback reporting. Edge cases include missing criticality markers in HTTP responses, zero-length resource sections, and module import failures during individual section testing. The testing framework provides detailed error context through emoji-based status indicators and section-by-section failure isolation.

########## Internal Implementation Details

The `TestContext` class implements all required context methods as simple print statements with emoji prefixes for visual debugging. Section verification uses string containment checks with case-insensitive matching for robustness. The result analysis calculates character counts, HTTP section counts using `Content-Type:` markers, and displays truncated sample output for manual inspection. Individual section testing uses dynamic module imports with `__import__` and `getattr` for flexible function resolution.

########### Code Usage Examples

**Basic test execution for session initialization validation:**
```python
# Execute comprehensive session initialization test
success = await test_session_init_resource()
if success:
    print("Session initialization meta-resource validated successfully")
```

**Individual component testing for debugging:**
```python
# Test specific resource sections in isolation
await test_individual_sections()
# Validates framework rules, project context, WIP tasks, and knowledge indexes separately
```

**Custom context implementation for testing:**
```python
class TestContext:
    async def info(self, message):
        print(f"ℹ️  {message}")
    async def report_progress(self, current, total, message):
        percentage = (current / total) * 100
        print(f"📊 [{percentage:3.0f}%] {message}")
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_smart_compliance_debug.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This debug test script validates the `get_gitignore_compliance_status` function isolation within the JESSE Framework MCP Server, specifically designed to test smart compliance functionality through direct function execution and debugging. The script provides isolated testing capabilities for gitignore compliance checking, function unwrapping validation, and detailed result analysis with comprehensive error reporting. Key semantic entities include `get_gitignore_compliance_status`, `debug_smart_compliance`, `DebugContext`, `unwrap_fastmcp_function`, `asyncio` async execution, `traceback` error reporting, and console output formatting with emoji-based status indicators. The debugging framework implements two-phase validation through function import/unwrapping verification and direct execution testing with detailed result inspection and compliance status interpretation.

##### Main Components

The script contains two primary components: `DebugContext` class providing simplified logging functionality with `info` and `error` methods for console output, and `debug_smart_compliance` async function implementing comprehensive function testing and validation. The main execution block uses `asyncio.run()` for direct script execution. The debug function implements sequential testing phases including function import verification, unwrapping validation, execution testing, and result analysis with detailed output formatting and error handling.

###### Architecture & Design

The architecture follows a focused debugging pattern with isolated function testing through direct import and execution validation, utilizing simplified context mocking for dependency injection. The design implements comprehensive error handling through try-catch blocks with detailed traceback reporting and console output formatting. Testing validation is structured with sequential phases and detailed result inspection including type analysis, length measurement, and content preview. The debugging framework uses emoji-based status indicators combined with detailed console output for clear test result visualization.

####### Implementation Approach

The implementation uses direct function import from `jesse_framework_mcp.resources.gitignore` module and function unwrapping through `unwrap_fastmcp_function` utility for FastMCP decorator removal. Context mocking employs simple class definition with async logging methods for dependency satisfaction. Result analysis implements comprehensive inspection including type checking, content length measurement, and preview generation with string representation. The testing strategy uses sequential validation phases with detailed console output and error isolation through exception handling with full traceback capture.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.resources.gitignore:get_gitignore_compliance_status` - primary compliance checking function
- `utils:unwrap_fastmcp_function` - FastMCP decorator removal utility
- `asyncio` (external library) - async execution framework
- `traceback` (external library) - error reporting and stack trace generation

**← Outbound:**
- Console debug output with detailed function testing results
- Compliance status validation for gitignore configuration verification
- Error reporting for debugging failed compliance checks

**⚡ System role and ecosystem integration:**
- **System Role**: Isolated debugging utility for gitignore compliance function validation within the JESSE Framework MCP Server testing ecosystem
- **Ecosystem Position**: Auxiliary debugging tool for compliance function isolation, supporting development and troubleshooting of gitignore resource functionality
- **Integration Pattern**: Executed manually by developers for debugging compliance function behavior, providing detailed inspection of function execution and result analysis for troubleshooting

######### Edge Cases & Error Handling

Error handling covers function import failures with detailed error reporting, FastMCP unwrapping errors with traceback capture, and function execution failures with comprehensive exception handling. The script handles missing dependencies through import error catching and provides detailed error context through `traceback.print_exc()` for debugging support. Edge cases include empty result handling with compliance status interpretation, function execution timeouts, and context dependency failures. The debugging framework provides comprehensive error scenario coverage through exception catching and detailed console output for troubleshooting failed compliance checks.

########## Internal Implementation Details

Function testing uses direct import and unwrapping through `unwrap_fastmcp_function` utility for decorator removal before execution. Context mocking implements simple async methods with formatted console output using emoji prefixes for visual debugging. Result analysis employs comprehensive inspection including `type()` checking, `len()` measurement, and `repr()` preview generation with string slicing for content examination. Error reporting uses `traceback.print_exc()` for full stack trace capture and detailed exception information display.

########### Code Usage Examples

**Basic compliance function debugging with unwrapping:**

This example demonstrates how to debug the gitignore compliance function through direct import and unwrapping. The test validates that the function can be imported and unwrapped successfully before execution.

```python
# Debug compliance function import and unwrapping
compliance_func = unwrap_fastmcp_function(get_gitignore_compliance_status)
print("✅ Function imported and unwrapped successfully")
result = await compliance_func(ctx)
print(f"📊 Result type: {type(result)}")
```

**Comprehensive result analysis with detailed inspection:**

This snippet shows how to analyze compliance function results with detailed inspection and status interpretation. The analysis includes type checking, content measurement, and compliance status determination.

```python
# Analyze compliance function results with detailed inspection
print(f"📊 Result length: {len(result)} chars")
print(f"📊 Result preview: {repr(result[:200])}")
if result.strip():
    print("⚠️ Compliance issues detected - function returned content")
else:
    print("✅ No compliance issues - function returned empty string")
```

**Error handling with comprehensive traceback reporting:**

This example demonstrates how to handle errors during compliance function testing with detailed error reporting. The error handling provides full traceback information for debugging failed compliance checks.

```python
# Handle errors with comprehensive traceback reporting
try:
    result = await compliance_func(ctx)
    print(f"✅ Function executed successfully")
except Exception as e:
    print(f"❌ Error in smart compliance: {e}")
    import traceback
    traceback.print_exc()
    return None
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_strands_driver.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This test script validates the `StrandsClaude4Driver` integration within the JESSE Framework MCP Server, specifically designed to verify AWS Bedrock Claude 4 Sonnet model functionality through the Strands Agent SDK. The script provides comprehensive testing capabilities for LLM driver configuration, conversation management, caching systems, and AWS integration validation. Key semantic entities include `StrandsClaude4Driver`, `Claude4SonnetConfig`, `ConversationMemoryStrategy`, `PromptCache`, `strands-agents` package integration, `AWS_REGION` and `AWS_PROFILE` environment variables, and `asyncio` async execution patterns. The testing framework implements structured validation through context manager patterns and provides detailed logging with emoji-based status indicators for driver initialization, conversation lifecycle management, and AWS credential validation.

##### Main Components

The script contains five primary async test functions: `test_basic_configuration()` for configuration validation and optimization presets, `test_driver_initialization()` for context manager lifecycle testing, `test_conversation_management()` for conversation state and statistics validation, `test_mock_responses()` for driver structure verification without API calls, and `test_caching_system()` for independent cache functionality testing. The `run_all_tests()` function orchestrates sequential test execution with result aggregation, while `main()` provides entry point functionality with environment validation and AWS credential checking.

###### Architecture & Design

The architecture follows a comprehensive testing pattern with isolated test functions for each driver component, utilizing async context managers for proper resource cleanup. The design implements graceful degradation for missing AWS credentials, treating them as warnings rather than failures for structural validation. Error handling is structured with try-catch blocks around each test function, providing detailed logging and result tracking. The testing framework uses assertion-based validation combined with mock response testing to verify driver functionality without requiring actual AWS Bedrock API access.

####### Implementation Approach

The implementation uses configuration factory methods (`create_optimized_for_conversations()`, `create_optimized_for_analysis()`, `create_optimized_for_performance()`) to test different optimization presets. Driver testing employs async context manager patterns with `async with StrandsClaude4Driver(config)` for proper initialization and cleanup. Caching system validation uses direct `PromptCache` instantiation with TTL expiration testing and LRU eviction verification. The testing strategy implements both positive path validation and error condition testing through invalid configuration attempts and missing dependency handling.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.llm.strands_agent_driver:StrandsClaude4Driver` - primary LLM driver class
- `jesse_framework_mcp.llm.strands_agent_driver:Claude4SonnetConfig` - configuration management
- `jesse_framework_mcp.llm.strands_agent_driver:ConversationMemoryStrategy` - memory strategy enum
- `jesse_framework_mcp.llm.strands_agent_driver.conversation:PromptCache` - caching system
- `strands` (external library) - Strands Agent SDK for AWS Bedrock integration
- `asyncio` (external library) - async execution framework
- `logging` (external library) - structured logging system
- `AWS_REGION` environment variable - AWS region configuration
- `AWS_PROFILE` environment variable - AWS credential profile
- `AWS_ACCESS_KEY_ID` environment variable - AWS access credentials

**← Outbound:**
- Console test output with structured logging and emoji status indicators
- Test result aggregation for CI/CD pipeline integration
- AWS credential validation reports for deployment verification

**⚡ System role and ecosystem integration:**
- **System Role**: Validation gateway ensuring Strands Claude 4 driver reliability and AWS Bedrock integration before JESSE MCP Server deployment
- **Ecosystem Position**: Critical testing component for LLM driver functionality within the MCP server architecture, validating conversation management and caching systems
- **Integration Pattern**: Executed by developers and CI/CD systems to verify AWS Bedrock connectivity and driver configuration before production deployment

######### Edge Cases & Error Handling

Error handling covers missing `strands-agents` package installation with graceful exit and installation instructions, invalid configuration parameters with validation error capture, and missing AWS credentials with warning-level reporting. The script handles driver initialization failures through try-catch blocks with detailed error logging and continues with structural validation. Edge cases include AWS credential misconfiguration, Bedrock API access restrictions, cache TTL expiration timing, and conversation memory strategy validation. The testing framework provides differentiated error reporting through structured logging with emoji indicators and maintains test execution continuity despite individual test failures.

########## Internal Implementation Details

Configuration testing uses factory method validation with parameter inspection and invalid value rejection testing. Driver initialization employs context manager lifecycle verification with `is_initialized` property checking and conversation creation validation. Cache testing implements direct `PromptCache` manipulation with TTL timing validation using `asyncio.sleep()` and LRU eviction verification through entry count assertions. The test orchestration uses tuple-based test definition with function references and result aggregation through boolean return values.

########### Code Usage Examples

**Basic driver configuration and testing setup:**

This example demonstrates how to create optimized configurations and test driver initialization with proper error handling. The configuration factory methods provide preset optimizations for different use cases.

```python
# Create optimized configurations for different scenarios
config = Claude4SonnetConfig.create_optimized_for_performance()
async with StrandsClaude4Driver(config) as driver:
    conversation_id = "test_conversation_001"
    context = await driver.start_conversation(conversation_id)
    logger.info(f"Started conversation: {context.conversation_id}")
```

**Comprehensive test execution with result aggregation:**

This snippet shows how to run all validation tests with structured result reporting and error handling. The test runner provides detailed logging and summary reporting for CI/CD integration.

```python
# Execute all driver validation tests with result tracking
success = asyncio.run(run_all_tests())
if success:
    logger.info("🎉 All tests passed! The Strands Claude 4 driver is ready for use.")
else:
    logger.warning("⚠️ Some tests failed. Please check the implementation.")
```

**Cache system validation with TTL and eviction testing:**

This example demonstrates independent cache testing with expiration and eviction validation. The cache system supports TTL-based expiration and LRU eviction for memory management.

```python
# Test cache operations with TTL expiration and LRU eviction
cache = PromptCache(max_entries=3, ttl_seconds=1)
await cache.set("test prompt", "test_conversation", "config_hash", "test response")
cached_response = await cache.get("test prompt", "test_conversation", "config_hash")
assert cached_response == "test response", "Cache retrieval failed"
```

### {PROJECT_ROOT}/jesse-framework-mcp/tests/test_upfront_cache_structure_preparation.py

*Last Updated: 2025-07-06T23:03:54Z*

#### Functional Intent & Features

This comprehensive test suite validates the upfront cache structure preparation implementation within the JESSE Framework MCP Server knowledge building system, specifically designed to verify the `prepare_cache_structure` method and its integration with hierarchical indexing workflows. The test suite provides extensive validation capabilities for cache directory pre-creation, race condition prevention, concurrent operation safety, and fallback behavior verification. Key semantic entities include `FileAnalysisCache`, `HierarchicalIndexer`, `IndexingConfig`, `DirectoryContext`, `FileContext`, `ProcessingStatus`, `MockContext`, `MockKnowledgeBuilder`, `test_cache_structure_preparation`, `test_hierarchical_indexer_integration`, `test_fallback_behavior`, `prepare_cache_structure`, `get_cache_path`, `cache_analysis`, `get_cached_analysis`, `_collect_all_files_recursive`, `_discover_directory_structure`, `OutputConfig`, `DebugConfig`, and `asyncio.gather` concurrent execution patterns. The testing framework implements three-phase validation through basic cache structure preparation testing, hierarchical indexer integration verification, and fallback behavior validation with comprehensive race condition detection.

##### Main Components

The test suite contains three primary async test functions: `test_cache_structure_preparation()` implementing basic cache directory pre-creation validation with complex directory structure testing, `test_hierarchical_indexer_integration()` validating integration with hierarchical indexing workflows including concurrent operation safety, and `test_fallback_behavior()` testing on-demand directory creation when structure preparation is bypassed. The `MockContext` class provides simplified logging functionality, while `MockKnowledgeBuilder` extends knowledge building capabilities with simulated processing for realistic testing. The `create_directory_context()` helper function recursively builds directory context structures from file lists, and `run_all_tests()` orchestrates comprehensive test execution with detailed result reporting.

###### Architecture & Design

The architecture follows a comprehensive testing pattern with isolated test functions for different cache preparation aspects, utilizing temporary directory structures and realistic file hierarchies for validation. The design implements mock-based testing through `MockKnowledgeBuilder` and `MockContext` to simulate knowledge building workflows without external dependencies. Error handling is structured with assertion-based validation and detailed console output for debugging. The testing framework uses realistic directory structures combined with concurrent operation simulation to validate race condition prevention and cache structure reliability.

####### Implementation Approach

The implementation uses temporary directory creation with `tempfile.TemporaryDirectory()` for isolated testing environments and complex directory hierarchy generation through nested loops. Cache structure testing employs direct method calls to `prepare_cache_structure()` and validation through directory existence checking. Concurrent operation testing uses `asyncio.gather()` for parallel cache operations and race condition detection through error message analysis. The testing strategy implements both positive path validation and edge case testing through fallback behavior verification and on-demand directory creation scenarios.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.knowledge_bases.indexing.file_analysis_cache:FileAnalysisCache` - cache implementation with structure preparation
- `jesse_framework_mcp.knowledge_bases.indexing.hierarchical_indexer:HierarchicalIndexer` - hierarchical indexing workflow
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:IndexingConfig` - configuration management
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:OutputConfig` - output configuration
- `jesse_framework_mcp.knowledge_bases.models.indexing_config:DebugConfig` - debug configuration
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:DirectoryContext` - directory context modeling
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:FileContext` - file context modeling
- `jesse_framework_mcp.knowledge_bases.models.knowledge_context:ProcessingStatus` - processing status tracking
- `asyncio` (external library) - async execution and concurrent operation management
- `tempfile` (external library) - temporary directory and file management
- `pathlib:Path` (external library) - cross-platform path manipulation
- `datetime` (external library) - timestamp handling for context creation

**← Outbound:**
- Console test output with detailed cache structure validation reporting
- Test result validation for cache preparation functionality integrity
- Performance metrics for concurrent operation safety verification
- Exit code reporting for CI/CD pipeline integration

**⚡ System role and ecosystem integration:**
- **System Role**: Critical validation component ensuring upfront cache structure preparation reliability and race condition prevention within the JESSE Framework MCP Server knowledge building ecosystem
- **Ecosystem Position**: Essential testing utility for cache optimization functionality, validating the bridge between cache structure preparation and hierarchical indexing workflows with concurrent operation safety
- **Integration Pattern**: Executed by developers and CI/CD systems to verify cache structure preparation behavior, race condition elimination, and performance optimization before knowledge building system deployment

######### Edge Cases & Error Handling

Error handling covers temporary directory creation failures with automatic cleanup, cache structure preparation errors with detailed error reporting, and concurrent operation race condition detection through message analysis. The test suite handles missing directory scenarios through fallback behavior validation and on-demand directory creation testing. Edge cases include partial directory structure creation, filesystem permission issues, concurrent access conflicts, and cache operation failures during structure preparation. The testing framework provides comprehensive error scenario coverage through assertion-based validation, detailed console output for debugging, and race condition indicator detection through error message pattern matching.

########## Internal Implementation Details

Cache structure preparation testing uses complex directory hierarchy generation with nested loops creating multiple levels of directories and files. Directory context creation employs recursive tree building with relative path calculation and subdirectory processing. Concurrent operation testing creates multiple async tasks with `asyncio.gather()` for parallel execution and race condition detection. Mock integration uses class inheritance with method overriding to simulate knowledge building workflows while maintaining actual cache integration behavior. Test orchestration uses tuple-based test definition with comprehensive result aggregation and success rate calculation.

########### Code Usage Examples

**Basic cache structure preparation with complex directory hierarchy:**

This example demonstrates how to test upfront cache structure preparation with complex directory hierarchies. The test validates that all necessary cache directories are created before any cache operations begin.

```python
# Test cache structure preparation with complex directory hierarchy
cache = FileAnalysisCache(config)
root_context = await create_directory_context(source_root, files_created)
await cache.prepare_cache_structure(root_context, source_root, ctx)
all_files = cache._collect_all_files_recursive(root_context)
expected_dirs = {cache.get_cache_path(file_path, source_root).parent for file_path in all_files}
assert all(expected_dir.exists() for expected_dir in expected_dirs)
```

**Concurrent cache operation safety testing with race condition detection:**

This snippet shows how to test concurrent cache operations for race condition prevention and safety validation. The test verifies that multiple simultaneous cache operations complete successfully without conflicts.

```python
# Test concurrent cache operations for race condition prevention
async def concurrent_cache_operation(file_path, analysis_content):
    await cache.cache_analysis(file_path, analysis_content, source_root)
tasks = [concurrent_cache_operation(file, f"Analysis {i}") for i, file in enumerate(test_files)]
await asyncio.gather(*tasks)
assert all(cache.get_cache_path(file, source_root).exists() for file in test_files)
```

**Mock knowledge builder integration with hierarchical indexer testing:**

This example demonstrates how to test cache structure preparation integration with hierarchical indexing workflows using mock components. The test validates that cache preparation occurs seamlessly during indexing operations.

```python
# Test hierarchical indexer integration with mock knowledge builder
class MockKnowledgeBuilder:
    def __init__(self, config):
        self.analysis_cache = FileAnalysisCache(config)
    async def build_file_knowledge(self, file_context, ctx, source_root=None):
        return FileContext(processing_status=ProcessingStatus.COMPLETED)
indexer.knowledge_builder = MockKnowledgeBuilder(config)
root_context = await indexer._discover_directory_structure(source_root, ctx)
await indexer.knowledge_builder.analysis_cache.prepare_cache_structure(root_context, source_root, ctx)
```

---
*Generated: 2025-07-06T23:03:54Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/tests*
*Total Files: 21*
*Total Subdirectories: 0*

# End of tests_kb.md