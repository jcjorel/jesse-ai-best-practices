<!-- âš ï¸ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! âš ï¸ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/

## Global Summary

#### Functional Intent & Features

This directory implements the complete Jesse Framework MCP Server package, providing comprehensive AI-assisted development capabilities through `FastMCP` protocol compliance with resource-first architecture, embedded content delivery, and intelligent knowledge base management for modern development workflows. The system enables MCP clients to access framework rules, project contexts, workflows, and knowledge bases through standardized resource endpoints while supporting both granular individual access and consolidated meta-resource delivery for efficient AI assistant integration. Key semantic entities include `FastMCP` server instance with `server = FastMCP("JESSE Framework")`, primary resource handlers `framework_index()`, `jesse_framework_start_prompt()`, `jesse_wip_task_create_prompt()`, and `jesse_knowledge_capture_prompt()`, centralized constants `JESSE_RULE_FILES`, `HTTP_BOUNDARY_MARKER`, and `DEFAULT_CRITICALITY`, comprehensive helper utilities through `content_loaders`, `session_management`, `knowledge_scanners`, `path_utils`, `async_http_formatter`, and `mistletoe_spacing` modules, knowledge base system with `HierarchicalIndexer`, `KnowledgeBuilder`, `FileAnalysisCache`, and `RebuildDecisionEngine`, LLM integration via `StrandsClaude4Driver` and `Claude4SonnetConfig`, resource endpoints including `jesse://index`, `jesse://framework/rule/{rule_name}`, `jesse://session/init-context`, `jesse://project/knowledge`, `jesse://wip-tasks`, and `file://workflows/{workflow_name}`, embedded content access through `JESSE_*.md` rule files and `workflows/` automation definitions, HTTP formatting with `XAsyncContentCriticality.CRITICAL` and `XAsyncContentCriticality.INFORMATIONAL` classifications, portable path variables `{PROJECT_ROOT}`, `{HOME}`, `{CLINE_RULES}`, `{CLINE_WORKFLOWS}`, build-time content embedding through `copy_jesse_content.py` and `JesseBuildHook`, comprehensive testing infrastructure with `pytest` framework and `MockContext` simulation, and complete package distribution through `pyproject.toml` configuration with `hatchling` build system integration.

##### Main Components

The directory contains comprehensive MCP server implementation with core server files, specialized functional subdirectories, embedded framework content, build infrastructure, testing suite, and package configuration. Core server files include `jesse_framework_mcp/main.py` implementing the primary `FastMCP` server with resource discovery and prompt handlers, `jesse_framework_mcp/constants.py` providing centralized configuration constants and HTTP formatting standards, and `jesse_framework_mcp/__init__.py` serving as package initialization with version metadata and entry point delegation. Specialized subdirectories encompass `jesse_framework_mcp/knowledge_bases/` implementing hierarchical indexing with Plan-then-Execute architecture, `jesse_framework_mcp/helpers/` providing modular utility functions for content loading and HTTP formatting, `jesse_framework_mcp/llm/` containing Claude 4 Sonnet integration through `strands_agent_driver/` package, `jesse_framework_mcp/resources/` delivering comprehensive MCP resource handlers with individual and meta-resource patterns, and `jesse_framework_mcp/embedded_content/` housing framework rules and workflow definitions with programmatic access interfaces. Supporting infrastructure includes `build_scripts/copy_jesse_content.py` for build-time content preparation, `tests/` directory with 22 comprehensive test files covering all functional areas, package configuration through `pyproject.toml` with `hatchling` build system, dependency management via `uv.lock` with 77 pinned packages, comprehensive documentation in `README.md`, version control exclusions through `.gitignore`, and utility functions in `utils.py` for `FastMCP` function unwrapping.

###### Architecture & Design

The architecture implements a modern resource-first MCP server design with `FastMCP` native transport management, following clean separation between transport layer and resource implementations with automatic lifecycle management through `server.run(transport="stdio")`. The design emphasizes modular organization with dedicated subdirectories for different functional domains, comprehensive HTTP formatting through `async_http_formatter` utilities, embedded content delivery enabling self-contained framework distribution, and build-time content preparation ensuring complete framework packaging. Key design patterns include the resource-first pattern with individual resource access through dedicated URIs, auto-registration pattern leveraging `FastMCP` decorators for automatic resource handler discovery, meta-resource aggregation pattern combining multiple contexts into unified responses, Plan-then-Execute architecture separating decision-making from execution in knowledge base operations, async context manager pattern for LLM integration with proper resource lifecycle handling, embedded content access pattern using `importlib.resources` for package-bundled framework rules and workflows, build hook integration pattern implementing `BuildHookInterface` for automated content preparation, and comprehensive testing pattern with mock-based validation and integration testing. The system uses composition over inheritance with specialized helper modules, centralized configuration through constants, build-time content embedding for self-contained distribution, and comprehensive error handling with individual section failure isolation preventing complete resource delivery failures while maintaining MCP protocol compliance.

####### Implementation Approach

The implementation uses `FastMCP` native transport with automatic lifecycle management eliminating manual event loop creation, comprehensive resource discovery through dynamic scanning of available components, and HTTP-formatted content delivery ensuring consistent AI assistant processing. The approach employs async-first patterns throughout with `FastMCP` Context integration for progress reporting, cache-first processing strategies through `FileAnalysisCache` integration avoiding unnecessary LLM calls, and continuation-based retry mechanisms providing 90%+ token savings through intelligent response completion. Knowledge base processing implements Plan-then-Execute architecture with atomic task execution through `ExecutionEngine` and comprehensive decision-making via `RebuildDecisionEngine`, while LLM integration uses async context managers with `StrandsClaude4Driver` for Claude 4 Sonnet capabilities. Content delivery combines JSON serialization for structured data, markdown formatting for documentation, and HTTP section wrapping with appropriate criticality classifications. Build-time content preparation uses `copy_jesse_content()` orchestration with `JesseBuildHook` integration for automated framework copying during package creation. The system implements working directory management with project root detection, sequential loading with progress reporting for meta-resource aggregation, conditional output strategies returning empty responses when compliant for massive context reduction, and comprehensive testing through `pytest` framework with mock context simulation and integration validation. Error handling employs try-catch blocks with specific exception types, graceful degradation with placeholder content, and comprehensive logging through structured error reporting.

######## External Dependencies & Integration Points

**â†’ Inbound:**
- `fastmcp.FastMCP` (external library) - MCP server framework providing native transport and protocol compliance with automatic lifecycle management
- `fastmcp.Context` (external library) - progress reporting and logging interface for real-time user feedback during operations
- `hatchling` (external library) - modern Python build backend providing package creation and distribution capabilities with custom build hook support
- `importlib.resources` (external library) - embedded content access with Python 3.9+ compatibility and fallback support for package-bundled framework content
- `mistletoe` (external library) - AST-based markdown parsing and rendering for document structure manipulation and spacing preservation
- `pydantic` (external library) - configuration validation and type safety for hierarchical parameter management across knowledge base system
- `strands.Agent` (external library) - Strands Agent SDK for Claude 4 Sonnet interaction and streaming capabilities through AWS Bedrock integration
- `boto3` (external library) - AWS SDK for Amazon Bedrock service access and authentication for LLM operations
- `pytest` (external library) - comprehensive testing framework with async support and fixture management for validation infrastructure
- `pathlib.Path` (external library) - cross-platform filesystem operations throughout the system for portable path handling
- `asyncio` (external library) - async programming patterns for concurrent operations and context management across all components
- AWS environment variables `AWS_REGION`, `AWS_PROFILE`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` - authentication configuration for Bedrock integration

**â† Outbound:**
- MCP clients - consuming framework resources through standardized MCP protocol with resource and prompt endpoints for AI assistant integration
- Cline AI assistant - accessing comprehensive session context and workflow resources as slash commands for development workflow automation
- Development environments - using Jesse Framework resources for AI-assisted development workflows and context delivery through MCP protocol
- AI coding assistants - consuming framework rules with CRITICAL criticality for strict adherence to development standards and best practices
- Knowledge management systems - processing generated knowledge base files and cached analysis content for project documentation
- AWS Bedrock service - generating Claude 4 Sonnet API calls and streaming responses for LLM-powered content analysis
- PyPI package repository - distributing complete MCP server package with embedded framework content for installation and deployment
- Generated artifacts including `*.md` knowledge files, `*.analysis.md` cache files, `*.indexing-config.json` configuration files for knowledge base management
- Console applications - using main entry point for server startup and lifecycle management through `jesse-framework-mcp` command

**âš¡ System role and ecosystem integration:**
- **System Role**: Complete MCP server implementation for Jesse Framework ecosystem, providing comprehensive AI-assisted development capabilities through FastMCP protocol compliance with resource-first architecture, embedded content delivery, intelligent knowledge base management, and build-time content preparation for self-contained distribution
- **Ecosystem Position**: Central infrastructure component serving as primary MCP protocol interface, coordinating all framework resources including rules, workflows, knowledge bases, and LLM integration while providing unified access point for AI assistants and development tools with complete package distribution capabilities
- **Integration Pattern**: Used by MCP clients through stdio transport for resource and prompt access, consumed by AI assistants for framework initialization and workflow guidance, integrated with AWS Bedrock for LLM capabilities, coordinated with development tools through standardized MCP protocol, deployed as self-contained package with embedded content enabling framework distribution without external dependencies, and built through automated content preparation ensuring complete framework packaging

######### Edge Cases & Error Handling

The system handles comprehensive edge cases including missing project root scenarios through validation with fallback to setup guidance, `FastMCP` server startup failures through exception handling with descriptive error logging, and individual resource failures through isolation preventing complete system failure. Knowledge base processing manages empty files with infinite rebuild loop prevention, missing directories with graceful degradation, and LLM truncation detection through multiple validation strategies including programmatic marker checking and continuation-based recovery. LLM integration addresses missing Strands Agent SDK through conditional imports with mock class definitions, AWS Bedrock connection failures with region context and troubleshooting guidance, and streaming failures with retry logic and exponential backoff. Resource delivery handles missing embedded content through comprehensive error messages, working directory management with restoration mechanisms, and HTTP formatting edge cases including Unicode content handling and byte-perfect content-length calculations. Build-time content preparation manages missing `artifacts/.clinerules/` structure through project root discovery failures with descriptive error messages, missing source files through individual file verification, and build hook integration failures through exception propagation. Testing infrastructure handles mock context simulation failures, temporary directory creation issues with automatic cleanup, and comprehensive validation across all functional areas with individual test isolation. The system provides smart compliance checking with conditional output returning empty responses when compliant for context optimization, comprehensive orphaned file detection with safety validation, configuration validation with descriptive error messages for invalid parameters, and package distribution error handling through `hatchling` build system integration. Error isolation ensures individual component failures don't cascade to complete system failure while maintaining MCP protocol compliance and package integrity.

########## Internal Implementation Details

The MCP server uses `FastMCP` native transport initialization with `server = FastMCP("JESSE Framework")` and automatic lifecycle management through `server.run(transport="stdio")` eliminating manual event loop creation. Resource discovery employs dynamic component scanning including rule enumeration through `get_available_rule_names()`, knowledge base scanning with exception handling, and workflow file discovery using `get_embedded_workflow_files()`. HTTP formatting applies `format_http_section()` with specific criticality classifications, portable path resolution using placeholder variables, and content type specifications for consistent MCP response delivery. Knowledge base system implements cache-first processing with `FileAnalysisCache` using HTML comment metadata blocks and SHA-256 hashing for key generation, Plan-then-Execute architecture with atomic task processing through `ExecutionEngine`, and comprehensive decision-making via `RebuildDecisionEngine`. LLM integration uses lazy initialization with thread-safe locks, conversation management through in-memory dictionaries, and streaming implementation processing different event types including data, reasoning, and tool usage events. Embedded content access employs module-relative path resolution using `Path(__file__).parent`, automatic file extension handling, and comprehensive error reporting through `FileNotFoundError` exceptions. Build-time content preparation uses `copy_jesse_content()` orchestration with `find_jesse_project_root()` for project discovery, `shutil.copy2()` for individual rule files, and `shutil.copytree()` for complete workflow directory structure with `JesseBuildHook` integration for automated execution. Package configuration employs `hatchling` build backend with custom hook integration executing during package creation, dependency management through `uv.lock` with 77 pinned packages ensuring reproducible builds, and comprehensive metadata including version, authors, and entry points. Testing infrastructure uses `pytest` framework with `MockContext` classes for `FastMCP` simulation, temporary directory creation for isolated testing environments, and comprehensive validation across 22 test files covering all functional areas. The system maintains consistent logging patterns, structured error handling with specific exception types, comprehensive validation protocols ensuring data integrity throughout all operations, and complete package distribution capabilities through automated build processes.

########### Usage Examples

**Complete MCP server deployment with package installation:**

This example demonstrates the primary deployment pattern for Jesse Framework MCP Server through package installation and execution. The approach provides complete framework functionality through standardized Python packaging with embedded content.

```bash
# Install Jesse Framework MCP Server package with all embedded content and dependencies
# Provides complete JESSE framework functionality through standardized package distribution
pip install jesse-framework-mcp

# Execute MCP server with stdio transport for client communication
# Server includes all embedded framework rules, workflows, and knowledge base capabilities
jesse-framework-mcp
```

**Comprehensive session initialization through meta-resource aggregation:**

This example shows how MCP clients access complete development context through single resource request, demonstrating the meta-resource aggregation pattern for efficient session startup with all framework components.

```python
# Access comprehensive session context for complete development environment setup
# Returns multi-section HTTP response with framework rules, project context, workflows, and compliance
session_context = await mcp_client.read_resource("jesse://session/init-context")

# Parse multi-section response for individual framework contexts
sections = extract_http_sections_from_multi_response(session_context)
framework_rules = [s for s in sections if s.criticality == "CRITICAL"]
project_context = [s for s in sections if s.section_type == "project-context"]
workflows = [s for s in sections if s.section_type == "workflow"]
```

**Knowledge base hierarchical indexing with Plan-then-Execute architecture:**

This example demonstrates the advanced knowledge base processing capabilities with LLM integration, comprehensive caching strategies, and Plan-then-Execute workflow coordination for intelligent content analysis.

```python
# Initialize hierarchical knowledge base indexing with Plan-then-Execute workflow coordination
# Provides comprehensive content analysis with cache optimization and LLM integration
from jesse_framework_mcp.knowledge_bases import (
    HierarchicalIndexer, IndexingConfig, IndexingMode
)

# Configure indexing with cache optimization, LLM integration, and Plan-then-Execute architecture
config = IndexingConfig(
    handler_type="project-base",
    indexing_mode=IndexingMode.INCREMENTAL,
    max_concurrent_operations=4,
    enable_prompt_caching=True
)

# Execute Plan-then-Execute workflow with progress reporting and comprehensive analysis
async def run_knowledge_indexing():
    indexer = HierarchicalIndexer(config)
    status = await indexer.index_hierarchy(Path("./src"), ctx)
    print(f"Processed {status.processing_stats.files_completed} files")
    print(f"LLM calls: {status.processing_stats.llm_calls_made}")
    print(f"Cache hits: {status.processing_stats.cache_hits}")
    return status
```

**Build-time content preparation with automated framework embedding:**

This example showcases the build-time content preparation system that automatically embeds complete JESSE framework content during package creation, ensuring self-contained distribution.

```python
# Build-time content preparation with automated JESSE framework embedding during package creation
# Provides complete framework content embedding from artifacts/ to embedded_content/ structure
from build_scripts.copy_jesse_content import copy_jesse_content, JesseBuildHook

# Manual content preparation for development and testing scenarios
try:
    copy_jesse_content()
    print("âœ… JESSE framework content copied successfully")
    print("ðŸ“¦ Package ready for distribution with embedded content")
except (ValueError, FileNotFoundError) as e:
    print(f"âŒ Content preparation failed: {e}")

# Automated build hook integration for package creation
# Hatchling automatically triggers content preparation during build process
hook = JesseBuildHook()
hook.initialize(version="0.1.0", build_data={})
```

## Subdirectory Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/build_scripts/
*Last Updated: 2025-07-07T10:14:42Z*

This directory implements the build-time infrastructure for the Jesse Framework MCP Server, providing automated framework content preparation and distribution packaging through Hatchling build system integration. The directory enables single source of truth copying from `artifacts/.clinerules/` to `embedded_content/` during package builds, ensuring complete JESSE framework content including rules and workflows is embedded in the MCP server package for runtime access. Key semantic entities include the primary build script `copy_jesse_content.py` containing orchestration function `copy_jesse_content()`, specialized copying functions `copy_jesse_rules()` and `copy_jesse_workflows()`, project discovery utility `find_jesse_project_root()`, Hatchling integration class `JesseBuildHook` implementing `BuildHookInterface`, legacy compatibility function `hatch_build_hook()`, imported modules `os`, `shutil`, and `pathlib.Path` for file operations, centralized configuration import `get_jesse_rule_files()` from constants module, source directory structure `artifacts/.clinerules/` containing framework files, destination structure `embedded_content/` for runtime embedding, and comprehensive error handling with `ValueError` and `FileNotFoundError` exceptions for missing components. The system implements defensive programming with descriptive error messages and complete framework copying through build system integration ensuring automated content preparation during package creation.

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/
*Last Updated: 2025-07-07T10:14:42Z*

This directory implements the core Jesse Framework MCP Server, providing comprehensive AI-assisted development capabilities through `FastMCP` protocol compliance with resource-first architecture, embedded content delivery, and intelligent knowledge base management for modern development workflows. The system enables MCP clients to access framework rules, project contexts, workflows, and knowledge bases through standardized resource endpoints while supporting both granular individual access and consolidated meta-resource delivery for efficient AI assistant integration. Key semantic entities include `FastMCP` server instance with `server = FastMCP("JESSE Framework")`, primary resource handlers `framework_index()`, `jesse_framework_start_prompt()`, `jesse_wip_task_create_prompt()`, and `jesse_knowledge_capture_prompt()`, centralized constants `JESSE_RULE_FILES`, `HTTP_BOUNDARY_MARKER`, and `DEFAULT_CRITICALITY`, comprehensive helper utilities through `content_loaders`, `session_management`, `knowledge_scanners`, `path_utils`, `async_http_formatter`, and `mistletoe_spacing` modules, knowledge base system with `HierarchicalIndexer`, `KnowledgeBuilder`, `FileAnalysisCache`, and `RebuildDecisionEngine`, LLM integration via `StrandsClaude4Driver` and `Claude4SonnetConfig`, resource endpoints including `jesse://index`, `jesse://framework/rule/{rule_name}`, `jesse://session/init-context`, `jesse://project/knowledge`, `jesse://wip-tasks`, and `file://workflows/{workflow_name}`, embedded...

### {PROJECT_ROOT}/jesse-framework-mcp/tests/
*Last Updated: 2025-07-07T10:14:42Z*

This directory provides comprehensive test coverage for the JESSE Framework MCP Server knowledge base system, specifically validating core functionality across resource endpoints, knowledge building workflows, HTTP formatting infrastructure, and hierarchical indexing operations. The test suite ensures system reliability through validation of `HierarchicalIndexer`, `KnowledgeBuilder`, `FileAnalysisCache`, `RebuildDecisionEngine`, `StrandsClaude4Driver`, `XAsyncHttpPath`, `IndexingConfig`, and `FastMCP` resource protocol compliance. Key semantic entities include `pytest` testing framework, `asyncio` async execution patterns, `tempfile` temporary environment management, `MockContext` simulation classes, `unwrap_fastmcp_function` utility, `jesse://session/init-context` meta-resource, `--JESSE_FRAMEWORK_BOUNDARY_2025--` boundary markers, `X-ASYNC-Content-Writable` headers, `.knowledge/` directory structures, `project-base` indexing rules, and `Claude4SonnetConfig` LLM integration. The testing architecture implements comprehensive validation through resource endpoint testing, knowledge building workflow verification, cache behavior validation, HTTP formatting compliance, and integration testing with real project data to ensure production readiness.

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/.gitignore

*Last Updated: 2025-07-07T10:14:42Z*

#### Functional Intent & Features

This file implements Git version control exclusion rules for the Jesse Framework MCP Server project, providing comprehensive ignore patterns that prevent sensitive files, build artifacts, and temporary content from being tracked in the repository while preserving essential knowledge base metadata. The configuration enables selective knowledge management by ignoring actual content files while preserving documentation and structure, supporting development workflows with comprehensive Python ecosystem exclusions, and maintaining clean repository state across multiple development environments. Key semantic entities include knowledge management patterns `.knowledge/git-clones/*/` and `.knowledge/pdf-knowledge/*.pdf` for content exclusion, negation patterns `!.knowledge/git-clones/*.md` and `!.knowledge/pdf-knowledge/README.md` for metadata preservation, Python-specific patterns `__pycache__/`, `*.py[cod]`, `build/`, `dist/`, `*.egg-info/` for build artifact exclusion, virtual environment patterns `.env`, `.venv`, `env/`, `venv/` for environment isolation, IDE patterns `.vscode/`, `.idea/`, `*.swp` for editor file exclusion, testing patterns `.pytest_cache/`, `.coverage`, `htmlcov/` for test artifact management, OS-specific patterns `.DS_Store`, `Thumbs.db` for system file exclusion, and MCP server patterns `mcp-server.log`, `server.log`, `debug.log` for runtime log management. The system implements selective preservation through Git negation patterns ensuring knowledge base documentation remains tracked while excluding large binary content and sensitive runtime data.

##### Main Components

The file contains eight primary section categories providing comprehensive version control exclusion coverage for the Jesse Framework MCP Server project. The knowledge management section defines patterns for `.knowledge/git-clones/` and `.knowledge/pdf-knowledge/` directories with selective exclusion and preservation rules. The Python section includes comprehensive patterns for build artifacts, bytecode, distribution files, and package management tools. The virtual environment section covers multiple environment naming conventions and backup patterns. The IDE and editor section addresses multiple development environments including VSCode, IntelliJ, Vim, and Spyder. The testing and coverage section handles pytest, coverage, tox, and hypothesis artifacts. The OS-specific section covers macOS, Windows, and Linux system files. The development tools section includes patterns for type checkers, linters, and documentation generators. The MCP server section addresses runtime logs and debug files specific to the framework implementation.

###### Architecture & Design

The architecture implements a hierarchical exclusion pattern system with selective preservation through Git negation rules, following comprehensive coverage principles for Python development ecosystems and specialized knowledge management requirements. The design emphasizes selective knowledge base management preserving documentation while excluding content files, comprehensive Python ecosystem support covering build tools, package managers, and testing frameworks, and multi-environment compatibility addressing different operating systems and development setups. Key design patterns include the selective exclusion pattern using directory wildcards followed by specific file preservation, comprehensive coverage pattern addressing all major Python development tools and workflows, hierarchical organization pattern grouping related exclusions by functional category, negation pattern using `!` prefix for selective file preservation within excluded directories, and environment isolation pattern preventing virtual environment and configuration file tracking. The system uses Git's native pattern matching with glob patterns, directory-specific exclusions, and file extension matching for comprehensive coverage.

####### Implementation Approach

The implementation uses Git ignore pattern syntax with glob matching for flexible file and directory exclusion including wildcard patterns `*`, directory patterns with trailing slashes, and file extension patterns. Selective preservation employs negation patterns with `!` prefix to preserve specific files within excluded directories. The approach implements comprehensive Python ecosystem coverage through specific patterns for build tools, package managers, virtual environments, and testing frameworks. Knowledge management uses directory-level exclusion with file-level preservation for `.knowledge/` subdirectories. Multi-environment support addresses different operating systems, IDEs, and development tools through specific pattern collections. Pattern organization follows logical grouping with descriptive comments for maintainability. File extension matching uses bracket notation for multiple extensions and wildcard patterns for flexible matching.

######## External Dependencies & Integration Points

**â†’ References:**
- `Git` version control system - consuming ignore patterns for repository file exclusion and tracking decisions
- `.knowledge/git-clones/` - knowledge management directory structure requiring selective content exclusion
- `.knowledge/pdf-knowledge/` - PDF document storage requiring binary file exclusion with metadata preservation
- Python build tools - generating artifacts matched by `build/`, `dist/`, `*.egg-info/` patterns
- Virtual environment tools - creating environments matched by `.venv`, `env/`, `venv/` patterns
- IDE and editor systems - generating configuration files matched by `.vscode/`, `.idea/`, `*.swp` patterns
- Testing frameworks - producing artifacts matched by `.pytest_cache/`, `.coverage`, `htmlcov/` patterns

**â† Referenced By:**
- Git version control operations - using patterns for `git add`, `git status`, and `git commit` file filtering
- Development workflows - relying on exclusions for clean repository state and build artifact management
- CI/CD pipelines - depending on ignore patterns for consistent build environments and artifact handling
- Knowledge management systems - using selective exclusion for content privacy while preserving structure
- MCP server runtime - generating log files excluded by `mcp-server.log`, `server.log` patterns

**âš¡ System role and ecosystem integration:**
- **System Role**: Version control configuration for Jesse Framework MCP Server ecosystem, defining comprehensive file exclusion rules for clean repository management and selective knowledge base preservation
- **Ecosystem Position**: Core development infrastructure component ensuring repository cleanliness, protecting sensitive content, and maintaining development workflow efficiency across multiple environments and tools
- **Integration Pattern**: Used by Git version control system for automatic file filtering, consumed by development tools for consistent environment setup, integrated with knowledge management workflows for content privacy, and coordinated with build systems for artifact exclusion

######### Edge Cases & Error Handling

The system handles nested directory structures through recursive wildcard patterns preventing deep directory exclusion issues. Conflicting patterns are managed through Git's precedence rules where more specific patterns override general ones. File extension variations are addressed through bracket notation and multiple pattern entries for comprehensive coverage. Cross-platform compatibility issues are handled through multiple OS-specific pattern entries addressing different system file conventions. Knowledge base content protection uses directory-level exclusion with explicit file preservation preventing accidental content exposure. Build artifact conflicts are managed through comprehensive pattern coverage addressing multiple build tools and package managers. Virtual environment naming variations are covered through multiple pattern entries addressing different naming conventions. IDE-specific file conflicts are handled through comprehensive editor pattern coverage preventing configuration file tracking.

########## Internal Implementation Details

The file uses Git ignore syntax with hash comments for section organization and pattern documentation. Knowledge management patterns employ directory exclusion with trailing slashes followed by negation patterns for specific file preservation. Python patterns use file extension matching with bracket notation for bytecode variants and wildcard patterns for build artifacts. Virtual environment patterns address multiple naming conventions including hidden directories and backup suffixes. IDE patterns cover configuration directories and temporary files across multiple development environments. Testing patterns address artifact directories and coverage files from multiple testing frameworks. OS patterns use specific file names and extensions for system-generated files. MCP server patterns target specific log file names generated during runtime operations. Pattern ordering follows logical grouping with related exclusions clustered together for maintainability.

########### Usage Examples

Knowledge management selective exclusion demonstrates the core pattern for preserving documentation while excluding content files. This approach enables version control of knowledge base structure without tracking sensitive or large binary content.

```gitignore
# Selective knowledge base management preserving structure while excluding content
# Enables documentation tracking without exposing sensitive or large binary files
.knowledge/git-clones/*/
!.knowledge/git-clones/*.md
!.knowledge/git-clones/README.md

.knowledge/pdf-knowledge/*.pdf
!.knowledge/pdf-knowledge/*.md
!.knowledge/pdf-knowledge/README.md
```

Python development environment exclusion showcases comprehensive coverage for build artifacts and virtual environments. This pattern ensures clean repository state across different Python development workflows and tools.

```gitignore
# Comprehensive Python development artifact exclusion for clean repository management
# Covers build tools, package managers, virtual environments, and testing frameworks
__pycache__/
*.py[cod]
build/
dist/
*.egg-info/
.venv
env/
venv/
.pytest_cache/
.coverage
```

### {PROJECT_ROOT}/jesse-framework-mcp/pyproject.toml

*Last Updated: 2025-07-07T10:14:42Z*

#### Functional Intent & Features

This file serves as the Python package configuration for the Jesse Framework MCP Server, defining build system requirements, dependencies, and metadata for distributing the complete JESSE AI Framework rules and workflows as an MCP-compatible server package. The configuration enables build-time embedding of JESSE framework content from the `artifacts/` directory through custom build hooks, providing a self-contained MCP server distribution with integrated framework governance. Key semantic entities include `hatchling` build system with `hatch-vcs` version control integration, `fastmcp~=2.9.2` as the primary MCP protocol implementation, `jesse-framework-mcp` package name with version `0.1.0`, `build_scripts/copy_jesse_content.py` custom build hook for content embedding, `jesse_framework_mcp/embedded_content/` directory for framework rules and workflows, `boto3>=1.38.46` for AWS service integration, `strands-agents>=0.1.0` for agent framework support, `mistletoe>=1.4.0` for markdown processing, `PyYAML>=6.0` for YAML output generation, `requires-python = ">=3.10"` compatibility requirement, and comprehensive development tooling configuration including `pytest`, `black`, `isort`, `flake8`, and `mypy` for code quality assurance.

##### Main Components

The configuration contains eight primary sections defining package structure and build behavior: `build-system` section specifying `hatchling` and `hatch-vcs` requirements, `project` section with package metadata including name, version, description, authors, and dependencies, `project.urls` section providing repository and documentation links, `project.scripts` section defining the `jesse-framework-mcp` command-line entry point, `tool.hatch.build.hooks.custom` section configuring the build-time content copying hook, `tool.hatch.build.targets.wheel.shared-data` section for embedded content distribution, `project.optional-dependencies` section with development tools, and comprehensive tool configuration sections for `black`, `isort`, `mypy`, and `pytest`. Supporting components include `tool.setuptools.package-data` for setuptools compatibility, `dependency-groups` for modern dependency management, and detailed Python version classifiers supporting 3.10, 3.11, and 3.12.

###### Architecture & Design

The architecture implements a build-time content embedding pattern using `hatchling` build system with custom hooks to integrate JESSE framework rules and workflows into the Python package distribution. The design employs a modular dependency structure with `fastmcp` as the core MCP protocol implementation, supplemented by specialized libraries for AWS integration, agent frameworks, markdown processing, and YAML generation. The system uses shared data distribution through wheel packaging to include embedded content in the final package, ensuring framework rules and workflows are available at runtime without external dependencies. The architectural pattern includes comprehensive development tooling integration with code formatting, linting, type checking, and testing frameworks configured for Python 3.10+ compatibility.

####### Implementation Approach

The implementation uses `hatchling` build backend with custom build hooks executing `build_scripts/copy_jesse_content.py` to embed JESSE framework content during package creation. The approach employs version pinning strategies with compatible version ranges (`~=2.9.2` for FastMCP, `>=1.38.46` for boto3) ensuring stable dependency resolution while allowing patch updates. Package data inclusion uses both modern `tool.hatch.build.targets.wheel.shared-data` configuration and legacy `tool.setuptools.package-data` for broad compatibility. Development workflow integration implements standardized tooling with `black` for code formatting, `isort` for import organization, `mypy` for type checking, and `pytest` for testing with asyncio support. The build process coordinates content copying, dependency resolution, and package assembly to produce a self-contained MCP server distribution.

######## External Dependencies & Integration Points

**â†’ References:**
- `hatchling` (external library) - modern Python build backend providing package creation and distribution capabilities
- `hatch-vcs` (external library) - version control integration for automatic version management from Git tags
- `fastmcp~=2.9.2` (external library) - FastMCP framework implementing MCP protocol for server functionality
- `boto3>=1.38.46` (external library) - AWS SDK for Python enabling cloud service integration
- `strands-agents>=0.1.0` (external library) - agent framework for AI assistant coordination and management
- `mistletoe>=1.4.0` (external library) - markdown parser and renderer for processing framework documentation
- `PyYAML>=6.0` (external library) - YAML processing library for configuration and data serialization
- `build_scripts/copy_jesse_content.py` - custom build hook script for embedding JESSE framework content

**â† Referenced By:**
- Python package installers - `pip`, `poetry`, `conda` consume this configuration for package installation and dependency resolution
- CI/CD build systems - automated build pipelines reference this configuration for package creation and distribution
- Development environments - IDEs and development tools use tool configurations for code formatting and quality checks
- Package distribution platforms - PyPI and other repositories use metadata for package indexing and discovery
- MCP client applications - consume the built package as an MCP server providing JESSE framework functionality
- Docker containers and deployment systems - reference package configuration for containerized deployments

**âš¡ System role and ecosystem integration:**
- **System Role**: Central package configuration defining the complete build, distribution, and runtime requirements for the Jesse Framework MCP Server, enabling seamless integration of JESSE framework rules with MCP protocol implementation
- **Ecosystem Position**: Core infrastructure component that bridges JESSE framework content with Python packaging ecosystem, ensuring framework rules and workflows are distributed as a standard Python package with MCP server capabilities
- **Integration Pattern**: Consumed by Python build tools for package creation, referenced by dependency managers for installation, and used by development tools for code quality assurance while coordinating build-time content embedding with runtime MCP server functionality

######### Edge Cases & Error Handling

The configuration addresses Python version compatibility issues through explicit `requires-python = ">=3.10"` specification ensuring FastMCP v2.9.2 compatibility requirements are met. Build hook failures are mitigated through the custom `copy_jesse_content.py` script which handles missing source content and provides error reporting during package creation. Dependency resolution conflicts are managed through version pinning strategies using compatible version specifiers (`~=` for patch-level updates, `>=` for minimum versions) preventing incompatible library combinations. Development tool configuration includes error handling through `mypy` type checking with `warn_return_any` and `disallow_untyped_defs` flags catching type-related issues. The system handles package data inclusion failures through dual configuration using both modern hatchling and legacy setuptools specifications ensuring broad compatibility across different installation environments.

########## Internal Implementation Details

The build system uses `hatchling.build` backend with custom hook integration executing during package creation to embed JESSE framework content from the `artifacts/` directory into `jesse_framework_mcp/embedded_content/`. Dependency management employs semantic versioning with `fastmcp~=2.9.2` allowing patch updates while preventing minor version changes that could introduce breaking changes. Package data configuration uses `tool.hatch.build.targets.wheel.shared-data` mapping `embedded_content` to the package directory structure ensuring framework rules and workflows are included in wheel distributions. Development tooling configuration implements standardized settings with `black` line length of 88 characters, `isort` black profile compatibility, `mypy` strict type checking for Python 3.10, and `pytest` asyncio mode for testing MCP server functionality. The entry point configuration maps `jesse-framework-mcp` command to `jesse_framework_mcp:main` function enabling command-line server execution.

########### Code Usage Examples

This example demonstrates the package installation and basic usage pattern for the Jesse Framework MCP Server. The installation process includes all embedded JESSE framework content through the build-time copying mechanism.

```bash
# Install the Jesse Framework MCP Server package with all dependencies
pip install jesse-framework-mcp

# Run the MCP server with stdio transport for client communication
jesse-framework-mcp
```

This example shows the development environment setup using the optional development dependencies. The configuration enables comprehensive code quality checking and testing capabilities for framework development.

```bash
# Install development dependencies for contributing to the framework
pip install jesse-framework-mcp[dev]

# Run code quality checks using configured tools
black --check .
isort --check-only .
flake8 .
mypy .
pytest
```

This example illustrates the build process configuration showing how JESSE framework content is embedded during package creation. The custom build hook ensures framework rules and workflows are included in the distribution.

```toml
# Build system configuration with custom content embedding
[tool.hatch.build.hooks.custom]
path = "build_scripts/copy_jesse_content.py"

# Embedded content distribution in wheel packages
[tool.hatch.build.targets.wheel.shared-data]
"embedded_content" = "jesse_framework_mcp/embedded_content"
```

### {PROJECT_ROOT}/jesse-framework-mcp/README.md

*Last Updated: 2025-07-07T10:14:42Z*

#### Functional Intent & Features

This file implements comprehensive documentation for the Jesse Framework MCP Server, providing complete installation, configuration, and usage guidance for developers integrating the JESSE AI Framework through Model Context Protocol implementation. The documentation enables developers to replace manual 6-step session setup with single MCP tool calls while understanding build-time content embedding, project knowledge integration, and lazy loading capabilities. Key semantic entities include core MCP tools `jesse_start_session` and `jesse_load_knowledge_base` for framework initialization and knowledge base loading, installation methods using `uv` package manager and `pip` for distribution, configuration patterns for `Cline` MCP integration with `mcpServers` JSON configuration, directory structures `.knowledge/git-clones/`, `.knowledge/pdf-knowledge/`, `.knowledge/work-in-progress/` for project knowledge organization, build process components `artifacts/.clinerules/` source directory and `embedded_content/` destination, command-line interface `jesse-framework-mcp` for direct execution, session logging format with `.coding_assistant/jesse/session.log` file path, troubleshooting scenarios for build and runtime issues, development workflow commands `uv build`, `uv sync --dev`, `pytest`, `black`, `isort`, and `mypy` for code quality, and architectural patterns including build-time embedding, session initialization flow, and knowledge base discovery mechanisms. The system implements self-contained distribution with version-locked JESSE rules and portable execution across project directories.

##### Main Components

The documentation contains eleven primary sections providing comprehensive coverage of installation, usage, architecture, development, and troubleshooting for the Jesse Framework MCP Server. The Overview section establishes core functionality including complete session initialization, embedded framework content, and project knowledge integration. The Features section details core tools `jesse_start_session` and `jesse_load_knowledge_base` with self-contained distribution capabilities. The Installation section covers prerequisites, PyPI installation, and source installation methods. The Usage section provides Cline integration configuration, direct usage commands, and tool usage examples. The Architecture section explains build-time content embedding, session initialization flow, and knowledge base structure. The Development section covers building from source, testing procedures, and development dependencies. The Configuration section details session logging and knowledge base discovery mechanisms. The Troubleshooting section addresses build issues, runtime issues, and logging problems. The License, Contributing, and Support sections provide project governance and community information.

###### Architecture & Design

The architecture implements a comprehensive documentation structure with clear separation between user-facing functionality and technical implementation details, following standard open-source project documentation patterns with installation, usage, development, and troubleshooting sections. The design emphasizes practical guidance through concrete examples, step-by-step procedures, and troubleshooting scenarios while maintaining technical accuracy and completeness. Key design patterns include the progressive disclosure pattern starting with overview and features before diving into technical details, example-driven documentation pattern providing concrete code snippets and configuration examples, troubleshooting pattern addressing common issues with specific solutions, architectural explanation pattern using diagrams and flow descriptions for complex processes, and comprehensive coverage pattern addressing all aspects from installation to contribution guidelines. The system uses standard Markdown formatting with code blocks, JSON configurations, directory trees, and structured sections for maximum readability and accessibility.

####### Implementation Approach

The implementation uses structured Markdown documentation with hierarchical organization through header levels, code block formatting for examples and configurations, and comprehensive cross-referencing between related sections. Content organization follows logical user journey from installation through usage to development and troubleshooting. The approach implements concrete examples with actual command lines, configuration files, and directory structures rather than abstract descriptions. Technical concepts are explained through architectural diagrams using ASCII art and step-by-step process flows. Error scenarios include specific error messages with corresponding solutions and explanations. Development guidance provides complete workflow from building to testing with specific tool commands and dependencies. Installation instructions cover multiple package managers and deployment scenarios with platform-specific considerations.

######## External Dependencies & Integration Points

**â†’ References:**
- `Python 3.8+` runtime environment - required for MCP server execution and package installation
- `uv` package manager - recommended installation and development tool for dependency management
- `pip` package manager - alternative installation method for broader compatibility
- `Cline` AI assistant - primary integration target consuming MCP server through stdio transport
- `PyPI` package repository - distribution platform for jesse-framework-mcp package
- `Git` version control - source code management and repository cloning for development
- `artifacts/.clinerules/` directory - source location for JESSE framework content during build process
- `.knowledge/` directory structure - project-specific knowledge base organization and discovery

**â† Referenced By:**
- Developer installation workflows - using documentation for package setup and configuration
- Cline MCP configuration - consuming JSON configuration examples for server integration
- Build systems - referencing build process documentation for content embedding procedures
- Troubleshooting workflows - using error scenarios and solutions for issue resolution
- Development teams - following contribution guidelines and development setup procedures
- Package managers - distributing through PyPI with installation instructions and dependencies

**âš¡ System role and ecosystem integration:**
- **System Role**: Comprehensive documentation hub for Jesse Framework MCP Server ecosystem, providing authoritative guidance for installation, configuration, usage, and development workflows
- **Ecosystem Position**: Central reference point serving developers, integrators, and contributors with complete project information from basic usage to advanced development scenarios
- **Integration Pattern**: Used by developers for initial setup and ongoing reference, consumed by AI assistants through MCP protocol integration, referenced by build systems for content embedding procedures, and coordinated with package distribution platforms for installation and dependency management

######### Edge Cases & Error Handling

The documentation addresses build-time issues including missing JESSE project hierarchy with specific error messages and resolution steps. Installation problems are covered through multiple package manager options and troubleshooting for dependency conflicts. Runtime errors include embedded content loading failures with rebuild recommendations and knowledge base discovery issues with file path verification. Configuration problems address MCP server integration with Cline including transport protocol setup and command execution paths. Development environment issues cover build script testing, dependency installation, and code quality tool execution. Session logging failures are documented as non-blocking with permission-based solutions. Cross-platform compatibility considerations address different operating system requirements and path handling. Version compatibility issues between JESSE framework versions and MCP server releases are addressed through version-locking mechanisms and rebuild procedures.

########## Internal Implementation Details

The documentation uses standard Markdown syntax with consistent header hierarchy, code block formatting with language identifiers, and structured section organization. Installation procedures specify exact command sequences with package manager alternatives and environment setup requirements. Configuration examples provide complete JSON structures with proper syntax and required fields. Architectural explanations use ASCII art diagrams for build processes and directory structures with clear input-output relationships. Development workflows specify exact tool commands with dependency management and testing procedures. Error messages are quoted verbatim with corresponding solution steps and verification procedures. File path specifications use consistent notation with directory trailing slashes and relative path conventions. Code examples include both command-line usage and programmatic API calls with proper syntax highlighting and context explanations.

########### Usage Examples

MCP server installation demonstrates the primary setup workflow for developers integrating the Jesse Framework. This approach provides multiple installation methods with package manager flexibility and environment compatibility.

```bash
# Primary installation method using UV package manager for optimal dependency management
# Provides fastest installation with automatic virtual environment handling
uv add jesse-framework-mcp

# Alternative installation using pip for broader compatibility across development environments
# Supports traditional Python package installation workflows
pip install jesse-framework-mcp
```

Cline integration configuration showcases the MCP server setup pattern for AI assistant integration. This configuration enables seamless JESSE framework access through standardized MCP protocol communication.

```json
# Cline MCP server configuration for Jesse Framework integration
# Enables AI assistant access to complete JESSE framework through stdio transport
{
  "mcpServers": {
    "jesse-framework": {
      "command": "uv",
      "args": ["run", "jesse-framework-mcp"],
      "transport": "stdio"
    }
  }
}
```

Tool usage examples demonstrate the core MCP functionality for session initialization and knowledge base loading. These patterns enable developers to leverage JESSE framework capabilities through standardized tool calls.

```javascript
// Complete JESSE framework session initialization with project context loading
// Replaces manual 6-step setup with single tool call including WIP task integration
const context = await mcpClient.callTool("jesse_start_session", {
    user_prompt: "Help me implement authentication",
    load_wip_tasks: true
});

// Selective knowledge base loading for efficient context window management
// Enables targeted knowledge access based on task relevance and LLM selection
const kbContent = await mcpClient.callTool("jesse_load_knowledge_base", {
    kb_names: ["fastapi_kb", "aws_cdk_kb"]
});
```

### {PROJECT_ROOT}/jesse-framework-mcp/utils.py

*Last Updated: 2025-07-07T10:14:42Z*

#### Functional Intent & Features

This file implements FastMCP function unwrapping utilities for testing and development support, providing direct access to original functions from FastMCP decorated objects without MCP protocol overhead. The module enables developers to extract and validate underlying callable implementations from FastMCP wrapper objects for testing, debugging, and development workflows. Key semantic entities include primary function `unwrap_fastmcp_function()` for extracting original functions from decorated objects, helper functions `_is_fastmcp_wrapper()` and `_try_class_specific_extraction()` for wrapper detection and class-specific extraction patterns, metadata function `get_function_metadata()` for comprehensive function analysis, validation function `validate_fastmcp_function()` for FastMCP compatibility checking, imported modules `inspect` for function signature validation, `typing` for type hints and annotations, and `functools` for function metadata preservation, FastMCP wrapper types including `FunctionResource`, `FunctionTool`, and `FunctionPrompt`, function attribute patterns `fn`, `_func`, `__wrapped__`, `func`, `_function`, `handler`, `_handler`, `callback`, `_callback`, and `read` for extraction, exception types `TypeError`, `AttributeError`, and `ValueError` for comprehensive error handling, and validation parameters including `expected_context_param` for Context parameter checking. The system implements defensive programming with comprehensive error handling and descriptive messages while supporting all FastMCP decorator types with type safety and fallback mechanisms.

##### Main Components

The file contains four primary functions and two helper functions providing comprehensive FastMCP function unwrapping and validation capabilities. The `unwrap_fastmcp_function()` function serves as the main entry point for extracting original functions from FastMCP decorated objects with multi-pattern support. The `get_function_metadata()` function extracts comprehensive metadata from functions for debugging and validation including signature, docstring, and module information. The `validate_fastmcp_function()` function validates functions against FastMCP requirements checking async patterns, Context parameters, and documentation standards. Helper functions include `_is_fastmcp_wrapper()` for detecting FastMCP wrapper types based on class name patterns and attributes, and `_try_class_specific_extraction()` for attempting class-specific function extraction patterns for different FastMCP wrapper types. The module provides comprehensive support for `FunctionResource`, `FunctionTool`, and `FunctionPrompt` wrapper types with fallback mechanisms for unknown wrapper patterns.

###### Architecture & Design

The architecture implements a multi-pattern extraction system with defensive programming principles, following clean separation between MCP protocol handling and direct function access with comprehensive error handling and type safety validation. The design emphasizes support for all FastMCP decorator types through attribute inspection and class-specific extraction patterns, robust wrapper detection using multiple heuristics, and comprehensive validation with clear guidance for fixing issues. Key design patterns include the extraction pattern with multiple attribute attempts for different FastMCP wrapper storage mechanisms, validation pattern providing detailed compatibility checking with specific recommendations, helper pattern separating wrapper detection and class-specific extraction logic, metadata pattern extracting comprehensive function information for analysis, and fallback pattern providing graceful degradation for unknown wrapper types. The system uses composition over inheritance with specialized functions for different aspects, comprehensive error handling with descriptive messages, and type safety with proper validation throughout the extraction process.

####### Implementation Approach

The implementation uses attribute inspection algorithms with systematic attempts through predefined function attribute lists including `fn`, `_func`, `__wrapped__`, `func`, `_function`, `handler`, `_handler`, `callback`, `_callback`, and `read` for comprehensive extraction coverage. Wrapper detection employs class name pattern matching for FastMCP types and attribute presence checking for common wrapper characteristics. The approach implements class-specific extraction patterns for `Resource`, `Tool`, and `Prompt` wrapper types with dedicated attribute attempts for each category. Function validation uses `inspect.signature()` for parameter analysis and `inspect.iscoroutinefunction()` for async pattern verification. Error handling employs specific exception types with detailed error messages including available attributes and extraction methods for debugging support. Metadata extraction combines `inspect` module functions for signature, documentation, and source information with safe fallbacks for missing attributes. Type safety validation ensures extracted objects are callable with proper signature patterns before returning results.

######## External Dependencies & Integration Points

**â†’ Inbound:**
- `inspect` (external library) - function signature validation, metadata extraction, and source code analysis for comprehensive function introspection
- `typing` (external library) - type hints and annotations including Any, Callable, Union for comprehensive type safety
- `functools` (external library) - function metadata preservation and wrapper utilities for maintaining function characteristics

**â† Outbound:**
- FastMCP resource handlers - consuming `unwrap_fastmcp_function()` for direct function access during testing and development workflows
- Testing frameworks - using extracted functions for unit testing without MCP protocol overhead
- Development tools - accessing function metadata and validation results for debugging and analysis
- Session initialization systems - using function unwrapping for direct function invocation and compatibility checking
- Resource validation systems - consuming validation functions for FastMCP compliance verification

**âš¡ System role and ecosystem integration:**
- **System Role**: Development and testing utility for Jesse Framework MCP Server ecosystem, providing direct access to underlying function implementations from FastMCP decorated objects for testing, debugging, and development workflows
- **Ecosystem Position**: Support utility serving development and testing needs, enabling direct function access without MCP protocol complexity while maintaining compatibility with all FastMCP decorator patterns
- **Integration Pattern**: Used by developers for testing FastMCP resources directly, consumed by testing frameworks for unit test execution, integrated with development workflows for function analysis and validation, and coordinated with FastMCP decorators for seamless function extraction across different wrapper types

######### Edge Cases & Error Handling

The system handles unknown FastMCP wrapper types through comprehensive attribute inspection with fallback to class-specific extraction patterns when standard attributes unavailable. Missing function attributes are managed through systematic attempts across multiple attribute names with descriptive error messages listing available attributes for debugging. Non-callable extracted objects trigger `TypeError` exceptions with specific object type information and extraction method context. Invalid function signatures are handled through `inspect.signature()` validation with warnings for functions lacking Context parameters. Wrapper detection edge cases include objects with partial FastMCP characteristics handled through conservative detection heuristics. Function metadata extraction manages missing attributes through safe fallbacks preventing extraction failures. Signature inspection failures are handled gracefully with continued execution and warning messages rather than complete failure. Class-specific extraction handles unknown class types through pattern matching with graceful None returns for unsupported wrapper types.

########## Internal Implementation Details

The module uses systematic attribute inspection with predefined lists including primary `fn` attribute for FastMCP FunctionResource objects and fallback attributes for various wrapper patterns. Wrapper detection implements class name pattern matching for `FunctionResource`, `FunctionTool`, `FunctionPrompt`, `Resource`, `Tool`, and `Prompt` patterns with attribute presence checking for `_func`, `__wrapped__`, `func`, and `_function`. Class-specific extraction employs dedicated patterns for Resource, Tool, and Prompt wrapper types with specific attribute attempts including `_func`, `handler`, `_handler`, and `callback` for each category. Function validation uses `inspect.iscoroutinefunction()` for async requirement checking and parameter analysis for Context parameter validation. Metadata extraction combines `inspect.signature()`, `inspect.getdoc()`, `inspect.getfile()`, and `inspect.getsourcelines()` with exception handling for unavailable information. Error messages include specific wrapper types, available attributes, and extraction methods for comprehensive debugging support. Type safety validation ensures callable objects with proper signatures before function return.

########### Code Usage Examples

FastMCP function unwrapping demonstrates the primary usage pattern for extracting original functions from decorated objects for direct testing. This approach enables developers to test FastMCP resources without MCP protocol overhead while maintaining full function access.

```python
# Extract original function from FastMCP decorated resource for direct testing
# Enables testing without MCP protocol complexity while preserving function behavior
from utils import unwrap_fastmcp_function

# Unwrap FastMCP resource to access underlying function
original_function = unwrap_fastmcp_function(decorated_resource)
# Direct function invocation for testing with Context parameter
result = await original_function(context, *args, **kwargs)
```

Function validation showcases the FastMCP compatibility checking pattern for ensuring proper function structure. This pattern provides comprehensive validation with specific recommendations for fixing compatibility issues.

```python
# Validate function compatibility with FastMCP requirements and get detailed feedback
# Provides comprehensive validation results with specific recommendations for fixes
from utils import validate_fastmcp_function, get_function_metadata

# Validate FastMCP function requirements
validation_result = validate_fastmcp_function(function, expected_context_param="ctx")
if not validation_result['is_valid']:
    print("Validation issues:", validation_result['issues'])
    print("Recommendations:", validation_result['recommendations'])

# Extract comprehensive function metadata for analysis
metadata = get_function_metadata(function)
print(f"Function: {metadata['name']}, Parameters: {metadata['parameters']}")
```

### {PROJECT_ROOT}/jesse-framework-mcp/uv.lock

*Last Updated: 2025-07-07T10:14:42Z*

#### Functional Intent & Features

This file serves as the dependency lock file for the Jesse Framework MCP Server project, providing deterministic package resolution and version pinning for all direct and transitive dependencies across the Python ecosystem. The lock file ensures reproducible builds and consistent development environments by specifying exact versions, checksums, and source locations for every package required by the project. Key semantic entities include `uv.lock` format with `version = 1` and `revision = 1` metadata, `requires-python = ">=3.10"` compatibility specification, `jesse-framework-mcp` as the main package with `version = "0.1.0"` and `source = { editable = "." }` configuration, comprehensive dependency graph including `fastmcp~=2.9.2` for MCP protocol implementation, `boto3>=1.38.46` for AWS integration, `strands-agents>=0.1.0` for agent framework support, `mistletoe>=1.4.0` for markdown processing, `PyYAML>=6.0` for YAML handling, development dependencies including `pytest>=8.4.1`, `black>=25.1.0`, `mypy>=1.16.1`, and `flake8>=7.3.0`, with detailed package metadata containing SHA256 hashes, wheel URLs, and source distribution information ensuring cryptographic verification and supply chain security for all dependencies.

##### Main Components

The lock file contains 77 distinct package entries organized into a flat dependency structure with comprehensive metadata for each package. Primary components include the main project package `jesse-framework-mcp` with editable source configuration and optional development dependencies, core runtime dependencies such as `fastmcp`, `boto3`, `strands-agents`, `mistletoe`, and `pyyaml`, development tooling packages including `pytest`, `pytest-asyncio`, `black`, `isort`, `flake8`, and `mypy`, and extensive transitive dependencies covering cryptography (`cryptography`, `cffi`), HTTP clients (`httpx`, `httpcore`, `h11`), async frameworks (`anyio`, `starlette`, `uvicorn`), data validation (`pydantic`, `pydantic-core`), and utility libraries (`click`, `rich`, `typer`). Each package entry includes version specifications, source registry information, dependency relationships, and cryptographic verification data through SHA256 hashes for both source distributions and wheel files.

###### Architecture & Design

The architecture implements a comprehensive dependency resolution system using the `uv` package manager format with deterministic version locking and cryptographic verification. The design employs a flat package structure where each dependency is explicitly listed with complete metadata including version constraints, source locations, and integrity checksums. The system uses semantic versioning with compatible version ranges (`~=` for patch-level updates, `>=` for minimum versions) while locking to specific versions for reproducibility. The architectural pattern includes conditional dependencies based on Python version markers (`python_full_version < '3.11'`, `python_full_version < '3.13'`) and platform-specific markers (`sys_platform == 'win32'`, `platform_python_implementation != 'PyPy'`), comprehensive wheel distribution support across multiple platforms (macOS, Linux, Windows) and architectures (x86_64, ARM64, i686), and development dependency separation through optional dependency groups enabling different installation profiles.

####### Implementation Approach

The implementation uses the `uv` lock file format version 1 with revision 1, providing structured dependency resolution with exact version pinning and cryptographic verification through SHA256 hashes. The approach employs comprehensive package metadata including source registry URLs (`https://pypi.org/simple`), wheel and source distribution URLs with integrity hashes, and dependency relationship mapping with conditional markers. Version resolution implements semantic versioning constraints while locking to specific versions ensuring reproducible builds across different environments. The system handles platform-specific dependencies through conditional markers, supports both wheel and source distribution installations, and maintains separate dependency groups for development and runtime requirements. Package verification uses SHA256 checksums for both wheel files and source distributions, ensuring supply chain security and preventing dependency tampering.

######## External Dependencies & Integration Points

**â†’ References:**
- `https://pypi.org/simple` - primary package index registry for all external dependencies and package resolution
- `https://files.pythonhosted.org/packages/` - CDN hosting wheel and source distribution files with SHA256 verification
- `fastmcp~=2.9.2` (external library) - FastMCP framework for MCP protocol implementation and server functionality
- `boto3>=1.38.46` (external library) - AWS SDK for Python enabling cloud service integration and API access
- `strands-agents>=0.1.0` (external library) - agent framework for AI assistant coordination and management capabilities
- `mistletoe>=1.4.0` (external library) - markdown parser and renderer for processing framework documentation
- `PyYAML>=6.0` (external library) - YAML processing library for configuration and data serialization operations

**â† Referenced By:**
- `uv` package manager - consumes lock file for deterministic dependency resolution and installation operations
- CI/CD build systems - reference lock file for consistent dependency installation across build environments
- Development environments - use lock file to ensure consistent package versions across team members
- Docker containers - leverage lock file for reproducible container builds with exact dependency versions
- Package distribution systems - reference dependency specifications for package metadata and requirements
- Security scanning tools - analyze lock file for vulnerability detection and dependency audit procedures

**âš¡ System role and ecosystem integration:**
- **System Role**: Central dependency management artifact for the Jesse Framework MCP Server, ensuring deterministic package resolution and reproducible builds across all deployment environments
- **Ecosystem Position**: Critical infrastructure component that defines the complete dependency graph for the project, enabling consistent development, testing, and production deployments
- **Integration Pattern**: Consumed by package managers for installation, referenced by CI/CD systems for build reproducibility, and used by security tools for vulnerability scanning while maintaining cryptographic verification of all dependencies through SHA256 checksums

######### Edge Cases & Error Handling

The lock file addresses dependency resolution conflicts through exact version pinning and comprehensive constraint satisfaction across the entire dependency graph. Platform compatibility issues are handled through conditional dependency markers and multiple wheel distributions supporting different operating systems and architectures. Python version compatibility constraints prevent installation on unsupported Python versions through `requires-python = ">=3.10"` specification. Package integrity failures are detected through SHA256 hash verification for both wheel and source distributions. The system handles missing optional dependencies through conditional markers and graceful degradation patterns. Network connectivity issues during package installation are mitigated through multiple mirror support and cached wheel distributions. Version constraint conflicts are resolved through the lock file's deterministic resolution ensuring all transitive dependencies are compatible.

########## Internal Implementation Details

The lock file format uses TOML syntax with structured package entries containing comprehensive metadata including version specifications, source registry information, dependency relationships, and cryptographic verification data. Each package entry includes `name`, `version`, `source` registry information, `dependencies` array with conditional markers, `sdist` source distribution metadata with URL and SHA256 hash, and `wheels` array containing platform-specific wheel files with URLs and integrity checksums. Dependency resolution implements constraint satisfaction algorithms ensuring all version requirements are met across the entire dependency graph. Platform-specific handling uses conditional markers like `python_full_version < '3.11'` and `sys_platform == 'win32'` for targeted dependency inclusion. The system maintains separate dependency groups through `optional-dependencies` and `dev-dependencies` sections enabling different installation profiles for development and production environments.

########### Code Usage Examples

This example demonstrates installing dependencies using the lock file for reproducible development environment setup. The lock file ensures exact versions are installed matching the project's tested configuration.

```bash
# Install dependencies using uv with lock file for exact version matching
uv sync
# Installs all dependencies with exact versions specified in uv.lock
```

This example shows how to install only production dependencies excluding development tools. The lock file supports selective installation based on dependency groups and optional requirements.

```bash
# Install production dependencies only using lock file specifications
uv sync --no-dev
# Excludes development dependencies like pytest, black, mypy from installation
```

This example illustrates adding a new dependency while maintaining lock file integrity. The lock file must be updated to include new dependencies with proper version resolution and hash verification.

```bash
# Add new dependency and update lock file with resolved versions
uv add requests
uv lock
# Updates uv.lock with new dependency and all transitive requirements
```

---
*Generated: 2025-07-07T10:14:42Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp*
*Total Files: 5*
*Total Subdirectories: 3*

# End of jesse-framework-mcp_kb.md