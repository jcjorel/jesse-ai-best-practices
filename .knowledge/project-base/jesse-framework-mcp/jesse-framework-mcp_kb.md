<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/

## Global Summary

#### Functional Intent & Features

This directory implements the complete Jesse Framework MCP Server project, providing a comprehensive AI-assisted development platform through `FastMCP` protocol integration with embedded content delivery, hierarchical knowledge base management, and intelligent resource orchestration for modern development workflows. The system delivers complete MCP server functionality through standardized resource endpoints, automated knowledge indexing, LLM-powered content analysis, and embedded framework rules enabling consistent AI-assisted development practices. Key semantic entities include `FastMCP` server instance with `server = FastMCP("JESSE Framework")`, primary entry point `main()` function using `server.run(transport="stdio")`, comprehensive resource handlers including `framework_index()` decorated with `@server.resource("jesse://index")`, knowledge base integration via `register_knowledge_bases_tools()` and `register_knowledge_bases_resources()`, embedded content access through `load_embedded_content()` and `get_jesse_rule_files()`, hierarchical indexing system with `HierarchicalIndexer`, `KnowledgeBuilder`, and `RebuildDecisionEngine` components, LLM integration through `StrandsClaude4Driver` with `Claude4SonnetConfig` factory methods, HTTP formatting utilities `format_http_section()` and `format_multi_section_response()` with `XAsyncContentCriticality` classifications, resource URIs including `jesse://framework/rule/{rule_name}`, `jesse://session/init-context`, `jesse://wip-tasks`, and `file://workflows/{workflow_name}`, comprehensive helper modules for `content_loaders`, `session_management`, `knowledge_scanners`, `path_utils`, and `async_http_formatter`, embedded framework rules `JESSE_KNOWLEDGE_MANAGEMENT.md`, `JESSE_CODE_COMMENTS.md`, `JESSE_CODE_GENERATION.md`, specialized workflow automation through 15 markdown-based workflow definitions, build-time content preparation through `copy_jesse_content.py` with `JesseBuildHook` integration, comprehensive testing infrastructure with `pytest` framework, and complete development governance through consolidated standards documents ensuring consistent AI-assisted development practices across the entire Jesse Framework MCP ecosystem.

##### Main Components

The directory contains comprehensive project structure with core Python package, testing infrastructure, build system integration, documentation, and configuration files providing complete MCP server functionality and development governance. The `jesse_framework_mcp/` subdirectory implements the main Python package with three primary files (`main.py`, `constants.py`, `__init__.py`) and seven specialized subdirectories including `knowledge_bases/` for hierarchical indexing, `helpers/` for utility functions, `llm/` for LLM integration, `resources/` for MCP resource handlers, and `embedded_content/` for framework governance. The `tests/` subdirectory provides comprehensive testing infrastructure with 21 test files covering session initialization, HTTP formatting, knowledge base processing, and integration testing. The `build_scripts/` subdirectory contains build-time infrastructure with `copy_jesse_content.py` for automated framework content preparation during package builds. Project configuration includes `pyproject.toml` for Python packaging with Hatchling build system, `uv.lock` for deterministic dependency resolution, `.gitignore` for version control exclusions, and `README.md` for comprehensive documentation. Supporting files include `utils.py` for FastMCP function unwrapping utilities and development workflow support.

###### Architecture & Design

The architecture implements a layered MCP server design with clear separation between protocol handling, resource management, knowledge processing, and embedded content delivery through modular component organization and standardized integration patterns. The design emphasizes resource-first architecture with individual resource access patterns, comprehensive session initialization through meta-resource aggregation, and intelligent knowledge base management through hierarchical processing strategies. The system employs `FastMCP` native transport with automatic lifecycle management, HTTP-formatted resource delivery for consistent AI assistant processing, and embedded content access patterns using `importlib.resources` for package-bundled framework rules and workflows. Key design patterns include the resource handler pattern with `FastMCP` decorators for endpoint registration, Plan-then-Execute architecture separating decision-making from execution through distinct phases, meta-resource aggregation pattern combining multiple contexts into unified responses, async-first architecture with comprehensive context manager support, hierarchical processing pattern ensuring leaf-first dependency ordering, cache-first processing strategies through `FileAnalysisCache` integration, embedded content access pattern for self-contained framework delivery, and build-time content preparation pattern through Hatchling integration. The architectural framework uses composition over inheritance with specialized classes for different concerns, centralized configuration management through constants and helper modules, comprehensive error handling with graceful degradation, and modular organization enabling independent evolution of different system components while maintaining consistent integration patterns.

####### Implementation Approach

The implementation uses `FastMCP` native transport with `server.run(transport="stdio")` eliminating manual event loop management and leveraging automatic lifecycle handling for modern MCP protocol compliance. Resource discovery employs dynamic scanning of available components including framework rules enumeration, knowledge base scanning, and WIP task counting through directory iteration with JSON serialization for structured metadata delivery. The approach implements five-phase Plan-then-Execute workflows through recursive directory discovery, centralized decision analysis via `RebuildDecisionEngine`, atomic task generation through `PlanGenerator`, execution preview for debugging validation, and dependency-aware task execution via `ExecutionEngine` with performance metrics collection. Content delivery combines embedded content access using `importlib.resources` for package-bundled rules and workflows, project-specific knowledge loading from `.knowledge/` directory structures, and HTTP formatting through standardized section wrapping with appropriate criticality classifications. LLM integration employs async context manager patterns with `StrandsClaude4Driver` providing streaming capabilities, conversation management, and intelligent caching through SHA-256 hashing with TTL expiration policies. Build system integration uses Hatchling build hooks with `JesseBuildHook` class implementing `BuildHookInterface` for automated content copying from `artifacts/.clinerules/` to `embedded_content/` during package creation. The system implements comprehensive path resolution using portable path variables `{PROJECT_ROOT}`, `{HOME}`, `{CLINE_RULES}`, cross-platform compatibility through `pathlib.Path` operations, and defensive programming patterns with comprehensive error handling and graceful degradation across all operational components.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:FastMCP` (external library) - MCP server framework providing native transport, resource registration, and protocol compliance with automatic lifecycle management
- `fastmcp:Context` (external library) - MCP context interface for async progress reporting, error logging, and user interaction throughout all server operations
- `strands:Agent` (external library) - Strands Agent SDK for Claude 4 Sonnet interaction with real-time streaming capabilities and AWS Bedrock integration
- `strands.models:BedrockModel` (external library) - Bedrock model wrapper for AWS integration and LLM configuration management
- `boto3` (external library) - AWS SDK for Python enabling Amazon Bedrock service access and authentication for LLM operations
- `mistletoe` (external library) - AST-based markdown parsing and rendering for reliable document manipulation and content extraction
- `pydantic` (external library) - Configuration validation and type safety for indexing parameters and data model integrity
- `hatchling.builders.hooks.plugin.interface:BuildHookInterface` (external library) - Hatchling build system integration interface for automated content preparation
- `pytest` (external library) - Comprehensive testing framework with fixtures, parametric testing, and assertion utilities
- `importlib.resources` (external library) - Embedded content access with Python version compatibility for package-bundled framework rules and workflows
- `pathlib.Path` (external library) - Cross-platform path operations and filesystem metadata access for directory traversal and file processing
- `asyncio` (external library) - Async programming patterns and concurrency control for performance optimization and parallel processing
- AWS environment variables `AWS_REGION`, `AWS_PROFILE`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` - Authentication and configuration for LLM services
- `artifacts/.clinerules/` - Source JESSE framework files for build-time content preparation

**← Outbound:**
- MCP clients - consuming comprehensive framework resources through standardized MCP protocol with resource and prompt endpoints
- Cline AI assistant - accessing framework initialization prompts, workflow resources as slash commands, and comprehensive session context
- Development environments - using Jesse Framework resources for AI-assisted development workflows and context delivery
- AI coding assistants - consuming framework rules with CRITICAL criticality for strict adherence and workflow guidance
- Package distribution platforms - PyPI and other repositories using package metadata for distribution and installation
- `{PROJECT_ROOT}/.knowledge/project-base/` - Generated knowledge base files with hierarchical structure mirroring source organization
- `{PROJECT_ROOT}/.knowledge/git-clones/` - Specialized knowledge structures for git repository processing with read-only mirrored organization
- `debug_output/llm_debug/` - Debug interaction capture files for development workflow support and LLM interaction replay
- `cache_files/*.analysis.md` - Cached analysis files for performance optimization and staleness detection
- AWS Bedrock service integration - Generating actual API calls, streaming responses, and conversation management for live LLM interaction
- CI/CD pipeline systems - Consuming test results, build artifacts, and deployment validation reports

**⚡ System role and ecosystem integration:**
- **System Role**: Complete MCP server implementation for Jesse Framework ecosystem, serving as the central orchestrator for AI-assisted development workflows with embedded content delivery, hierarchical knowledge management, intelligent resource coordination, and comprehensive testing infrastructure
- **Ecosystem Position**: Core infrastructure platform providing complete MCP protocol compliance while bridging embedded framework governance with runtime project knowledge loading, LLM-powered content analysis, standardized resource delivery for AI assistants, and automated build-time content preparation
- **Integration Pattern**: Used by MCP clients through stdio transport for resource and prompt access, consumed by AI assistants for framework initialization and workflow guidance, integrated with AWS Bedrock services through specialized driver implementations, coordinated with development tools through standardized resource endpoints, built through Hatchling with automated content preparation, tested through comprehensive test suites, and distributed through Python packaging ecosystem while supporting comprehensive development workflows through embedded content delivery and intelligent knowledge base management

######### Edge Cases & Error Handling

The system implements comprehensive error handling across multiple operational layers including MCP protocol validation, filesystem access restrictions, LLM processing failures, embedded content access issues, build system integration problems, and testing infrastructure challenges. `FastMCP` server startup failures are managed through comprehensive exception handling in `main()` function with descriptive error logging and proper exception propagation for debugging support. Knowledge base processing addresses truncation detection through `TruncationDetectedError` preventing artifact creation when LLM responses are incomplete, empty directory handling by detecting contentless directories and skipping knowledge file generation, and filesystem access restrictions with `OSError` and `PermissionError` catching enabling continued processing. Resource delivery handles missing project root through comprehensive validation with fallback to setup guidance when project structure unavailable, individual resource failures through try-catch blocks preventing complete resource delivery failures, and working directory management with restoration mechanisms preventing directory state corruption. LLM integration manages missing Strands Agent SDK through conditional imports with availability flags and mock class definitions, AWS Bedrock connection failures through specialized exception handling with region context and troubleshooting guidance, and streaming failures through retry logic with exponential backoff for transient network issues. Build system integration handles missing JESSE project root through `find_jesse_project_root()` validation with descriptive error messages, missing source directories through existence checking with specific resolution guidance, and Hatchling build hook failures through proper exception propagation. Testing infrastructure manages test isolation through temporary directory creation, mock context implementation for FastMCP compatibility, and comprehensive assertion-based validation with detailed error reporting. The system handles cross-platform compatibility issues through `pathlib.Path` usage, environment variable resolution, and portable path variable substitution ensuring consistent behavior across Linux, macOS, and Windows systems.

########## Internal Implementation Details

The MCP server uses `FastMCP` native transport with `server = FastMCP("JESSE Framework")` initialization and automatic lifecycle management eliminating manual event loop creation while providing comprehensive resource registration through decorator-based auto-registration patterns. Resource index generation employs dynamic component discovery including rule enumeration through `await get_available_rule_names()`, knowledge base scanning with exception handling, and WIP task directory iteration using structured JSON serialization with Unicode support. Knowledge base processing maintains performance tracking through `_decisions_made`, `_filesystem_operations`, and decision timing counters for optimization monitoring across all processing phases while implementing Plan-then-Execute architecture with five distinct phases from discovery through atomic execution. HTTP formatting uses consistent patterns with `format_http_section()` calls including specific content types, criticality classifications using `XAsyncContentCriticality.CRITICAL` and `XAsyncContentCriticality.INFORMATIONAL`, portable location paths with `{PROJECT_ROOT}` placeholders, and additional headers for enhanced metadata delivery. LLM integration employs lazy initialization with thread-safe locks for external SDK component initialization, cache implementation using SHA-256 hash truncation to 16 characters for keys, TTL-based expiration with periodic cleanup, and conversation management through separate dictionaries for contexts and message arrays. Embedded content organization uses module-relative path resolution through `EMBEDDED_CONTENT_DIR = Path(__file__).parent` ensuring consistent access regardless of installation location, rule content retrieval with f-string formatting using `JESSE_{rule_name.upper()}.md` pattern matching, and workflow access with conditional extension appending and comprehensive error handling for missing content scenarios. Build system integration uses `sys.path.insert()` for dynamic import path manipulation, `shutil.copy2()` for metadata-preserving file copying, and `shutil.copytree()` for recursive directory structure preservation. Testing infrastructure employs `MockContext` classes for FastMCP simulation, temporary directory creation with `tempfile.TemporaryDirectory()` for test isolation, and comprehensive assertion-based validation with detailed console output for debugging support.

########### Usage Examples

**Complete MCP server initialization and execution:**

This example demonstrates the primary startup pattern for Jesse Framework MCP server with comprehensive resource registration and embedded content delivery. The approach provides complete MCP protocol compliance with automatic lifecycle management.

```python
# Initialize and run Jesse Framework MCP server with comprehensive functionality
from jesse_framework_mcp.main import main
from jesse_framework_mcp import __version__

# Start server with FastMCP native transport and complete resource registration
# Provides automatic lifecycle management, embedded content access, and knowledge base integration
if __name__ == "__main__":
    print(f"Starting Jesse Framework MCP Server v{__version__}")
    main()  # Runs with stdio transport managing all MCP protocol communication
```

**Comprehensive resource access and session initialization:**

This pattern shows how MCP clients access the complete Jesse Framework context through session initialization and individual resource endpoints. The approach enables efficient AI assistant setup with all essential development contexts.

```python
# Access comprehensive Jesse Framework resources through MCP client integration
# Demonstrates session initialization and individual resource consumption patterns

# Complete session initialization with all essential contexts
session_context = await mcp_client.read_resource("jesse://session/init-context")
# Returns multi-section HTTP response with framework rules, project context, workflows, and compliance

# Individual resource access for specific development contexts
framework_rule = await mcp_client.read_resource("jesse://framework/rule/knowledge_management")
project_knowledge = await mcp_client.read_resource("jesse://project/knowledge")
wip_tasks = await mcp_client.read_resource("jesse://wip-tasks")
workflow = await mcp_client.read_resource("file://workflows/jesse_wip_task_create")

# Knowledge base access with lazy loading and metadata extraction
knowledge_base = await mcp_client.read_resource("jesse://knowledge/cline_kb")
```

**Hierarchical knowledge base processing with Plan-then-Execute architecture:**

This example demonstrates the complete knowledge indexing workflow from configuration through execution, showcasing the Plan-then-Execute architecture with comprehensive progress tracking and LLM integration.

```python
# Execute comprehensive hierarchical knowledge base indexing with Plan-then-Execute workflow
from jesse_framework_mcp.knowledge_bases import (
    HierarchicalIndexer, IndexingConfig, IndexingMode,
    register_knowledge_bases_tools, register_knowledge_bases_resources
)
from jesse_framework_mcp.llm.strands_agent_driver import StrandsClaude4Driver, Claude4SonnetConfig
from pathlib import Path

# Configure comprehensive indexing with LLM integration
config = IndexingConfig(
    handler_type="project-base",
    indexing_mode=IndexingMode.INCREMENTAL,
    max_concurrent_operations=4,
    debug_mode=True
)

# Initialize LLM driver for content analysis
llm_config = Claude4SonnetConfig.create_optimized_for_analysis(
    enable_prompt_caching=True,
    aws_region="us-west-2"
)

async def run_complete_framework_workflow():
    # Initialize hierarchical indexer with Plan-then-Execute architecture
    indexer = HierarchicalIndexer(config)
    
    # Execute five-phase workflow: Discovery, Decision Analysis, Plan Generation, Preview, Execution
    async with StrandsClaude4Driver(llm_config) as llm_driver:
        status = await indexer.index_hierarchy(Path("./src"), ctx)
        
        print(f"Processing: {status.processing_stats.progress_percentage:.1f}%")
        print(f"LLM calls: {status.processing_stats.llm_calls_made}")
        print(f"Files processed: {status.processing_stats.files_processed}")
        print(f"Knowledge files generated: {status.processing_stats.directories_processed}")
        
        return status

# Cleanup resources after processing
await indexer.cleanup()
```

## Subdirectory Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/build_scripts/
*Last Updated: 2025-07-06T23:20:06Z*

This directory implements the build-time infrastructure for the Jesse Framework MCP Server, providing automated framework content preparation and distribution packaging through Hatchling build system integration. The directory enables single source of truth copying from `artifacts/.clinerules/` to `embedded_content/` during package builds, ensuring complete JESSE framework content including rules and workflows is embedded in the MCP server package for runtime access. Key semantic entities include the primary build script `copy_jesse_content.py` containing orchestration function `copy_jesse_content()`, specialized copying functions `copy_jesse_rules()` and `copy_jesse_workflows()`, project discovery utility `find_jesse_project_root()`, Hatchling integration class `JesseBuildHook` implementing `BuildHookInterface`, legacy compatibility function `hatch_build_hook()`, imported modules `os`, `shutil`, and `pathlib.Path` for file operations, centralized configuration import `get_jesse_rule_files()` from constants module, source directory structure `artifacts/.clinerules/` containing framework files, destination structure `embedded_content/` for runtime embedding, and comprehensive error handling with `ValueError` and `FileNotFoundError` exceptions for missing components. The system implements defensive programming with descriptive error messages and complete framework copying through build system integration ensuring automated content preparation during package creation.

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/
*Last Updated: 2025-07-06T23:20:06Z*

This directory implements the core Jesse Framework MCP Server package, providing a comprehensive AI-assisted development platform through `FastMCP` protocol integration with embedded content delivery, hierarchical knowledge base management, and intelligent resource orchestration for modern development workflows. The system delivers complete MCP server functionality through standardized resource endpoints, automated knowledge indexing, LLM-powered content analysis, and embedded framework rules enabling consistent AI-assisted development practices. Key semantic entities include `FastMCP` server instance with `server = FastMCP("JESSE Framework")`, primary entry point `main()` function using `server.run(transport="stdio")`, comprehensive resource handlers including `framework_index()` decorated with `@server.resource("jesse://index")`, knowledge base integration via `register_knowledge_bases_tools()` and `register_knowledge_bases_resources()`, embedded content access through `load_embedded_content()` and `get_jesse_rule_files()`, hierarchical indexing system with `HierarchicalIndexer`, `KnowledgeBuilder`, and `RebuildDecisionEngine` components, LLM integration through `StrandsClaude4Driver` with `Claude4SonnetConfig` factory methods, HTTP formatting utilities `format_http_section()` and `format_multi_section_response()` with `XAsyncContentCriticality` classifications, resource URIs including `jesse://framework/rule/{rule_name}`, `jesse://session/init-context`, `jesse://wip-tasks`...

### {PROJECT_ROOT}/jesse-framework-mcp/tests/
*Last Updated: 2025-07-06T23:20:06Z*

Comprehensive test suite validating the Jesse Framework MCP Server's knowledge base indexing system, HTTP formatting infrastructure, and resource endpoint functionality through isolated unit tests, integration testing, and real-world validation scenarios. Provides extensive testing capabilities for hierarchical dependency planning, cache integration, configuration management, project root detection, and MCP resource protocol compliance. Enables developers to verify system reliability through targeted validation of `HierarchicalIndexer`, `RebuildDecisionEngine`, `FileAnalysisCache`, `XAsyncHttpPath`, `IndexingConfig`, session initialization resources, and gitignore compliance functionality. Key semantic entities include `pytest`, `asyncio`, `tempfile`, `MockContext`, `TestContext`, `unwrap_fastmcp_function`, `pathlib.Path`, `FastMCP` protocol simulation, `jesse://session/init-context`, `jesse://project/gitignore-files`, `StrandsClaude4Driver`, `Claude4SonnetConfig`, boundary marker validation (`--JESSE_FRAMEWORK_BOUNDARY_2025--`), HTTP status code testing, and comprehensive decision outcome validation through `DecisionOutcome`, `DecisionReason`, and `DecisionReport` structures.

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/.gitignore

*Last Updated: 2025-07-06T23:20:06Z*

#### Functional Intent & Features

This file implements Git version control exclusion rules for the Jesse Framework MCP Server project, providing comprehensive ignore patterns that prevent sensitive files, build artifacts, and temporary content from being tracked in the repository while preserving essential knowledge base metadata. The configuration enables selective knowledge management by ignoring actual content files while preserving documentation and structure, supporting development workflows with comprehensive Python ecosystem exclusions, and maintaining clean repository state across multiple development environments. Key semantic entities include knowledge management patterns `.knowledge/git-clones/*/` and `.knowledge/pdf-knowledge/*.pdf` for content exclusion, negation patterns `!.knowledge/git-clones/*.md` and `!.knowledge/pdf-knowledge/README.md` for metadata preservation, Python-specific patterns `__pycache__/`, `*.py[cod]`, `build/`, `dist/`, `*.egg-info/` for build artifact exclusion, virtual environment patterns `.env`, `.venv`, `env/`, `venv/` for environment isolation, IDE patterns `.vscode/`, `.idea/`, `*.swp` for editor file exclusion, testing patterns `.pytest_cache/`, `.coverage`, `htmlcov/` for test artifact management, OS-specific patterns `.DS_Store`, `Thumbs.db` for system file exclusion, and MCP server patterns `mcp-server.log`, `server.log`, `debug.log` for runtime log management. The system implements selective preservation through Git negation patterns ensuring knowledge base documentation remains tracked while excluding large binary content and sensitive runtime data.

##### Main Components

The file contains eight primary section categories providing comprehensive version control exclusion coverage for the Jesse Framework MCP Server project. The knowledge management section defines patterns for `.knowledge/git-clones/` and `.knowledge/pdf-knowledge/` directories with selective exclusion and preservation rules. The Python section includes comprehensive patterns for build artifacts, bytecode, distribution files, and package management tools. The virtual environment section covers multiple environment naming conventions and backup patterns. The IDE and editor section addresses multiple development environments including VSCode, IntelliJ, Vim, and Spyder. The testing and coverage section handles pytest, coverage, tox, and hypothesis artifacts. The OS-specific section covers macOS, Windows, and Linux system files. The development tools section includes patterns for type checkers, linters, and documentation generators. The MCP server section addresses runtime logs and debug files specific to the framework implementation.

###### Architecture & Design

The architecture implements a hierarchical exclusion pattern system with selective preservation through Git negation rules, following comprehensive coverage principles for Python development ecosystems and specialized knowledge management requirements. The design emphasizes selective knowledge base management preserving documentation while excluding content files, comprehensive Python ecosystem support covering build tools, package managers, and testing frameworks, and multi-environment compatibility addressing different operating systems and development setups. Key design patterns include the selective exclusion pattern using directory wildcards followed by specific file preservation, comprehensive coverage pattern addressing all major Python development tools and workflows, hierarchical organization pattern grouping related exclusions by functional category, negation pattern using `!` prefix for selective file preservation within excluded directories, and environment isolation pattern preventing virtual environment and configuration file tracking. The system uses Git's native pattern matching with glob patterns, directory-specific exclusions, and file extension matching for comprehensive coverage.

####### Implementation Approach

The implementation uses Git ignore pattern syntax with glob matching for flexible file and directory exclusion including wildcard patterns `*`, directory patterns with trailing slashes, and file extension patterns. Selective preservation employs negation patterns with `!` prefix to preserve specific files within excluded directories. The approach implements comprehensive Python ecosystem coverage through specific patterns for build tools, package managers, virtual environments, and testing frameworks. Knowledge management uses directory-level exclusion with file-level preservation for `.knowledge/` subdirectories. Multi-environment support addresses different operating systems, IDEs, and development tools through specific pattern collections. Pattern organization follows logical grouping with descriptive comments for maintainability. File extension matching uses bracket notation for multiple extensions and wildcard patterns for flexible matching.

######## External Dependencies & Integration Points

**→ References:**
- `Git` version control system - consuming ignore patterns for repository file exclusion and tracking decisions
- `.knowledge/git-clones/` - knowledge management directory structure requiring selective content exclusion
- `.knowledge/pdf-knowledge/` - PDF document storage requiring binary file exclusion with metadata preservation
- Python build tools - generating artifacts matched by `build/`, `dist/`, `*.egg-info/` patterns
- Virtual environment tools - creating environments matched by `.venv`, `env/`, `venv/` patterns
- IDE and editor systems - generating configuration files matched by `.vscode/`, `.idea/`, `*.swp` patterns
- Testing frameworks - producing artifacts matched by `.pytest_cache/`, `.coverage`, `htmlcov/` patterns

**← Referenced By:**
- Git version control operations - using patterns for `git add`, `git status`, and `git commit` file filtering
- Development workflows - relying on exclusions for clean repository state and build artifact management
- CI/CD pipelines - depending on ignore patterns for consistent build environments and artifact handling
- Knowledge management systems - using selective exclusion for content privacy while preserving structure
- MCP server runtime - generating log files excluded by `mcp-server.log`, `server.log` patterns

**⚡ System role and ecosystem integration:**
- **System Role**: Version control configuration for Jesse Framework MCP Server ecosystem, defining comprehensive file exclusion rules for clean repository management and selective knowledge base preservation
- **Ecosystem Position**: Core development infrastructure component ensuring repository cleanliness, protecting sensitive content, and maintaining development workflow efficiency across multiple environments and tools
- **Integration Pattern**: Used by Git version control system for automatic file filtering, consumed by development tools for consistent environment setup, integrated with knowledge management workflows for content privacy, and coordinated with build systems for artifact exclusion

######### Edge Cases & Error Handling

The system handles nested directory structures through recursive wildcard patterns preventing deep directory exclusion issues. Conflicting patterns are managed through Git's precedence rules where more specific patterns override general ones. File extension variations are addressed through bracket notation and multiple pattern entries for comprehensive coverage. Cross-platform compatibility issues are handled through multiple OS-specific pattern entries addressing different system file conventions. Knowledge base content protection uses directory-level exclusion with explicit file preservation preventing accidental content exposure. Build artifact conflicts are managed through comprehensive pattern coverage addressing multiple build tools and package managers. Virtual environment naming variations are covered through multiple pattern entries addressing different naming conventions. IDE-specific file conflicts are handled through comprehensive editor pattern coverage preventing configuration file tracking.

########## Internal Implementation Details

The file uses Git ignore syntax with hash comments for section organization and pattern documentation. Knowledge management patterns employ directory exclusion with trailing slashes followed by negation patterns for specific file preservation. Python patterns use file extension matching with bracket notation for bytecode variants and wildcard patterns for build artifacts. Virtual environment patterns address multiple naming conventions including hidden directories and backup suffixes. IDE patterns cover configuration directories and temporary files across multiple development environments. Testing patterns address artifact directories and coverage files from multiple testing frameworks. OS patterns use specific file names and extensions for system-generated files. MCP server patterns target specific log file names generated during runtime operations. Pattern ordering follows logical grouping with related exclusions clustered together for maintainability.

########### Usage Examples

Knowledge management selective exclusion demonstrates the core pattern for preserving documentation while excluding content files. This approach enables version control of knowledge base structure without tracking sensitive or large binary content.

```gitignore
# Selective knowledge base management preserving structure while excluding content
# Enables documentation tracking without exposing sensitive or large binary files
.knowledge/git-clones/*/
!.knowledge/git-clones/*.md
!.knowledge/git-clones/README.md

.knowledge/pdf-knowledge/*.pdf
!.knowledge/pdf-knowledge/*.md
!.knowledge/pdf-knowledge/README.md
```

Python development environment exclusion showcases comprehensive coverage for build artifacts and virtual environments. This pattern ensures clean repository state across different Python development workflows and tools.

```gitignore
# Comprehensive Python development artifact exclusion for clean repository management
# Covers build tools, package managers, virtual environments, and testing frameworks
__pycache__/
*.py[cod]
build/
dist/
*.egg-info/
.venv
env/
venv/
.pytest_cache/
.coverage
```

### {PROJECT_ROOT}/jesse-framework-mcp/pyproject.toml

*Last Updated: 2025-07-06T23:20:06Z*

#### Functional Intent & Features

This file serves as the Python package configuration for the Jesse Framework MCP Server, defining build system requirements, dependencies, and metadata for distributing the complete JESSE AI Framework rules and workflows as an MCP-compatible server package. The configuration enables build-time embedding of JESSE framework content from the `artifacts/` directory through custom build hooks, providing a self-contained MCP server distribution with integrated framework governance. Key semantic entities include `hatchling` build system with `hatch-vcs` version control integration, `fastmcp~=2.9.2` as the primary MCP protocol implementation, `jesse-framework-mcp` package name with version `0.1.0`, `build_scripts/copy_jesse_content.py` custom build hook for content embedding, `jesse_framework_mcp/embedded_content/` directory for framework rules and workflows, `boto3>=1.38.46` for AWS service integration, `strands-agents>=0.1.0` for agent framework support, `mistletoe>=1.4.0` for markdown processing, `PyYAML>=6.0` for YAML output generation, `requires-python = ">=3.10"` compatibility requirement, and comprehensive development tooling configuration including `pytest`, `black`, `isort`, `flake8`, and `mypy` for code quality assurance.

##### Main Components

The configuration contains eight primary sections defining package structure and build behavior: `build-system` section specifying `hatchling` and `hatch-vcs` requirements, `project` section with package metadata including name, version, description, authors, and dependencies, `project.urls` section providing repository and documentation links, `project.scripts` section defining the `jesse-framework-mcp` command-line entry point, `tool.hatch.build.hooks.custom` section configuring the build-time content copying hook, `tool.hatch.build.targets.wheel.shared-data` section for embedded content distribution, `project.optional-dependencies` section with development tools, and comprehensive tool configuration sections for `black`, `isort`, `mypy`, and `pytest`. Supporting components include `tool.setuptools.package-data` for setuptools compatibility, `dependency-groups` for modern dependency management, and detailed Python version classifiers supporting 3.10, 3.11, and 3.12.

###### Architecture & Design

The architecture implements a build-time content embedding pattern using `hatchling` build system with custom hooks to integrate JESSE framework rules and workflows into the Python package distribution. The design employs a modular dependency structure with `fastmcp` as the core MCP protocol implementation, supplemented by specialized libraries for AWS integration, agent frameworks, markdown processing, and YAML generation. The system uses shared data distribution through wheel packaging to include embedded content in the final package, ensuring framework rules and workflows are available at runtime without external dependencies. The architectural pattern includes comprehensive development tooling integration with code formatting, linting, type checking, and testing frameworks configured for Python 3.10+ compatibility.

####### Implementation Approach

The implementation uses `hatchling` build backend with custom build hooks executing `build_scripts/copy_jesse_content.py` to embed JESSE framework content during package creation. The approach employs version pinning strategies with compatible version ranges (`~=2.9.2` for FastMCP, `>=1.38.46` for boto3) ensuring stable dependency resolution while allowing patch updates. Package data inclusion uses both modern `tool.hatch.build.targets.wheel.shared-data` configuration and legacy `tool.setuptools.package-data` for broad compatibility. Development workflow integration implements standardized tooling with `black` for code formatting, `isort` for import organization, `mypy` for type checking, and `pytest` for testing with asyncio support. The build process coordinates content copying, dependency resolution, and package assembly to produce a self-contained MCP server distribution.

######## External Dependencies & Integration Points

**→ References:**
- `hatchling` (external library) - modern Python build backend providing package creation and distribution capabilities
- `hatch-vcs` (external library) - version control integration for automatic version management from Git tags
- `fastmcp~=2.9.2` (external library) - FastMCP framework implementing MCP protocol for server functionality
- `boto3>=1.38.46` (external library) - AWS SDK for Python enabling cloud service integration
- `strands-agents>=0.1.0` (external library) - agent framework for AI assistant coordination and management
- `mistletoe>=1.4.0` (external library) - markdown parser and renderer for processing framework documentation
- `PyYAML>=6.0` (external library) - YAML processing library for configuration and data serialization
- `build_scripts/copy_jesse_content.py` - custom build hook script for embedding JESSE framework content

**← Referenced By:**
- Python package installers - `pip`, `poetry`, `conda` consume this configuration for package installation and dependency resolution
- CI/CD build systems - automated build pipelines reference this configuration for package creation and distribution
- Development environments - IDEs and development tools use tool configurations for code formatting and quality checks
- Package distribution platforms - PyPI and other repositories use metadata for package indexing and discovery
- MCP client applications - consume the built package as an MCP server providing JESSE framework functionality
- Docker containers and deployment systems - reference package configuration for containerized deployments

**⚡ System role and ecosystem integration:**
- **System Role**: Central package configuration defining the complete build, distribution, and runtime requirements for the Jesse Framework MCP Server, enabling seamless integration of JESSE framework rules with MCP protocol implementation
- **Ecosystem Position**: Core infrastructure component that bridges JESSE framework content with Python packaging ecosystem, ensuring framework rules and workflows are distributed as a standard Python package with MCP server capabilities
- **Integration Pattern**: Consumed by Python build tools for package creation, referenced by dependency managers for installation, and used by development tools for code quality assurance while coordinating build-time content embedding with runtime MCP server functionality

######### Edge Cases & Error Handling

The configuration addresses Python version compatibility issues through explicit `requires-python = ">=3.10"` specification ensuring FastMCP v2.9.2 compatibility requirements are met. Build hook failures are mitigated through the custom `copy_jesse_content.py` script which handles missing source content and provides error reporting during package creation. Dependency resolution conflicts are managed through version pinning strategies using compatible version specifiers (`~=` for patch-level updates, `>=` for minimum versions) preventing incompatible library combinations. Development tool configuration includes error handling through `mypy` type checking with `warn_return_any` and `disallow_untyped_defs` flags catching type-related issues. The system handles package data inclusion failures through dual configuration using both modern hatchling and legacy setuptools specifications ensuring broad compatibility across different installation environments.

########## Internal Implementation Details

The build system uses `hatchling.build` backend with custom hook integration executing during package creation to embed JESSE framework content from the `artifacts/` directory into `jesse_framework_mcp/embedded_content/`. Dependency management employs semantic versioning with `fastmcp~=2.9.2` allowing patch updates while preventing minor version changes that could introduce breaking changes. Package data configuration uses `tool.hatch.build.targets.wheel.shared-data` mapping `embedded_content` to the package directory structure ensuring framework rules and workflows are included in wheel distributions. Development tooling configuration implements standardized settings with `black` line length of 88 characters, `isort` black profile compatibility, `mypy` strict type checking for Python 3.10, and `pytest` asyncio mode for testing MCP server functionality. The entry point configuration maps `jesse-framework-mcp` command to `jesse_framework_mcp:main` function enabling command-line server execution.

########### Code Usage Examples

This example demonstrates the package installation and basic usage pattern for the Jesse Framework MCP Server. The installation process includes all embedded JESSE framework content through the build-time copying mechanism.

```bash
# Install the Jesse Framework MCP Server package with all dependencies
pip install jesse-framework-mcp

# Run the MCP server with stdio transport for client communication
jesse-framework-mcp
```

This example shows the development environment setup using the optional development dependencies. The configuration enables comprehensive code quality checking and testing capabilities for framework development.

```bash
# Install development dependencies for contributing to the framework
pip install jesse-framework-mcp[dev]

# Run code quality checks using configured tools
black --check .
isort --check-only .
flake8 .
mypy .
pytest
```

This example illustrates the build process configuration showing how JESSE framework content is embedded during package creation. The custom build hook ensures framework rules and workflows are included in the distribution.

```toml
# Build system configuration with custom content embedding
[tool.hatch.build.hooks.custom]
path = "build_scripts/copy_jesse_content.py"

# Embedded content distribution in wheel packages
[tool.hatch.build.targets.wheel.shared-data]
"embedded_content" = "jesse_framework_mcp/embedded_content"
```

### {PROJECT_ROOT}/jesse-framework-mcp/README.md

*Last Updated: 2025-07-06T23:20:06Z*

#### Functional Intent & Features

This file implements comprehensive documentation for the Jesse Framework MCP Server, providing complete installation, configuration, and usage guidance for developers integrating the JESSE AI Framework through Model Context Protocol implementation. The documentation enables developers to replace manual 6-step session setup with single MCP tool calls while understanding build-time content embedding, project knowledge integration, and lazy loading capabilities. Key semantic entities include core MCP tools `jesse_start_session` and `jesse_load_knowledge_base` for framework initialization and knowledge base loading, installation methods using `uv` package manager and `pip` for distribution, configuration patterns for `Cline` MCP integration with `mcpServers` JSON configuration, directory structures `.knowledge/git-clones/`, `.knowledge/pdf-knowledge/`, `.knowledge/work-in-progress/` for project knowledge organization, build process components `artifacts/.clinerules/` source directory and `embedded_content/` destination, command-line interface `jesse-framework-mcp` for direct execution, session logging format with `.coding_assistant/jesse/session.log` file path, troubleshooting scenarios for build and runtime issues, development workflow commands `uv build`, `uv sync --dev`, `pytest`, `black`, `isort`, and `mypy` for code quality, and architectural patterns including build-time embedding, session initialization flow, and knowledge base discovery mechanisms. The system implements self-contained distribution with version-locked JESSE rules and portable execution across project directories.

##### Main Components

The documentation contains eleven primary sections providing comprehensive coverage of installation, usage, architecture, development, and troubleshooting for the Jesse Framework MCP Server. The Overview section establishes core functionality including complete session initialization, embedded framework content, and project knowledge integration. The Features section details core tools `jesse_start_session` and `jesse_load_knowledge_base` with self-contained distribution capabilities. The Installation section covers prerequisites, PyPI installation, and source installation methods. The Usage section provides Cline integration configuration, direct usage commands, and tool usage examples. The Architecture section explains build-time content embedding, session initialization flow, and knowledge base structure. The Development section covers building from source, testing procedures, and development dependencies. The Configuration section details session logging and knowledge base discovery mechanisms. The Troubleshooting section addresses build issues, runtime issues, and logging problems. The License, Contributing, and Support sections provide project governance and community information.

###### Architecture & Design

The architecture implements a comprehensive documentation structure with clear separation between user-facing functionality and technical implementation details, following standard open-source project documentation patterns with installation, usage, development, and troubleshooting sections. The design emphasizes practical guidance through concrete examples, step-by-step procedures, and troubleshooting scenarios while maintaining technical accuracy and completeness. Key design patterns include the progressive disclosure pattern starting with overview and features before diving into technical details, example-driven documentation pattern providing concrete code snippets and configuration examples, troubleshooting pattern addressing common issues with specific solutions, architectural explanation pattern using diagrams and flow descriptions for complex processes, and comprehensive coverage pattern addressing all aspects from installation to contribution guidelines. The system uses standard Markdown formatting with code blocks, JSON configurations, directory trees, and structured sections for maximum readability and accessibility.

####### Implementation Approach

The implementation uses structured Markdown documentation with hierarchical organization through header levels, code block formatting for examples and configurations, and comprehensive cross-referencing between related sections. Content organization follows logical user journey from installation through usage to development and troubleshooting. The approach implements concrete examples with actual command lines, configuration files, and directory structures rather than abstract descriptions. Technical concepts are explained through architectural diagrams using ASCII art and step-by-step process flows. Error scenarios include specific error messages with corresponding solutions and explanations. Development guidance provides complete workflow from building to testing with specific tool commands and dependencies. Installation instructions cover multiple package managers and deployment scenarios with platform-specific considerations.

######## External Dependencies & Integration Points

**→ References:**
- `Python 3.8+` runtime environment - required for MCP server execution and package installation
- `uv` package manager - recommended installation and development tool for dependency management
- `pip` package manager - alternative installation method for broader compatibility
- `Cline` AI assistant - primary integration target consuming MCP server through stdio transport
- `PyPI` package repository - distribution platform for jesse-framework-mcp package
- `Git` version control - source code management and repository cloning for development
- `artifacts/.clinerules/` directory - source location for JESSE framework content during build process
- `.knowledge/` directory structure - project-specific knowledge base organization and discovery

**← Referenced By:**
- Developer installation workflows - using documentation for package setup and configuration
- Cline MCP configuration - consuming JSON configuration examples for server integration
- Build systems - referencing build process documentation for content embedding procedures
- Troubleshooting workflows - using error scenarios and solutions for issue resolution
- Development teams - following contribution guidelines and development setup procedures
- Package managers - distributing through PyPI with installation instructions and dependencies

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive documentation hub for Jesse Framework MCP Server ecosystem, providing authoritative guidance for installation, configuration, usage, and development workflows
- **Ecosystem Position**: Central reference point serving developers, integrators, and contributors with complete project information from basic usage to advanced development scenarios
- **Integration Pattern**: Used by developers for initial setup and ongoing reference, consumed by AI assistants through MCP protocol integration, referenced by build systems for content embedding procedures, and coordinated with package distribution platforms for installation and dependency management

######### Edge Cases & Error Handling

The documentation addresses build-time issues including missing JESSE project hierarchy with specific error messages and resolution steps. Installation problems are covered through multiple package manager options and troubleshooting for dependency conflicts. Runtime errors include embedded content loading failures with rebuild recommendations and knowledge base discovery issues with file path verification. Configuration problems address MCP server integration with Cline including transport protocol setup and command execution paths. Development environment issues cover build script testing, dependency installation, and code quality tool execution. Session logging failures are documented as non-blocking with permission-based solutions. Cross-platform compatibility considerations address different operating system requirements and path handling. Version compatibility issues between JESSE framework versions and MCP server releases are addressed through version-locking mechanisms and rebuild procedures.

########## Internal Implementation Details

The documentation uses standard Markdown syntax with consistent header hierarchy, code block formatting with language identifiers, and structured section organization. Installation procedures specify exact command sequences with package manager alternatives and environment setup requirements. Configuration examples provide complete JSON structures with proper syntax and required fields. Architectural explanations use ASCII art diagrams for build processes and directory structures with clear input-output relationships. Development workflows specify exact tool commands with dependency management and testing procedures. Error messages are quoted verbatim with corresponding solution steps and verification procedures. File path specifications use consistent notation with directory trailing slashes and relative path conventions. Code examples include both command-line usage and programmatic API calls with proper syntax highlighting and context explanations.

########### Usage Examples

MCP server installation demonstrates the primary setup workflow for developers integrating the Jesse Framework. This approach provides multiple installation methods with package manager flexibility and environment compatibility.

```bash
# Primary installation method using UV package manager for optimal dependency management
# Provides fastest installation with automatic virtual environment handling
uv add jesse-framework-mcp

# Alternative installation using pip for broader compatibility across development environments
# Supports traditional Python package installation workflows
pip install jesse-framework-mcp
```

Cline integration configuration showcases the MCP server setup pattern for AI assistant integration. This configuration enables seamless JESSE framework access through standardized MCP protocol communication.

```json
# Cline MCP server configuration for Jesse Framework integration
# Enables AI assistant access to complete JESSE framework through stdio transport
{
  "mcpServers": {
    "jesse-framework": {
      "command": "uv",
      "args": ["run", "jesse-framework-mcp"],
      "transport": "stdio"
    }
  }
}
```

Tool usage examples demonstrate the core MCP functionality for session initialization and knowledge base loading. These patterns enable developers to leverage JESSE framework capabilities through standardized tool calls.

```javascript
// Complete JESSE framework session initialization with project context loading
// Replaces manual 6-step setup with single tool call including WIP task integration
const context = await mcpClient.callTool("jesse_start_session", {
    user_prompt: "Help me implement authentication",
    load_wip_tasks: true
});

// Selective knowledge base loading for efficient context window management
// Enables targeted knowledge access based on task relevance and LLM selection
const kbContent = await mcpClient.callTool("jesse_load_knowledge_base", {
    kb_names: ["fastapi_kb", "aws_cdk_kb"]
});
```

### {PROJECT_ROOT}/jesse-framework-mcp/utils.py

*Last Updated: 2025-07-06T23:20:06Z*

#### Functional Intent & Features

This file implements FastMCP function unwrapping utilities for testing and development support, providing direct access to original functions from FastMCP decorated objects without MCP protocol overhead. The module enables developers to extract and validate underlying callable implementations from FastMCP wrapper objects for testing, debugging, and development workflows. Key semantic entities include primary function `unwrap_fastmcp_function()` for extracting original functions from decorated objects, helper functions `_is_fastmcp_wrapper()` and `_try_class_specific_extraction()` for wrapper detection and class-specific extraction patterns, metadata function `get_function_metadata()` for comprehensive function analysis, validation function `validate_fastmcp_function()` for FastMCP compatibility checking, imported modules `inspect` for function signature validation, `typing` for type hints and annotations, and `functools` for function metadata preservation, FastMCP wrapper types including `FunctionResource`, `FunctionTool`, and `FunctionPrompt`, function attribute patterns `fn`, `_func`, `__wrapped__`, `func`, `_function`, `handler`, `_handler`, `callback`, `_callback`, and `read` for extraction, exception types `TypeError`, `AttributeError`, and `ValueError` for comprehensive error handling, and validation parameters including `expected_context_param` for Context parameter checking. The system implements defensive programming with comprehensive error handling and descriptive messages while supporting all FastMCP decorator types with type safety and fallback mechanisms.

##### Main Components

The file contains four primary functions and two helper functions providing comprehensive FastMCP function unwrapping and validation capabilities. The `unwrap_fastmcp_function()` function serves as the main entry point for extracting original functions from FastMCP decorated objects with multi-pattern support. The `get_function_metadata()` function extracts comprehensive metadata from functions for debugging and validation including signature, docstring, and module information. The `validate_fastmcp_function()` function validates functions against FastMCP requirements checking async patterns, Context parameters, and documentation standards. Helper functions include `_is_fastmcp_wrapper()` for detecting FastMCP wrapper types based on class name patterns and attributes, and `_try_class_specific_extraction()` for attempting class-specific function extraction patterns for different FastMCP wrapper types. The module provides comprehensive support for `FunctionResource`, `FunctionTool`, and `FunctionPrompt` wrapper types with fallback mechanisms for unknown wrapper patterns.

###### Architecture & Design

The architecture implements a multi-pattern extraction system with defensive programming principles, following clean separation between MCP protocol handling and direct function access with comprehensive error handling and type safety validation. The design emphasizes support for all FastMCP decorator types through attribute inspection and class-specific extraction patterns, robust wrapper detection using multiple heuristics, and comprehensive validation with clear guidance for fixing issues. Key design patterns include the extraction pattern with multiple attribute attempts for different FastMCP wrapper storage mechanisms, validation pattern providing detailed compatibility checking with specific recommendations, helper pattern separating wrapper detection and class-specific extraction logic, metadata pattern extracting comprehensive function information for analysis, and fallback pattern providing graceful degradation for unknown wrapper types. The system uses composition over inheritance with specialized functions for different aspects, comprehensive error handling with descriptive messages, and type safety with proper validation throughout the extraction process.

####### Implementation Approach

The implementation uses attribute inspection algorithms with systematic attempts through predefined function attribute lists including `fn`, `_func`, `__wrapped__`, `func`, `_function`, `handler`, `_handler`, `callback`, `_callback`, and `read` for comprehensive extraction coverage. Wrapper detection employs class name pattern matching for FastMCP types and attribute presence checking for common wrapper characteristics. The approach implements class-specific extraction patterns for `Resource`, `Tool`, and `Prompt` wrapper types with dedicated attribute attempts for each category. Function validation uses `inspect.signature()` for parameter analysis and `inspect.iscoroutinefunction()` for async pattern verification. Error handling employs specific exception types with detailed error messages including available attributes and extraction methods for debugging support. Metadata extraction combines `inspect` module functions for signature, documentation, and source information with safe fallbacks for missing attributes. Type safety validation ensures extracted objects are callable with proper signature patterns before returning results.

######## External Dependencies & Integration Points

**→ Inbound:**
- `inspect` (external library) - function signature validation, metadata extraction, and source code analysis for comprehensive function introspection
- `typing` (external library) - type hints and annotations including Any, Callable, Union for comprehensive type safety
- `functools` (external library) - function metadata preservation and wrapper utilities for maintaining function characteristics

**← Outbound:**
- FastMCP resource handlers - consuming `unwrap_fastmcp_function()` for direct function access during testing and development workflows
- Testing frameworks - using extracted functions for unit testing without MCP protocol overhead
- Development tools - accessing function metadata and validation results for debugging and analysis
- Session initialization systems - using function unwrapping for direct function invocation and compatibility checking
- Resource validation systems - consuming validation functions for FastMCP compliance verification

**⚡ System role and ecosystem integration:**
- **System Role**: Development and testing utility for Jesse Framework MCP Server ecosystem, providing direct access to underlying function implementations from FastMCP decorated objects for testing, debugging, and development workflows
- **Ecosystem Position**: Support utility serving development and testing needs, enabling direct function access without MCP protocol complexity while maintaining compatibility with all FastMCP decorator patterns
- **Integration Pattern**: Used by developers for testing FastMCP resources directly, consumed by testing frameworks for unit test execution, integrated with development workflows for function analysis and validation, and coordinated with FastMCP decorators for seamless function extraction across different wrapper types

######### Edge Cases & Error Handling

The system handles unknown FastMCP wrapper types through comprehensive attribute inspection with fallback to class-specific extraction patterns when standard attributes unavailable. Missing function attributes are managed through systematic attempts across multiple attribute names with descriptive error messages listing available attributes for debugging. Non-callable extracted objects trigger `TypeError` exceptions with specific object type information and extraction method context. Invalid function signatures are handled through `inspect.signature()` validation with warnings for functions lacking Context parameters. Wrapper detection edge cases include objects with partial FastMCP characteristics handled through conservative detection heuristics. Function metadata extraction manages missing attributes through safe fallbacks preventing extraction failures. Signature inspection failures are handled gracefully with continued execution and warning messages rather than complete failure. Class-specific extraction handles unknown class types through pattern matching with graceful None returns for unsupported wrapper types.

########## Internal Implementation Details

The module uses systematic attribute inspection with predefined lists including primary `fn` attribute for FastMCP FunctionResource objects and fallback attributes for various wrapper patterns. Wrapper detection implements class name pattern matching for `FunctionResource`, `FunctionTool`, `FunctionPrompt`, `Resource`, `Tool`, and `Prompt` patterns with attribute presence checking for `_func`, `__wrapped__`, `func`, and `_function`. Class-specific extraction employs dedicated patterns for Resource, Tool, and Prompt wrapper types with specific attribute attempts including `_func`, `handler`, `_handler`, and `callback` for each category. Function validation uses `inspect.iscoroutinefunction()` for async requirement checking and parameter analysis for Context parameter validation. Metadata extraction combines `inspect.signature()`, `inspect.getdoc()`, `inspect.getfile()`, and `inspect.getsourcelines()` with exception handling for unavailable information. Error messages include specific wrapper types, available attributes, and extraction methods for comprehensive debugging support. Type safety validation ensures callable objects with proper signatures before function return.

########### Code Usage Examples

FastMCP function unwrapping demonstrates the primary usage pattern for extracting original functions from decorated objects for direct testing. This approach enables developers to test FastMCP resources without MCP protocol overhead while maintaining full function access.

```python
# Extract original function from FastMCP decorated resource for direct testing
# Enables testing without MCP protocol complexity while preserving function behavior
from utils import unwrap_fastmcp_function

# Unwrap FastMCP resource to access underlying function
original_function = unwrap_fastmcp_function(decorated_resource)
# Direct function invocation for testing with Context parameter
result = await original_function(context, *args, **kwargs)
```

Function validation showcases the FastMCP compatibility checking pattern for ensuring proper function structure. This pattern provides comprehensive validation with specific recommendations for fixing compatibility issues.

```python
# Validate function compatibility with FastMCP requirements and get detailed feedback
# Provides comprehensive validation results with specific recommendations for fixes
from utils import validate_fastmcp_function, get_function_metadata

# Validate FastMCP function requirements
validation_result = validate_fastmcp_function(function, expected_context_param="ctx")
if not validation_result['is_valid']:
    print("Validation issues:", validation_result['issues'])
    print("Recommendations:", validation_result['recommendations'])

# Extract comprehensive function metadata for analysis
metadata = get_function_metadata(function)
print(f"Function: {metadata['name']}, Parameters: {metadata['parameters']}")
```

### {PROJECT_ROOT}/jesse-framework-mcp/uv.lock

*Last Updated: 2025-07-06T23:20:06Z*

#### Functional Intent & Features

This file serves as the dependency lock file for the Jesse Framework MCP Server project, providing deterministic package resolution and version pinning for all direct and transitive dependencies across the Python ecosystem. The lock file ensures reproducible builds and consistent development environments by specifying exact versions, checksums, and source locations for every package required by the project. Key semantic entities include `uv.lock` format with `version = 1` and `revision = 1` metadata, `requires-python = ">=3.10"` compatibility specification, `jesse-framework-mcp` as the main package with `version = "0.1.0"` and `source = { editable = "." }` configuration, comprehensive dependency graph including `fastmcp~=2.9.2` for MCP protocol implementation, `boto3>=1.38.46` for AWS integration, `strands-agents>=0.1.0` for agent framework support, `mistletoe>=1.4.0` for markdown processing, `PyYAML>=6.0` for YAML handling, development dependencies including `pytest>=8.4.1`, `black>=25.1.0`, `mypy>=1.16.1`, and `flake8>=7.3.0`, with detailed package metadata containing SHA256 hashes, wheel URLs, and source distribution information ensuring cryptographic verification and supply chain security for all dependencies.

##### Main Components

The lock file contains 77 distinct package entries organized into a flat dependency structure with comprehensive metadata for each package. Primary components include the main project package `jesse-framework-mcp` with editable source configuration and optional development dependencies, core runtime dependencies such as `fastmcp`, `boto3`, `strands-agents`, `mistletoe`, and `pyyaml`, development tooling packages including `pytest`, `pytest-asyncio`, `black`, `isort`, `flake8`, and `mypy`, and extensive transitive dependencies covering cryptography (`cryptography`, `cffi`), HTTP clients (`httpx`, `httpcore`, `h11`), async frameworks (`anyio`, `starlette`, `uvicorn`), data validation (`pydantic`, `pydantic-core`), and utility libraries (`click`, `rich`, `typer`). Each package entry includes version specifications, source registry information, dependency relationships, and cryptographic verification data through SHA256 hashes for both source distributions and wheel files.

###### Architecture & Design

The architecture implements a comprehensive dependency resolution system using the `uv` package manager format with deterministic version locking and cryptographic verification. The design employs a flat package structure where each dependency is explicitly listed with complete metadata including version constraints, source locations, and integrity checksums. The system uses semantic versioning with compatible version ranges (`~=` for patch-level updates, `>=` for minimum versions) while locking to specific versions for reproducibility. The architectural pattern includes conditional dependencies based on Python version markers (`python_full_version < '3.11'`, `python_full_version < '3.13'`) and platform-specific markers (`sys_platform == 'win32'`, `platform_python_implementation != 'PyPy'`), comprehensive wheel distribution support across multiple platforms (macOS, Linux, Windows) and architectures (x86_64, ARM64, i686), and development dependency separation through optional dependency groups enabling different installation profiles.

####### Implementation Approach

The implementation uses the `uv` lock file format version 1 with revision 1, providing structured dependency resolution with exact version pinning and cryptographic verification through SHA256 hashes. The approach employs comprehensive package metadata including source registry URLs (`https://pypi.org/simple`), wheel and source distribution URLs with integrity hashes, and dependency relationship mapping with conditional markers. Version resolution implements semantic versioning constraints while locking to specific versions ensuring reproducible builds across different environments. The system handles platform-specific dependencies through conditional markers, supports both wheel and source distribution installations, and maintains separate dependency groups for development and runtime requirements. Package verification uses SHA256 checksums for both wheel files and source distributions, ensuring supply chain security and preventing dependency tampering.

######## External Dependencies & Integration Points

**→ References:**
- `https://pypi.org/simple` - primary package index registry for all external dependencies and package resolution
- `https://files.pythonhosted.org/packages/` - CDN hosting wheel and source distribution files with SHA256 verification
- `fastmcp~=2.9.2` (external library) - FastMCP framework for MCP protocol implementation and server functionality
- `boto3>=1.38.46` (external library) - AWS SDK for Python enabling cloud service integration and API access
- `strands-agents>=0.1.0` (external library) - agent framework for AI assistant coordination and management capabilities
- `mistletoe>=1.4.0` (external library) - markdown parser and renderer for processing framework documentation
- `PyYAML>=6.0` (external library) - YAML processing library for configuration and data serialization operations

**← Referenced By:**
- `uv` package manager - consumes lock file for deterministic dependency resolution and installation operations
- CI/CD build systems - reference lock file for consistent dependency installation across build environments
- Development environments - use lock file to ensure consistent package versions across team members
- Docker containers - leverage lock file for reproducible container builds with exact dependency versions
- Package distribution systems - reference dependency specifications for package metadata and requirements
- Security scanning tools - analyze lock file for vulnerability detection and dependency audit procedures

**⚡ System role and ecosystem integration:**
- **System Role**: Central dependency management artifact for the Jesse Framework MCP Server, ensuring deterministic package resolution and reproducible builds across all deployment environments
- **Ecosystem Position**: Critical infrastructure component that defines the complete dependency graph for the project, enabling consistent development, testing, and production deployments
- **Integration Pattern**: Consumed by package managers for installation, referenced by CI/CD systems for build reproducibility, and used by security tools for vulnerability scanning while maintaining cryptographic verification of all dependencies through SHA256 checksums

######### Edge Cases & Error Handling

The lock file addresses dependency resolution conflicts through exact version pinning and comprehensive constraint satisfaction across the entire dependency graph. Platform compatibility issues are handled through conditional dependency markers and multiple wheel distributions supporting different operating systems and architectures. Python version compatibility constraints prevent installation on unsupported Python versions through `requires-python = ">=3.10"` specification. Package integrity failures are detected through SHA256 hash verification for both wheel and source distributions. The system handles missing optional dependencies through conditional markers and graceful degradation patterns. Network connectivity issues during package installation are mitigated through multiple mirror support and cached wheel distributions. Version constraint conflicts are resolved through the lock file's deterministic resolution ensuring all transitive dependencies are compatible.

########## Internal Implementation Details

The lock file format uses TOML syntax with structured package entries containing comprehensive metadata including version specifications, source registry information, dependency relationships, and cryptographic verification data. Each package entry includes `name`, `version`, `source` registry information, `dependencies` array with conditional markers, `sdist` source distribution metadata with URL and SHA256 hash, and `wheels` array containing platform-specific wheel files with URLs and integrity checksums. Dependency resolution implements constraint satisfaction algorithms ensuring all version requirements are met across the entire dependency graph. Platform-specific handling uses conditional markers like `python_full_version < '3.11'` and `sys_platform == 'win32'` for targeted dependency inclusion. The system maintains separate dependency groups through `optional-dependencies` and `dev-dependencies` sections enabling different installation profiles for development and production environments.

########### Code Usage Examples

This example demonstrates installing dependencies using the lock file for reproducible development environment setup. The lock file ensures exact versions are installed matching the project's tested configuration.

```bash
# Install dependencies using uv with lock file for exact version matching
uv sync
# Installs all dependencies with exact versions specified in uv.lock
```

This example shows how to install only production dependencies excluding development tools. The lock file supports selective installation based on dependency groups and optional requirements.

```bash
# Install production dependencies only using lock file specifications
uv sync --no-dev
# Excludes development dependencies like pytest, black, mypy from installation
```

This example illustrates adding a new dependency while maintaining lock file integrity. The lock file must be updated to include new dependencies with proper version resolution and hash verification.

```bash
# Add new dependency and update lock file with resolved versions
uv add requests
uv lock
# Updates uv.lock with new dependency and all transitive requirements
```

---
*Generated: 2025-07-06T23:20:06Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp*
*Total Files: 5*
*Total Subdirectories: 3*

# End of jesse-framework-mcp_kb.md