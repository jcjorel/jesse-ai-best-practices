<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/

## Global Summary

#### Functional Intent & Features

This directory implements the core Jesse Framework MCP Server, providing comprehensive AI-assisted development capabilities through `FastMCP` protocol compliance with resource-first architecture, embedded content delivery, and intelligent knowledge base management for modern development workflows. The system enables MCP clients to access framework rules, project contexts, workflows, and knowledge bases through standardized resource endpoints while supporting both granular individual access and consolidated meta-resource delivery for efficient AI assistant integration. Key semantic entities include `FastMCP` server instance with `server = FastMCP("JESSE Framework")`, primary resource handlers `framework_index()`, `jesse_framework_start_prompt()`, `jesse_wip_task_create_prompt()`, and `jesse_knowledge_capture_prompt()`, centralized constants `JESSE_RULE_FILES`, `HTTP_BOUNDARY_MARKER`, and `DEFAULT_CRITICALITY`, comprehensive helper utilities through `content_loaders`, `session_management`, `knowledge_scanners`, `path_utils`, `async_http_formatter`, and `mistletoe_spacing` modules, knowledge base system with `HierarchicalIndexer`, `KnowledgeBuilder`, `FileAnalysisCache`, and `RebuildDecisionEngine`, LLM integration via `StrandsClaude4Driver` and `Claude4SonnetConfig`, resource endpoints including `jesse://index`, `jesse://framework/rule/{rule_name}`, `jesse://session/init-context`, `jesse://project/knowledge`, `jesse://wip-tasks`, and `file://workflows/{workflow_name}`, embedded content access through `JESSE_*.md` rule files and `workflows/` automation definitions, HTTP formatting with `XAsyncContentCriticality.CRITICAL` and `XAsyncContentCriticality.INFORMATIONAL` classifications, portable path variables `{PROJECT_ROOT}`, `{HOME}`, `{CLINE_RULES}`, `{CLINE_WORKFLOWS}`, and comprehensive error handling with graceful degradation ensuring reliable MCP protocol compliance across all framework operations.

##### Main Components

The directory contains three primary implementation files, seven specialized subdirectories, and comprehensive embedded content providing complete MCP server functionality. Core server files include `main.py` implementing the primary `FastMCP` server with resource discovery and prompt handlers, `constants.py` providing centralized configuration constants and HTTP formatting standards, and `__init__.py` serving as package initialization with version metadata and entry point delegation. Specialized subdirectories encompass `knowledge_bases/` implementing hierarchical indexing with Plan-then-Execute architecture, `helpers/` providing modular utility functions for content loading, session management, and HTTP formatting, `llm/` containing Claude 4 Sonnet integration through `strands_agent_driver/` package, `resources/` delivering comprehensive MCP resource handlers with individual and meta-resource patterns, and `embedded_content/` housing framework rules and workflow definitions with programmatic access interfaces. The system includes comprehensive rule files `JESSE_KNOWLEDGE_MANAGEMENT.md`, `JESSE_HINTS.md`, `JESSE_CODE_COMMENTS.md`, `JESSE_CODE_GENERATION.md`, `JESSE_MARKDOWN.md`, and `JESSE_SCRATCHPAD.md` establishing development standards, plus 15 specialized workflow automation files in `workflows/` subdirectory covering task lifecycle management, knowledge capture, and strategic planning processes.

###### Architecture & Design

The architecture implements a modern resource-first MCP server design with `FastMCP` native transport management, following clean separation between transport layer and resource implementations with automatic lifecycle management through `server.run(transport="stdio")`. The design emphasizes modular organization with dedicated subdirectories for different functional domains, comprehensive HTTP formatting through `async_http_formatter` utilities, and embedded content delivery enabling self-contained framework distribution. Key design patterns include the resource-first pattern with individual resource access through dedicated URIs, auto-registration pattern leveraging `FastMCP` decorators for automatic resource handler discovery, meta-resource aggregation pattern combining multiple contexts into unified responses, Plan-then-Execute architecture separating decision-making from execution in knowledge base operations, async context manager pattern for LLM integration with proper resource lifecycle handling, and embedded content access pattern using `importlib.resources` for package-bundled framework rules and workflows. The system uses composition over inheritance with specialized helper modules, centralized configuration through constants, and comprehensive error handling with individual section failure isolation preventing complete resource delivery failures while maintaining MCP protocol compliance.

####### Implementation Approach

The implementation uses `FastMCP` native transport with automatic lifecycle management eliminating manual event loop creation, comprehensive resource discovery through dynamic scanning of available components, and HTTP-formatted content delivery ensuring consistent AI assistant processing. The approach employs async-first patterns throughout with `FastMCP` Context integration for progress reporting, cache-first processing strategies through `FileAnalysisCache` integration avoiding unnecessary LLM calls, and continuation-based retry mechanisms providing 90%+ token savings through intelligent response completion. Knowledge base processing implements Plan-then-Execute architecture with atomic task execution, while LLM integration uses async context managers with `StrandsClaude4Driver` for Claude 4 Sonnet capabilities. Content delivery combines JSON serialization for structured data, markdown formatting for documentation, and HTTP section wrapping with appropriate criticality classifications. The system implements working directory management with project root detection, sequential loading with progress reporting for meta-resource aggregation, and conditional output strategies returning empty responses when compliant for massive context reduction. Error handling employs try-catch blocks with specific exception types, graceful degradation with placeholder content, and comprehensive logging through structured error reporting.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp.FastMCP` (external library) - MCP server framework providing native transport and protocol compliance with automatic lifecycle management
- `fastmcp.Context` (external library) - progress reporting and logging interface for real-time user feedback during operations
- `importlib.resources` (external library) - embedded content access with Python 3.9+ compatibility and fallback support
- `mistletoe` (external library) - AST-based markdown parsing and rendering for document structure manipulation
- `pydantic` (external library) - configuration validation and type safety for hierarchical parameter management
- `strands.Agent` (external library) - Strands Agent SDK for Claude 4 Sonnet interaction and streaming capabilities
- `boto3` (external library) - AWS SDK for Amazon Bedrock service access and authentication
- `pathlib.Path` (external library) - cross-platform filesystem operations throughout the system
- `asyncio` (external library) - async programming patterns for concurrent operations and context management
- `json` (external library) - structured data serialization and configuration management
- `logging` (external library) - structured logging for operations, error tracking, and debugging
- `datetime` (external library) - timestamp generation and processing duration calculations
- AWS environment variables `AWS_REGION`, `AWS_PROFILE`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` - authentication configuration

**← Outbound:**
- MCP clients - consuming framework resources through standardized MCP protocol with resource and prompt endpoints
- Cline AI assistant - accessing comprehensive session context and workflow resources as slash commands
- Development environments - using Jesse Framework resources for AI-assisted development workflows
- AI coding assistants - consuming framework rules with CRITICAL criticality for strict adherence
- Knowledge management systems - processing generated knowledge base files and cached analysis content
- AWS Bedrock service - generating Claude 4 Sonnet API calls and streaming responses
- Generated artifacts including `*.md` knowledge files, `*.analysis.md` cache files, `*.indexing-config.json` configuration files
- Console applications - using main entry point for server startup and lifecycle management

**⚡ System role and ecosystem integration:**
- **System Role**: Complete MCP server implementation for Jesse Framework ecosystem, providing comprehensive AI-assisted development capabilities through FastMCP protocol compliance with resource-first architecture, embedded content delivery, and intelligent knowledge base management
- **Ecosystem Position**: Central infrastructure component serving as primary MCP protocol interface, coordinating all framework resources including rules, workflows, knowledge bases, and LLM integration while providing unified access point for AI assistants and development tools
- **Integration Pattern**: Used by MCP clients through stdio transport for resource and prompt access, consumed by AI assistants for framework initialization and workflow guidance, integrated with AWS Bedrock for LLM capabilities, coordinated with development tools through standardized MCP protocol, and deployed as self-contained package with embedded content enabling framework distribution without external dependencies

######### Edge Cases & Error Handling

The system handles comprehensive edge cases including missing project root scenarios through validation with fallback to setup guidance, FastMCP server startup failures through exception handling with descriptive error logging, and individual resource failures through isolation preventing complete system failure. Knowledge base processing manages empty files with infinite rebuild loop prevention, missing directories with graceful degradation, and LLM truncation detection through multiple validation strategies. LLM integration addresses missing Strands Agent SDK through conditional imports with mock class definitions, AWS Bedrock connection failures with region context and troubleshooting guidance, and streaming failures with retry logic and exponential backoff. Resource delivery handles missing embedded content through comprehensive error messages, working directory management with restoration mechanisms, and HTTP formatting edge cases including Unicode content handling. The system provides smart compliance checking with conditional output returning empty responses when compliant for context optimization, comprehensive orphaned file detection with safety validation, and configuration validation with descriptive error messages for invalid parameters. Error isolation ensures individual component failures don't cascade to complete system failure while maintaining MCP protocol compliance.

########## Internal Implementation Details

The MCP server uses `FastMCP` native transport initialization with `server = FastMCP("JESSE Framework")` and automatic lifecycle management through `server.run(transport="stdio")` eliminating manual event loop creation. Resource discovery employs dynamic component scanning including rule enumeration through `get_available_rule_names()`, knowledge base scanning with exception handling, and workflow file discovery using `get_embedded_workflow_files()`. HTTP formatting applies `format_http_section()` with specific criticality classifications, portable path resolution using placeholder variables, and content type specifications for consistent MCP response delivery. Knowledge base system implements cache-first processing with `FileAnalysisCache` using HTML comment metadata blocks and SHA-256 hashing for key generation, Plan-then-Execute architecture with atomic task processing through `ExecutionEngine`, and comprehensive decision-making via `RebuildDecisionEngine`. LLM integration uses lazy initialization with thread-safe locks, conversation management through in-memory dictionaries, and streaming implementation processing different event types including data, reasoning, and tool usage events. Embedded content access employs module-relative path resolution using `Path(__file__).parent`, automatic file extension handling, and comprehensive error reporting through `FileNotFoundError` exceptions. The system maintains consistent logging patterns, structured error handling with specific exception types, and comprehensive validation protocols ensuring data integrity throughout all operations.

########### Usage Examples

**Complete MCP server initialization and startup:**

This example demonstrates the primary deployment pattern for Jesse Framework MCP Server with comprehensive resource registration and native transport management.

```python
# Initialize and run Jesse Framework MCP server with complete functionality
# Provides automatic lifecycle management and comprehensive resource access
from jesse_framework_mcp.main import main

# Start server with FastMCP native transport and all resource handlers
if __name__ == "__main__":
    main()
# Server runs with stdio transport managing all MCP protocol communication
```

**Comprehensive session initialization through meta-resource:**

This example shows how MCP clients access complete development context through single resource request, demonstrating the meta-resource aggregation pattern for efficient session startup.

```python
# Access comprehensive session context for complete development environment setup
# Returns multi-section HTTP response with framework rules, project context, and workflows
session_context = await mcp_client.read_resource("jesse://session/init-context")

# Parse multi-section response for individual contexts
sections = extract_http_sections_from_multi_response(session_context)
framework_rules = [s for s in sections if s.criticality == "CRITICAL"]
project_context = [s for s in sections if s.section_type == "project-context"]
```

**Knowledge base hierarchical indexing with Plan-then-Execute architecture:**

This example demonstrates the advanced knowledge base processing capabilities with LLM integration and comprehensive caching strategies.

```python
# Initialize hierarchical knowledge base indexing with Plan-then-Execute workflow
from jesse_framework_mcp.knowledge_bases import (
    HierarchicalIndexer, IndexingConfig, IndexingMode
)

# Configure indexing with cache optimization and LLM integration
config = IndexingConfig(
    handler_type="project-base",
    indexing_mode=IndexingMode.INCREMENTAL,
    max_concurrent_operations=4,
    enable_prompt_caching=True
)

# Execute Plan-then-Execute workflow with progress reporting
async def run_knowledge_indexing():
    indexer = HierarchicalIndexer(config)
    status = await indexer.index_hierarchy(Path("./src"), ctx)
    print(f"Processed {status.processing_stats.files_completed} files")
    print(f"LLM calls: {status.processing_stats.llm_calls_made}")
    return status
```

**LLM integration with Claude 4 Sonnet streaming capabilities:**

This example showcases the advanced AI conversation features with streaming, caching, and memory management for production applications.

```python
# Advanced LLM integration with streaming and conversation management
from jesse_framework_mcp.llm.strands_agent_driver import (
    StrandsClaude4Driver, Claude4SonnetConfig
)

# Initialize with optimized configuration for analysis tasks
config = Claude4SonnetConfig.create_optimized_for_analysis(
    streaming=True,
    enable_prompt_caching=True,
    aws_region="us-west-2"
)

# Use async context manager for proper resource management
async def ai_assisted_analysis():
    async with StrandsClaude4Driver(config) as driver:
        await driver.start_conversation("analysis_session")
        
        # Stream AI analysis with real-time processing
        async for chunk in driver.stream_conversation(
            "Analyze this codebase structure...", "analysis_session"
        ):
            if chunk.metadata.get("stream_event") == "data":
                yield chunk.content
            elif chunk.is_complete:
                break
```

## Subdirectory Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/
*Last Updated: 2025-07-07T10:10:15Z*

This directory serves as the comprehensive embedded content repository for the Jesse Framework MCP project, providing centralized access to framework rules, workflow definitions, and documentation standards that govern AI-assisted development processes. The system delivers complete framework governance through consolidated standards documents, automated workflow orchestration, and programmatic content access enabling consistent development practices across all project activities. Key semantic entities include `JESSE_*.md` rule files establishing mandatory standards for `MARKDOWN`, `SCRATCHPAD`, `CODE_GENERATION`, `KNOWLEDGE_MANAGEMENT`, `HINTS`, and `CODE_COMMENTS`, comprehensive `workflows/` subdirectory containing 15 specialized workflow automation files, `__init__.py` module providing programmatic access through `get_jesse_rule_content()`, `get_workflow_content()`, and `list_jesse_rules()` functions, `UPPERCASE_SNAKE_CASE` naming conventions for documentation files, `three-section documentation pattern` for code elements, `zero-tolerance policy` enforcement mechanisms, `intemporal writing` format requirements, `${HOME}/Cline/Rules/` preferred installation locations, `EMBEDDED_CONTENT_DIR` path constant using `Path(__file__).

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/helpers/
*Last Updated: 2025-07-07T10:10:15Z*

This directory implements comprehensive helper utilities for the Jesse Framework MCP Server, providing modular support functions organized by functionality domain including embedded content loading, knowledge base management, session handling, path resolution, HTTP formatting, and markdown processing capabilities. The helpers package enables self-contained framework delivery through build-time embedded content while supporting dynamic project knowledge loading, cross-platform path variable resolution, standardized HTTP-style formatting for MCP resources, and enhanced markdown rendering with spacing preservation. Key semantic entities include `content_loaders` module with `load_embedded_jesse_framework_async()`, `load_project_knowledge_async()`, and `format_session_response_async()` functions, `knowledge_scanners` module with `scan_git_clone_knowledge_bases_async()` and `generate_knowledge_base_inventory_async()` functions, `session_management` module with `load_wip_task_context_async()` and `log_resource_access()` functions, `path_utils` module with `get_project_root()`, `resolve_portable_path()`, and `get_portable_path()` functions, `async_http_formatter` module with `XAsyncHttpStatus`, `XAsyncHttpPath`, `format_http_section()`, and `format_multi_section_response()` components, `mistletoe_spacing` module with `MarkdownPreservingRenderer` class and spacing preservation functions, `FastMCP Context` integration throughout all modules, portable path variables `{PROJECT_ROOT}`, `...

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/
*Last Updated: 2025-07-07T10:10:15Z*

This directory implements the core Knowledge Bases Hierarchical Indexing System for the Jesse Framework MCP Server, providing comprehensive orchestration of LLM-powered content analysis, cache-first processing optimization, and Plan-then-Execute architecture for reliable knowledge base generation. The system enables automated conversion of source code repositories into structured markdown knowledge bases through bottom-up hierarchical processing, utilizing `HierarchicalIndexer` for workflow orchestration, `KnowledgeBuilder` for Claude 4 Sonnet integration, `FileAnalysisCache` for performance optimization, and `RebuildDecisionEngine` for centralized decision-making. Key semantic entities include `FastMCP` server integration, `register_knowledge_bases_tools` and `register_knowledge_bases_resources` functions, `IndexingConfig` configuration management, `DirectoryContext` and `FileContext` runtime tracking, `ExecutionPlan` and `AtomicTask` execution modeling, `ProcessingStatus` and `IndexingMode` enumerations, `DecisionReport` and `RebuildDecision` audit structures, `TruncationDetectedError` handling, `EnhancedPrompts` LLM templates, `KnowledgeFileGenerator` output creation, `DebugHandler` interaction capture, `MarkdownParser` AST manipulation, `GitCloneHandler` and `ProjectBaseHandler` specialized processing, `mistletoe` parsing integration, `StrandsClaude4Driver` LLM operations, `Claude4SonnetConfig` model configuration, and comprehensive change detection with selective cascadi...

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/
*Last Updated: 2025-07-07T10:10:15Z*

This directory serves as the Large Language Model integration layer for the Jesse Framework MCP Server, providing comprehensive AI conversation capabilities through specialized driver implementations for advanced language models within the broader MCP ecosystem. The directory enables developers to integrate sophisticated AI conversation features including real-time streaming, intelligent caching, memory management, and conversation persistence through modular driver architectures designed for production deployment scenarios. Key semantic entities include `StrandsClaude4Driver` main driver class for AWS Bedrock Claude 4 Sonnet integration, `ConversationManager` for session and cache management, `Claude4SonnetConfig` configuration class with factory methods `create_optimized_for_conversations()`, `create_optimized_for_analysis()`, and `create_optimized_for_performance()`, `PromptCache` class for in-memory response caching with TTL and LRU eviction policies, `ConversationMemoryStrategy` enum with `SUMMARIZING`, `SLIDING_WINDOW`, and `NULL` memory management options, streaming response classes `StreamingResponse` and `ConversationResponse`, comprehensive exception hierarchy including `StrandsDriverError`, `ConversationError`, `ModelConfigurationError`, `CacheError`, `BedrockConnectionError`, `StreamingError`, and `TokenLimitError`, AWS integration through environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, Strands Agent SDK compone...

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/
*Last Updated: 2025-07-07T10:10:15Z*

This directory implements the comprehensive resources layer for the Jesse Framework MCP Server, providing HTTP-formatted resource handlers that deliver all essential development contexts through modern resource-first architecture with individual access patterns and intelligent session initialization capabilities. The directory enables MCP clients to access framework rules, project knowledge, WIP tasks, workflows, knowledge bases, and gitignore compliance through dedicated resource URIs supporting both granular individual access and consolidated meta-resource delivery for efficient AI-assisted development workflows. Key semantic entities include primary resource handler functions `get_wip_tasks_inventory()`, `get_jesse_workflow()`, `get_session_init_context()`, `get_knowledge_management_rule()`, `get_project_knowledge()`, `get_git_clones_readme()`, and `get_gitignore_compliance_status()` decorated with `@server.resource()` patterns, centralized registration function `register_all_resources()` coordinating all resource handler registrations, HTTP formatting functions `format_http_section()` and `format_multi_section_response()` with criticality classifications `XAsyncContentCriticality.CRITICAL`, `XAsyncContentCriticality.

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/__init__.py

*Last Updated: 2025-07-07T10:10:15Z*

#### Functional Intent & Features

This file implements the package initialization for the Jesse Framework MCP Server, providing the primary entry point and version information for the complete self-contained JESSE framework distribution. The module serves as the public interface for the MCP server package, enabling both console script execution and programmatic usage through standardized Python packaging patterns. Key semantic entities include package metadata constants `__version__ = "0.1.0"`, `__author__ = "JESSE Framework"`, and `__email__ = "contact@jesse-framework.dev"` for distribution identification, main entry point import `from .main import main` providing access to the FastMCP server implementation, export list `__all__ = ["main", "__version__"]` defining the public API surface, comprehensive docstring describing MCP server capabilities including `jesse_start_session` and `jesse_load_knowledge_base` functionality, usage examples for both command-line execution via `jesse-framework-mcp` console script and programmatic access through `asyncio.run(main())`, and build-time embedded content support for complete framework distribution. The system implements Python packaging standards for MCP server distribution with async main entry point compatibility for FastMCP stdio transport protocol while maintaining Python 3.8+ compatibility for broad deployment support.

##### Main Components

The file contains package metadata definitions, one primary import statement, one export list, and comprehensive documentation providing complete package initialization functionality. The package metadata includes `__version__`, `__author__`, and `__email__` constants establishing package identity and contact information for distribution. The main import statement `from .main import main` provides access to the FastMCP server implementation from the main module. The export list `__all__ = ["main", "__version__"]` defines the public API surface limiting exposed functionality to essential components. The module docstring provides comprehensive documentation describing MCP server capabilities, usage patterns, and integration examples for both console script and programmatic access scenarios.

###### Architecture & Design

The architecture implements a standard Python package initialization pattern with clean separation between public API surface and internal implementation details, following Python packaging standards for MCP server distribution. The design emphasizes simplicity through minimal package initialization with clear version and entry point exports, async compatibility through main entry point wrapper for FastMCP stdio transport, and comprehensive documentation providing usage guidance for different deployment scenarios. Key design patterns include the package initialization pattern establishing public API through `__all__` exports, entry point delegation pattern importing main functionality from implementation module, metadata definition pattern providing package identity through standard Python package attributes, and documentation pattern providing comprehensive usage examples for both command-line and programmatic access. The system uses standard Python packaging conventions with minimal complexity while maintaining compatibility requirements for MCP protocol integration.

####### Implementation Approach

The implementation uses standard Python package initialization with direct import delegation to the main module through `from .main import main` statement. Package metadata employs standard Python conventions with string constants for `__version__`, `__author__`, and `__email__` attributes. Public API definition uses `__all__` list containing `["main", "__version__"]` to explicitly control exported symbols. The approach implements comprehensive documentation through module docstring including usage examples for console script execution and programmatic access patterns. Entry point compatibility maintains async support through delegation to main module implementation while providing synchronous package-level interface. Documentation includes specific usage patterns with command-line execution via `jesse-framework-mcp` and programmatic execution through `asyncio.run(main())` for different deployment scenarios.

######## External Dependencies & Integration Points

**→ Inbound:**
- `.main:main` - main FastMCP server implementation providing complete MCP protocol functionality and resource handlers
- `asyncio` (external library) - async event loop support for MCP protocol execution referenced in documentation examples

**← Outbound:**
- Console script systems - consuming package entry point through `jesse-framework-mcp` command for MCP server execution
- Python import systems - accessing package functionality through `import jesse_framework_mcp` for programmatic usage
- Package distribution systems - using package metadata for PyPI distribution and dependency management
- MCP client applications - connecting to server through stdio transport for JESSE framework functionality
- Build systems - accessing package structure for embedded content integration and distribution packaging

**⚡ System role and ecosystem integration:**
- **System Role**: Package initialization interface for Jesse Framework MCP Server ecosystem, providing standardized entry point and metadata for complete framework distribution with MCP protocol compliance
- **Ecosystem Position**: Core package interface serving as primary access point for all JESSE framework functionality, bridging between Python packaging standards and MCP server implementation
- **Integration Pattern**: Used by package managers for distribution metadata, consumed by console script systems for command-line execution, accessed by Python applications for programmatic integration, and coordinated with build systems for embedded content packaging and deployment

######### Edge Cases & Error Handling

The system handles import failures through standard Python import mechanisms with potential ImportError exceptions if main module unavailable during package initialization. Package metadata access manages missing attributes through standard Python attribute access patterns with AttributeError exceptions for undefined package information. Console script execution handles async compatibility through delegation to main module implementation managing event loop creation and MCP protocol initialization. Documentation examples handle execution failures through standard asyncio exception handling patterns for event loop management. Package initialization manages missing dependencies through import-time error propagation preventing package loading when core functionality unavailable. The minimal implementation approach reduces error surface area by delegating complex functionality to main module while maintaining standard Python packaging error handling patterns.

########## Internal Implementation Details

The module uses direct import delegation with `from .main import main` providing access to FastMCP server implementation without additional wrapper logic. Package metadata employs string literal assignments with `__version__ = "0.1.0"`, `__author__ = "JESSE Framework"`, and `__email__ = "contact@jesse-framework.dev"` following Python packaging conventions. Public API definition uses list literal `__all__ = ["main", "__version__"]` explicitly controlling symbol exports for package consumers. Module docstring implements triple-quoted string with comprehensive documentation including package description, feature overview, and usage examples for different deployment scenarios. The implementation maintains minimal complexity with no additional logic beyond standard Python package initialization patterns while providing complete interface for MCP server functionality access.

########### Code Usage Examples

Console script execution demonstrates the primary deployment pattern for Jesse Framework MCP Server with command-line interface. This approach provides standardized MCP server execution through package console script integration.

```bash
# Execute Jesse Framework MCP Server through console script for MCP protocol communication
# Provides complete JESSE framework functionality over stdio transport
$ jesse-framework-mcp
# Server runs with FastMCP stdio transport for MCP client communication
```

Programmatic usage showcases the integration pattern for embedding Jesse Framework MCP Server within Python applications. This pattern enables custom MCP server deployment with application-specific configuration and lifecycle management.

```python
# Integrate Jesse Framework MCP Server programmatically for custom deployment scenarios
# Provides full control over server lifecycle and configuration within Python applications
import asyncio
from jesse_framework_mcp import main

# Execute server with custom async context and error handling
async def run_jesse_server():
    try:
        await main()
    except Exception as e:
        print(f"Server error: {e}")

# Run server with asyncio event loop management
asyncio.run(run_jesse_server())
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/constants.py

*Last Updated: 2025-07-07T10:10:15Z*

#### Functional Intent & Features

This file implements central configuration constants for the Jesse Framework MCP Server, providing a single source of truth for JESSE rule file definitions and HTTP formatting standards while eliminating hardcoded rule filenames across the codebase. The module enables dynamic discovery support for embedded content at runtime and comprehensive validation of rule file configurations against actual embedded resources. Key semantic entities include the core constant `JESSE_RULE_FILES` list containing six framework rule files, HTTP formatting constants `HTTP_BOUNDARY`, `HTTP_BOUNDARY_MARKER`, and `CONTENT_TYPES` dictionary for MCP resource standardization, section type classifications in `SECTION_TYPES` dictionary, criticality mappings `RULE_CRITICALITY_MAP` and `DEFAULT_CRITICALITY` for AI assistant processing, primary functions `get_jesse_rule_files()`, `get_jesse_rule_mapping()`, `discover_jesse_rule_files()`, `validate_jesse_rule_files()`, and `get_rule_files_info()` for rule management, `importlib.resources` import with Python < 3.9 compatibility fallback to `importlib_resources`, and comprehensive type hints using `typing.List`, `typing.Dict`, and `typing.Optional` for better code documentation. The system implements runtime discovery as fallback mechanism with graceful failure handling when embedded content cannot be accessed while maintaining compatibility with existing importlib.resources usage patterns.

##### Main Components

The file contains five primary functions, six constant definitions, and four dictionary configurations providing comprehensive rule file management and HTTP formatting standardization. The `get_jesse_rule_files()` function returns the complete list of JESSE rule files from central configuration with copy protection. The `get_jesse_rule_mapping()` function generates mapping from short rule names to full JESSE rule file names by automatically deriving from the central rule file list. The `discover_jesse_rule_files()` function dynamically discovers JESSE rule files from embedded content at runtime using importlib.resources scanning. The `validate_jesse_rule_files()` function validates configured JESSE rule files against embedded content for configuration consistency. The `get_rule_files_info()` function provides comprehensive information about JESSE rule files configuration for debugging and monitoring. Constant definitions include `JESSE_RULE_FILES` as the central list, `HTTP_BOUNDARY` and `HTTP_BOUNDARY_MARKER` for HTTP-style formatting, and dictionary configurations for `CONTENT_TYPES`, `SECTION_TYPES`, `RULE_CRITICALITY_MAP`, and `DEFAULT_CRITICALITY`.

###### Architecture & Design

The architecture implements a centralized configuration pattern with single source of truth for JESSE rule file definitions, following dynamic discovery support with runtime validation and graceful failure handling mechanisms. The design emphasizes elimination of hardcoded values through central constant management, automatic mapping generation from core rule lists to avoid duplication, and comprehensive HTTP formatting standardization for MCP resource delivery. Key design patterns include the single source of truth pattern centralizing all JESSE rule file definitions in one location, dynamic discovery pattern using importlib.resources for runtime content scanning, validation pattern comparing configured files with discovered embedded files, mapping generation pattern automatically deriving short names from full file names, and graceful degradation pattern handling embedded content access failures without breaking functionality. The system uses defensive programming with optional return types and exception handling, modular function design for specific responsibilities, and comprehensive type hints for better code documentation and IDE support.

####### Implementation Approach

The implementation uses list-based central configuration with `JESSE_RULE_FILES` containing six framework rule files as the authoritative source. Rule mapping generation employs string manipulation with prefix/suffix removal using `file_name[6:-3].lower()` to convert `JESSE_*.md` files to short names. Dynamic discovery utilizes `importlib.resources.files()` with directory iteration and file filtering for `JESSE_*.md` pattern matching. The approach implements validation through sorted list comparison between configured and discovered files, comprehensive error handling with try-catch blocks returning None for graceful failure scenarios, and dictionary-based configuration for HTTP formatting constants including content types, section types, and criticality mappings. Function design follows single responsibility principle with clear separation between configuration access, mapping generation, discovery, validation, and information gathering. Type hints employ `List[str]`, `Dict[str, str]`, `Optional[List[str]]`, and `Dict[str, any]` for comprehensive type safety and documentation.

######## External Dependencies & Integration Points

**→ Inbound:**
- `importlib.resources` (external library) - dynamic rule discovery from embedded content with directory scanning and file filtering
- `importlib_resources` (external library) - Python < 3.9 compatibility fallback for resource access functionality
- `typing` (external library) - type hints including List, Dict, Optional for better code documentation and IDE support
- `jesse_framework_mcp.embedded_content/` - embedded content directory containing JESSE rule files accessed through importlib.resources

**← Outbound:**
- Framework rule resource handlers - consuming `get_jesse_rule_files()` and `get_jesse_rule_mapping()` for rule access and routing
- HTTP formatter modules - using HTTP formatting constants for boundary markers, content types, and section classifications
- Resource validation systems - consuming `validate_jesse_rule_files()` for configuration consistency checking
- MCP server initialization - using rule file constants for resource registration and embedded content validation
- Debugging and monitoring tools - accessing `get_rule_files_info()` for comprehensive configuration diagnostics

**⚡ System role and ecosystem integration:**
- **System Role**: Central configuration hub for Jesse Framework MCP Server ecosystem, providing authoritative source for JESSE rule file definitions and HTTP formatting standards with dynamic discovery and validation capabilities
- **Ecosystem Position**: Core infrastructure component serving as foundation for all rule-based functionality, eliminating hardcoded values and providing consistent configuration access across the entire framework
- **Integration Pattern**: Used by framework components through function imports for rule file access, consumed by HTTP formatters for standardized resource delivery, integrated with embedded content system through importlib.resources for runtime discovery, and coordinated with validation systems for configuration consistency checking

######### Edge Cases & Error Handling

The system handles missing embedded content through graceful failure in `discover_jesse_rule_files()` returning None when importlib.resources access fails. Import compatibility manages Python version differences through try-catch import patterns with `importlib_resources` fallback for Python < 3.9 environments. File discovery handles non-existent embedded content directories through exception catching with None return values preventing system failures. Validation logic manages discovery failures by assuming configuration correctness when embedded content cannot be accessed. Rule mapping handles malformed file names through conditional checks ensuring files start with `JESSE_` and end with `.md` before processing. Configuration access provides copy protection in `get_jesse_rule_files()` preventing external modification of central rule list. Comprehensive error handling uses try-catch blocks with graceful degradation rather than exception propagation for non-critical operations.

########## Internal Implementation Details

The module uses central list definition with `JESSE_RULE_FILES` containing six specific rule files: `JESSE_KNOWLEDGE_MANAGEMENT.md`, `JESSE_HINTS.md`, `JESSE_CODE_COMMENTS.md`, `JESSE_CODE_GENERATION.md`, `JESSE_MARKDOWN.md`, and `JESSE_SCRATCHPAD.md`. HTTP formatting employs specific boundary marker `HTTP_BOUNDARY = "ASYNC-HTTP-SECTION-START-v20250628"` with formatted marker string. Content type mapping includes `text/markdown`, `application/json`, `text/plain`, `application/yaml` with workflow-specific markdown classification. Rule mapping implements string slicing with `file_name[6:-3].lower()` removing `JESSE_` prefix and `.md` suffix for short name generation. Discovery uses `resources.files('jesse_framework_mcp.embedded_content')` with `iterdir()` and conditional filtering for JESSE rule pattern matching. Validation employs sorted list comparison with `configured == discovered` for exact match verification. Information gathering combines all functions into comprehensive dictionary with configured files, discovered files, rule mapping, validation status, and total count for debugging support.

########### Code Usage Examples

Central rule file access demonstrates the primary usage pattern for obtaining JESSE framework rule definitions. This approach provides consistent access to rule files across the entire codebase while maintaining single source of truth.

```python
# Access central JESSE rule file configuration for framework resource handlers
# Provides single source of truth eliminating hardcoded rule filenames across codebase
from jesse_framework_mcp.constants import get_jesse_rule_files, get_jesse_rule_mapping

# Get complete list of JESSE rule files
rule_files = get_jesse_rule_files()
# Returns: ['JESSE_KNOWLEDGE_MANAGEMENT.md', 'JESSE_HINTS.md', ...]

# Get mapping from short names to full file names
rule_mapping = get_jesse_rule_mapping()
# Returns: {'knowledge_management': 'JESSE_KNOWLEDGE_MANAGEMENT.md', ...}
```

HTTP formatting constants showcase the standardization pattern for MCP resource delivery with consistent boundary markers and content types. This pattern ensures uniform HTTP-style formatting across all framework resources.

```python
# Use HTTP formatting constants for standardized MCP resource delivery
# Provides consistent boundary markers and content type definitions
from jesse_framework_mcp.constants import HTTP_BOUNDARY_MARKER, CONTENT_TYPES, DEFAULT_CRITICALITY

# Apply HTTP boundary marker for resource sections
section_header = f"{HTTP_BOUNDARY_MARKER}\nContent-Type: {CONTENT_TYPES['markdown']}"

# Use default criticality for resource classification
criticality = DEFAULT_CRITICALITY['framework-rule']  # Returns 'CRITICAL'

# Validate configuration consistency
from jesse_framework_mcp.constants import validate_jesse_rule_files
is_valid = validate_jesse_rule_files()  # Returns True if configuration matches embedded content
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/main.py

*Last Updated: 2025-07-07T10:10:15Z*

#### Functional Intent & Features

This file implements the main FastMCP server for the Jesse Framework MCP Server, providing resource-first MCP protocol compliance with FastMCP native transport architecture for AI-assisted development workflows. The module serves as the central entry point orchestrating all framework resources including individual JESSE rules, project context, workflows, knowledge bases, and WIP tasks through standardized MCP resource endpoints. Key semantic entities include `FastMCP` server instance initialized as `server = FastMCP("JESSE Framework")`, primary resource handler `framework_index()` decorated with `@server.resource("jesse://index")` for lightweight resource discovery, prompt handlers `jesse_framework_start_prompt()`, `jesse_wip_task_create_prompt()`, and `jesse_knowledge_capture_prompt()` decorated with `@server.prompt()`, utility functions `get_embedded_workflow_files()` and `get_workflow_description()` for workflow metadata extraction, main entry point `main()` function using `server.run(transport="stdio")` for FastMCP native transport, resource registration through `from . import resources` auto-importing all resource handlers, knowledge base integration via `register_knowledge_bases_tools()` and `register_knowledge_bases_resources()`, HTTP formatting through `format_http_section()` with `XAsyncContentCriticality.INFORMATIONAL`, logging configuration using `logging.basicConfig(level=logging.INFO)`, and comprehensive resource index generation with JSON serialization including framework rules, project resources, knowledge bases, WIP tasks, and workflows. The system implements FastMCP 2.0 patterns with automatic lifecycle management eliminating manual event loop creation while providing comprehensive resource discovery and programmatic access to all framework components.

##### Main Components

The file contains one primary resource handler, three prompt handlers, two utility functions, and one main entry point providing comprehensive MCP server functionality. The `framework_index()` resource handler serves the `jesse://index` endpoint delivering lightweight JSON-based resource discovery with metadata for all framework components. The prompt handlers include `jesse_framework_start_prompt()` for framework initialization, `jesse_wip_task_create_prompt()` for WIP task creation with complexity assessment, and `jesse_knowledge_capture_prompt()` for structured knowledge capture workflows. Utility functions include `get_embedded_workflow_files()` for dynamic workflow discovery from embedded content and `get_workflow_description()` for human-readable workflow metadata extraction. The `main()` function serves as the primary entry point implementing FastMCP native transport with stdio communication and comprehensive error handling. Resource registration occurs through module imports including `from . import resources` for auto-registration of all resource handlers and explicit registration of knowledge base tools and resources.

###### Architecture & Design

The architecture implements a resource-first design with FastMCP native transport management, following clean separation between transport layer and resource implementations with automatic lifecycle management. The design emphasizes lightweight resource discovery through JSON-based indexing, comprehensive prompt template system for consistent AI assistant interaction, and modular resource organization with auto-registration patterns. Key design patterns include the resource-first pattern with individual resource access through dedicated URIs, auto-registration pattern leveraging FastMCP decorators for automatic resource handler discovery, lightweight indexing pattern providing fast metadata access without full content loading, prompt template pattern for reusable AI assistant interaction workflows, and native transport pattern using FastMCP's built-in stdio management eliminating manual event loop handling. The system uses composition over inheritance with modular resource imports, centralized server instance shared across all components, and defensive programming with descriptive error messages for all failure scenarios.

####### Implementation Approach

The implementation uses FastMCP native transport with `server.run(transport="stdio")` eliminating manual event loop management and leveraging FastMCP 2.0 automatic lifecycle handling. Resource discovery employs dynamic scanning of available components including framework rules enumeration through `get_available_rule_names()`, knowledge base scanning via `scan_available_knowledge_bases_async()`, and WIP task counting through directory iteration. Content delivery combines JSON serialization for structured metadata with HTTP formatting using `format_http_section()` for consistent MCP response patterns. The approach implements auto-registration through module imports with `from . import resources` triggering decorator-based resource handler registration, explicit knowledge base registration through dedicated functions, and comprehensive error handling with try-catch blocks and descriptive error messages. Prompt generation uses template-based patterns with parameter substitution and complexity-based guidance for different workflow scenarios. Logging employs standard Python logging with INFO level configuration for operational visibility and debugging support.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:FastMCP` - FastMCP framework providing native transport and MCP protocol compliance with automatic lifecycle management
- `fastmcp:Context` - FastMCP Context for resource operations with progress reporting and logging capabilities
- `logging` (external library) - server logging and error reporting with configurable log levels and structured output
- `pathlib.Path` (external library) - cross-platform filesystem operations for directory scanning and file access
- `json` (external library) - JSON serialization for resource index generation and structured data delivery
- `datetime` (external library) - timestamp generation for resource metadata and index generation
- `.resources` - auto-registration of all resource handlers through module import triggering decorator-based registration
- `.helpers.knowledge_scanners` - knowledge base scanning functionality for resource discovery and metadata extraction
- `.helpers.async_http_formatter:format_http_section` - HTTP section formatting with criticality classification for MCP responses
- `.knowledge_bases:register_knowledge_bases_tools` - knowledge base tool registration for MCP tool endpoints
- `.knowledge_bases:register_knowledge_bases_resources` - knowledge base resource registration for MCP resource endpoints

**← Outbound:**
- MCP clients - consuming framework resources through standardized MCP protocol with resource and prompt endpoints
- AI assistants - accessing framework initialization prompts and resource discovery through MCP transport
- Development environments - using Jesse Framework resources for AI-assisted development workflows and context delivery
- Cline AI assistant - consuming workflow resources as slash commands and framework prompts for development guidance
- FastMCP transport layer - receiving server instance configuration and resource handler registrations for protocol compliance
- Console applications - using main entry point for server startup and lifecycle management

**⚡ System role and ecosystem integration:**
- **System Role**: Central MCP server orchestrator for Jesse Framework ecosystem, providing FastMCP native transport with comprehensive resource discovery and prompt template system for AI-assisted development workflows
- **Ecosystem Position**: Core infrastructure component serving as primary MCP protocol interface, coordinating all framework resources and providing unified access point for AI assistants and development tools
- **Integration Pattern**: Used by MCP clients through stdio transport for resource and prompt access, consumed by AI assistants for framework initialization and workflow guidance, integrated with FastMCP framework through native transport patterns, and coordinated with all framework components through auto-registration and centralized server instance management

######### Edge Cases & Error Handling

The system handles FastMCP server startup failures through comprehensive exception handling in `main()` function with descriptive error logging and proper exception propagation. Resource index generation manages individual component failures through try-catch blocks preventing complete index failure when specific resources unavailable. Knowledge base scanning handles missing directories and access permissions through exception handling with empty list fallbacks. Workflow file discovery manages missing embedded content through exception propagation with detailed error context. WIP task counting handles non-existent directories through existence checking with zero count fallbacks. Prompt generation handles missing or invalid parameters through default value assignment and parameter validation. Server lifecycle management includes KeyboardInterrupt handling for graceful shutdown and comprehensive error logging for debugging support. Resource registration failures are managed through individual module error handling preventing complete server startup failure.

########## Internal Implementation Details

The module uses FastMCP native transport with `server = FastMCP("JESSE Framework")` initialization and `server.run(transport="stdio")` for automatic lifecycle management eliminating manual event loop creation. Resource index generation employs dynamic component discovery including rule enumeration through `await get_available_rule_names()`, knowledge base scanning with exception handling, and WIP task directory iteration using `Path(".knowledge/work-in-progress").iterdir()`. JSON serialization uses `json.dumps(index_data, indent=2, ensure_ascii=False)` for structured metadata delivery with Unicode support. HTTP formatting applies `format_http_section()` with `XAsyncContentCriticality.INFORMATIONAL` classification and `application/json` content type. Logging configuration uses `logging.basicConfig(level=logging.INFO)` with named logger `logger = logging.getLogger(__name__)` for structured output. Auto-registration leverages Python import system with `from . import resources` triggering decorator-based resource handler discovery. Prompt templates use f-string formatting with parameter substitution and conditional content based on input parameters. Error handling implements specific exception types with detailed error messages including component names and operation context for comprehensive debugging support.

########### Code Usage Examples

FastMCP server initialization demonstrates the primary startup pattern for Jesse Framework MCP server with native transport. This approach provides complete MCP protocol compliance with automatic lifecycle management and comprehensive resource registration.

```python
# Initialize and run Jesse Framework MCP server with FastMCP native transport
# Provides automatic lifecycle management and stdio transport for MCP protocol compliance
from jesse_framework_mcp.main import main

# Start server with comprehensive resource registration and error handling
main()
# Server runs with FastMCP native transport managing all protocol communication
```

Resource index access showcases the lightweight discovery pattern for programmatic framework exploration. This pattern enables efficient resource metadata access without full content loading for client optimization and resource enumeration.

```python
# Access lightweight framework resource index for programmatic discovery
# Returns JSON-structured metadata for all available framework resources
import json
from fastmcp import Context

# Framework index provides comprehensive resource metadata
index_response = await framework_index(Context())
index_data = json.loads(index_response)

# Access resource categories and metadata
framework_rules = index_data["resource_categories"]["framework_rules"]
available_rules = framework_rules["available_rules"]
uri_pattern = framework_rules["uri_pattern"]

# Use metadata for dynamic resource access
for rule_name in available_rules:
    rule_uri = uri_pattern.format(rule_name=rule_name)
    print(f"Framework rule: {rule_uri}")
```

---
*Generated: 2025-07-07T10:10:15Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp*
*Total Files: 3*
*Total Subdirectories: 5*

# End of jesse_framework_mcp_kb.md