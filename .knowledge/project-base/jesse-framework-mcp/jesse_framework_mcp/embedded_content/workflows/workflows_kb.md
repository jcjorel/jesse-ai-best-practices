<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/

## Global Summary

#### Functional Intent & Features

This directory provides a comprehensive workflow automation system for the Jesse Framework MCP ecosystem, delivering structured development processes through specialized markdown-based workflow definitions that orchestrate complex multi-step operations across Git repositories, knowledge management systems, and AI-assisted development environments. The system enables systematic task management, code quality assurance, knowledge capture, and strategic planning through automated workflows with integrated validation, error handling, and state management. Key semantic entities include `Do your magic` compliance analysis triggers, `WIP task` lifecycle management with `.knowledge/work-in-progress/` directory structures, `Git` integration patterns using `git status --porcelain` and branch management commands, `Cline` session coordination via `https://github.com/cline/cline`, `Amazon Working Backwards` methodology implementation with `working_backwards/current/` state preservation, `MCP Perplexity` research integration for external knowledge gathering, `PyPDF2` PDF processing capabilities, `Context Window Management Protocol` with 80% capacity monitoring, `intemporal writing` format conversion for knowledge persistence, `snake_case` naming conventions, `ISO timestamp` formatting, structured commit message templates with mandatory sections, and comprehensive error handling with rollback mechanisms ensuring consistent system state across all workflow operations.

##### Main Components

The directory contains fifteen specialized workflow files implementing distinct operational domains: code quality assurance through `jesse_do_your_magic.md` compliance analysis, comprehensive task lifecycle management via `jesse_wip_task_create.md`, `jesse_wip_task_switch.md`, `jesse_wip_task_complete.md`, and `jesse_wip_task_archive.md`, knowledge management workflows including `jesse_wip_task_capture_knowledge.md` and `jesse_wip_kb_git_clone_import.md`, conversation preservation through `jesse_capture_our_chat.md`, session management via `jesse_wip_task_new_session.md` and `jesse_wip_task_disable.md`, strategic planning through `jesse_amazon_prfaq_coach.md`, framework maintenance via `jesse_framework_upgrade.md`, specialized file processing through `jesse_wip_task_process_large_file.md` and `jesse_wip_kb_pdf_import.md`, version control integration via `jesse_wip_task_commit.md`, and knowledge consistency verification through `jesse_wip_task_check_consistency.md`. Each workflow implements structured execution steps with validation checkpoints, error handling procedures, and integration patterns supporting the broader Jesse Framework development ecosystem.

###### Architecture & Design

The architecture implements a modular workflow orchestration pattern with standardized execution frameworks, state management protocols, and integration interfaces across all workflow components. The design employs trigger-response activation mechanisms supporting both natural language commands and explicit workflow invocation, systematic validation checkpoints preventing inconsistent operations, and comprehensive error handling with rollback capabilities ensuring system integrity. The system uses structured template-based content generation with markdown formatting standards, hierarchical directory organization patterns, and atomic file operations with verification protocols. The architectural pattern includes session-aware state management through memory-based flags and file-based persistence, multi-workflow coordination through shared knowledge bases and Git repository integration, and progressive complexity handling from simple operations to multi-session processes with context window management and graceful degradation capabilities.

####### Implementation Approach

The implementation uses standardized workflow execution patterns with sequential step processing, mandatory validation checkpoints, and comprehensive error recovery mechanisms across all workflow types. The approach employs Git command-line integration for repository operations, file system manipulation for knowledge base management, and external service integration through MCP protocols for research and analysis capabilities. Workflow coordination uses shared state management through `.knowledge/` directory structures, Essential Knowledge Base synchronization via `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md`, and session state preservation through dedicated working directories. The system implements template-driven content generation with structured markdown formats, automated naming conventions using snake_case conversion algorithms, and timestamp-based organization for archival and tracking purposes. Quality assurance employs validation protocols with format compliance checking, content completeness verification, and cross-reference integrity maintenance across multiple knowledge storage locations.

######## External Dependencies & Integration Points

**→ References:**
- `git` (external tool) - version control system providing repository validation, branch management, commit operations, and merge assistance across multiple workflows
- `Cline` conversation system via `https://github.com/cline/cline` - session management and workflow execution environment for multi-session coordination
- `MCP Perplexity` server - external research service for knowledge gathering, repository analysis, and market research integration
- `PyPDF2` (external library) - PDF processing capabilities for document indexing and content extraction workflows
- `.knowledge/` directory structure - centralized knowledge storage including work-in-progress tasks, persistent knowledge, git clones, and PDF repositories
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - Essential Knowledge Base requiring updates across multiple workflow operations
- `Amazon Working Backwards` methodology - strategic planning framework with authentic templates and coaching guidance
- `VSCode` editor integration - scope determination and file context for analysis workflows

**← Referenced By:**
- Jesse Framework MCP server - primary consumer of workflow automation for development process orchestration
- Development team processes - consume structured workflows for task management, code quality, and knowledge capture
- CI/CD pipeline integration - reference workflow standards for automated quality assurance and validation
- Knowledge management systems - use workflow outputs for structured information organization and cross-referencing
- Project documentation generation - leverage workflow-generated content for comprehensive project knowledge bases
- Quality assurance procedures - enforce workflow standards for consistency and compliance verification

**⚡ System role and ecosystem integration:**
- **System Role**: Core workflow automation engine within the Jesse Framework MCP ecosystem, providing structured development process orchestration with integrated Git management, knowledge capture, and quality assurance capabilities
- **Ecosystem Position**: Central infrastructure component bridging development tools, knowledge management systems, and AI-assisted workflows through standardized automation patterns and state management protocols
- **Integration Pattern**: Invoked by developers and AI assistants through natural language triggers and explicit commands, coordinates with Git repositories and external services, produces structured outputs for knowledge management and project coordination while maintaining system consistency through comprehensive validation and error handling mechanisms

######### Edge Cases & Error Handling

The workflow system addresses comprehensive error scenarios including Git repository state inconsistencies through mandatory validation checkpoints and rollback procedures, context window exhaustion via proactive monitoring and graceful session handoff mechanisms, and file system operation failures through atomic operations with complete state restoration capabilities. Network connectivity issues affecting external service integration implement graceful degradation with offline processing options and retry mechanisms. Multi-session coordination handles interrupted workflows through persistent state management and resume capabilities across Cline session boundaries. Validation failures trigger specific error reporting with correction guidance and iterative improvement workflows. The system manages concurrent workflow execution through state locking mechanisms and conflict detection, while handling partial operation failures through comprehensive rollback procedures ensuring consistent system state regardless of failure points.

########## Internal Implementation Details

The workflow system uses standardized execution engines with sequential step processing, mandatory checkpoint validation, and comprehensive state tracking across all workflow types. Template processing employs structured markdown generation with dynamic content insertion, placeholder replacement, and format compliance verification. State management implements file-based persistence through JSON progress tracking, directory-based organization with timestamp-based naming, and memory-based session flags for temporary configuration changes. Git integration uses command-line operations with porcelain command parsing, branch management algorithms, and merge strategy selection with conflict resolution guidance. Knowledge base operations employ content extraction algorithms, cross-reference validation, and consistency checking across multiple storage locations. Error handling implements detailed logging with specific resolution guidance, atomic operation patterns with rollback capabilities, and comprehensive validation protocols ensuring data integrity throughout all workflow operations.

########### Usage Examples

This example demonstrates the comprehensive task lifecycle management workflow from creation through completion with Git integration:

```bash
# Create new WIP task with Git branch management
User: "Create a new task for implementing authentication system"
# System validates Git state, creates task structure, establishes branch
# Result: .knowledge/work-in-progress/auth_system_implementation/ with WIP_TASK.md and PROGRESS.md

# Switch between tasks with safety validation
User: "Switch to API refactoring task"
# System validates uncommitted changes, loads task context, switches Git branch

# Complete task with knowledge extraction and archival
User: "Complete current task"
# System extracts learnings, merges Git branch, archives task with timestamp
```

This example shows the integrated knowledge management workflow with external research and consistency verification:

```bash
# Capture knowledge with automatic categorization and storage
User: "Remember this API pattern for future reference"
# System categorizes knowledge, applies intemporal writing, updates persistent storage

# Import external repository with structured analysis
User: "Import https://github.com/example/auth-library for reference"
# System clones repository, generates knowledge base, processes large files

# Verify knowledge consistency across all sources
User: "Check knowledge consistency across all files"
# System scans all knowledge bases, identifies conflicts, guides resolution
```

This example illustrates the quality assurance and strategic planning workflow integration:

```bash
# Perform comprehensive code compliance analysis
User: "Do your magic on the authentication module"
# System analyzes code against standards, generates findings, provides remediation plan

# Create strategic PR/FAQ document with Amazon methodology
User: "Help me create a PR/FAQ for the new authentication feature"
# System guides through Working Backwards methodology, generates professional document

# Commit changes with structured documentation
User: "Commit these authentication changes"
# System analyzes changes, generates structured commit message, requires user confirmation
```

## Subdirectory Knowledge Integration

*No subdirectories processed*

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_amazon_prfaq_coach.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow documentation provides a comprehensive Amazon PR/FAQ coaching system implementing the authentic Amazon Working Backwards methodology, designed to guide users through creating professional PR/FAQ documents using real Amazon templates, examples, and coaching frameworks extracted from internal Amazon sources. The system delivers mandatory knowledge base loading with selective exclusions, context window management protocols preventing session interruption, and complete 5-stage Working Backwards methodology implementation (`LISTEN`, `DEFINE`, `INVENT`, `REFINE`, `TEST & ITERATE`). Key semantic entities include `Context Window Management Protocol` with 80% capacity monitoring, `working_backwards/current/` directory structure for session state preservation, `JESSE_KNOWLEDGE_MANAGEMENT.md` mandatory loading, `MCP Perplexity` research integration, Amazon's `7-paragraph Press Release Structure`, comprehensive `FAQ Organization System` with 11 essential internal questions, `Customer Focus Scoring System` for quality assessment, `Believability Assessment Framework` for testimonial validation, Amazon's `Top 10 Writing Guidelines` implementation, and complete `Working Backwards Assessment` with customer research methods, problem definition templates, solution evaluation matrices, experience design frameworks, and comprehensive success metrics enabling authentic Amazon-style strategic document creation with professional coaching guidance.

##### Main Components

The workflow contains fourteen primary sections organized into coaching methodology, document creation, and quality assessment components. Core sections include initial setup with experience assessment routing, Working Backwards Assessment implementing the 5-stage methodology, PR/FAQ Document Creation using Amazon's complete framework, Advanced Writing Quality Assessment with Amazon's top 10 guidelines, Knowledge Base Integration for persistent storage, and specialized modes including Examples Library with 20+ real Amazon examples, Methodology Learning Mode for comprehensive education, and Iterative Coaching Mode for section-by-section guidance. The system incorporates mandatory protocols including Context Window Management with graceful halt procedures, Knowledge Base Loading with selective exclusions, and comprehensive quality validation frameworks ensuring authentic Amazon communication standards.

###### Architecture & Design

The architecture implements a session-aware coaching pattern with proactive context management and state preservation mechanisms preventing workflow interruption. The design employs a multi-modal coaching approach supporting different user experience levels through routing to specialized coaching paths based on initial assessment. The system uses mandatory knowledge loading protocols with intentional exclusions of WIP tasks and available knowledge bases to maintain clean coaching focus. The architectural pattern includes comprehensive state management through `working_backwards/current/` directory structure, enabling seamless session resumption and progress preservation. The design incorporates Amazon's authentic methodology frameworks with real examples and templates, ensuring professional-grade output quality through systematic validation and assessment protocols.

####### Implementation Approach

The implementation uses proactive context window monitoring with checkpoint validation at critical workflow stages, triggering graceful halt procedures at 80% capacity to preserve session state and enable seamless continuation. The approach employs systematic knowledge base loading following JESSE Framework protocols while intentionally excluding WIP task and available knowledge base context to maintain coaching focus. The system implements Amazon's complete 5-stage Working Backwards methodology with detailed coaching frameworks, customer research integration through MCP Perplexity calls, and comprehensive document creation using authentic Amazon templates. Quality assurance employs Amazon's top 10 writing guidelines with automated assessment tools including customer focus scoring, believability frameworks, and readability analysis ensuring professional document standards.

######## External Dependencies & Integration Points

**→ References:**
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - mandatory system rules and essential knowledge loading for coaching context
- `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` - accumulated project knowledge integration for coaching enhancement
- `working_backwards/current/` - dedicated directory structure for session state management and document preservation
- `MCP Perplexity` - external research integration for customer insights, market data, and competitive analysis
- `https://github.com/cline/cline` - Cline conversation system for session management and coaching delivery
- Amazon internal PR/FAQ examples - authentic templates and frameworks for professional document creation
- Amazon Working Backwards methodology - 5-stage customer-focused development process implementation

**← Referenced By:**
- Strategic planning workflows - processes requiring customer-focused vision document creation
- Product development teams - groups needing authentic Amazon-style PR/FAQ documents for stakeholder communication
- Project management systems - workflows incorporating Working Backwards methodology for customer-centric planning
- Knowledge management processes - systems capturing and preserving strategic planning insights and methodologies
- Stakeholder review processes - procedures requiring professional PR/FAQ documents for decision-making and approval

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive strategic planning coach implementing authentic Amazon Working Backwards methodology for creating professional customer-focused vision documents within the Jesse Framework MCP ecosystem
- **Ecosystem Position**: Specialized coaching workflow that operates independently of development tasks while integrating with knowledge management and session state preservation systems
- **Integration Pattern**: Used by product teams and strategic planners through direct workflow invocation, integrated with MCP Perplexity for external research, coordinated with Jesse Framework knowledge management for context loading, and designed for seamless session continuation across multiple coaching interactions

######### Edge Cases & Error Handling

The workflow handles context window exhaustion through proactive monitoring and graceful halt procedures, preserving all session state and enabling seamless resumption in fresh sessions. Missing or corrupted working backwards directory structures trigger automatic initialization with proper file creation and state management setup. Knowledge base loading failures provide fallback mechanisms while maintaining coaching functionality with reduced context. MCP Perplexity research failures continue coaching workflow while noting research limitations and providing alternative guidance approaches. User experience level mismatches are handled through dynamic routing and coaching approach adjustment based on demonstrated capability and needs. The system addresses incomplete Working Backwards stage completion through validation checkpoints and guided remediation before proceeding to subsequent stages.

########## Internal Implementation Details

The workflow uses bash scripting for working backwards directory initialization and state management, creating structured file organization for session preservation and progress tracking. Context monitoring employs percentage-based capacity assessment with checkpoint validation at critical workflow stages, implementing immediate state saving and session termination protocols when approaching limits. Knowledge base loading implements selective exclusion logic intentionally avoiding WIP task and available knowledge base context while maintaining essential system knowledge and working backwards context. Quality assessment employs multi-dimensional scoring systems including customer focus rating scales, believability assessment frameworks, and readability analysis tools ensuring professional document standards. Session resumption mechanisms reconstruct coaching context from preserved state files, enabling seamless continuation of complex multi-stage coaching processes.

########### Code Usage Examples

This example demonstrates the mandatory knowledge base loading protocol with selective exclusions for clean coaching context:

```bash
# Execute mandatory knowledge base loading with coaching-specific exclusions
# Load system rules and essential knowledge
cat .clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md
cat .knowledge/persistent-knowledge/KNOWLEDGE_BASE.md

# Load existing working backwards context if available
for file in working_backwards/current/*.md; do 
  if [ -f "$file" ]; then 
    echo "=== BEGIN FILE: $file ==="; 
    cat "$file"; 
    echo "=== END FILE: $file ==="; 
  fi; 
done

# Intentionally exclude WIP task and available KB context for clean coaching focus
```

This example shows the context window management protocol with graceful halt and state preservation:

```bash
# Context window monitoring and graceful halt procedure at 80% capacity
echo "## Coaching Session State - $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> working_backwards/current/coaching_session_state.md
echo "**Context Halt Triggered**: 80% capacity reached" >> working_backwards/current/coaching_session_state.md
echo "**Current Phase**: [Document current coaching phase]" >> working_backwards/current/coaching_session_state.md
echo "**Completed Stages**: [List completed stages]" >> working_backwards/current/coaching_session_state.md
echo "**Next Steps**: [Document specific next actions]" >> working_backwards/current/coaching_session_state.md
```

This example illustrates the Working Backwards Assessment implementation with Amazon's problem definition template:

```markdown
# Amazon's mandatory problem definition template for Stage 2 (DEFINE)
Today, [specific customer segment] have to [current limitation/friction/manual process] 
when [specific triggering situation]. 

This means [quantified impact/consequence for customer], making it difficult to 
[specific customer goal/desired outcome].

Customers need a way to [specific needed capability] so they can 
[desired business/personal result].

Supporting Evidence:
- Data Source 1: [Specific evidence with numbers - e.g., "73% of surveyed customers report..."]
- Data Source 2: [Quantified impact - e.g., "Average time spent is 45 minutes per task"]  
- Data Source 3: [Customer quotes - e.g., "As one customer told us, 'I waste 2 hours daily on...'"]
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_capture_our_chat.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `Capture Our Chat Workflow` for preserving complete conversation records between users and assistants within the Jesse Framework ecosystem, providing permanent markdown documentation of interactive sessions including code changes, task completions, and all conversational exchanges. The workflow delivers systematic conversation archival through trigger-based activation, structured content formatting, and timestamped file generation with write-only access patterns. Key semantic entities include the `capture our chat` trigger phrase, `.coding_assistant/captured_chats/` directory structure, `YYYYMMDD-HHmm` timestamp format specification, `snake_case` topic conversion algorithm, `YAML` code block formatting for user messages, markdown preservation for assistant responses, file path construction pattern `<project_root>/.coding_assistant/captured_chats/YYYYMMDD-HHmm-<Chat_topic_in_snake_case>.md`, structured file headers with date and topic metadata, conversation body chronological ordering, file footer with task completion results, recreation handling with progressive snapshots, and integration references to `JESSE_MARKDOWN.md` standards for file management and naming conventions. The system enables developers to maintain comprehensive conversation archives while ensuring ephemeral document handling and preventing context pollution through read-back restrictions.

##### Main Components

The workflow contains seven primary operational steps: chat topic identification through conversation analysis and `snake_case` conversion, timestamp generation using `YYYYMMDD-HHmm` format specification, file path construction with standardized directory structure, conversation content formatting with `YAML` blocks for user messages and markdown preservation for assistant responses, structured content organization including file headers with metadata and chronological conversation bodies, recreation handling with progressive snapshot creation for multiple captures, and confirmation response with file location and conversation metrics. Supporting components include implementation guidelines for file system operations and content completeness requirements, special considerations for ephemeral document handling and read-back restrictions, comprehensive error handling procedures for file writing failures, and example usage patterns demonstrating simple captures, contextual captures, and multiple capture scenarios.

###### Architecture & Design

The architecture implements a trigger-response workflow pattern with structured content preservation and write-only file access constraints. The design uses natural language trigger detection for workflow activation, systematic topic extraction and standardization through `snake_case` conversion, and hierarchical file organization under `.coding_assistant/captured_chats/` directory structure. The system employs template-based content formatting with distinct `YAML` blocks for user messages, standard markdown for assistant responses, and structured file organization with headers, conversation bodies, and completion footers. The workflow follows a progressive snapshot pattern enabling multiple captures within single conversations while preventing file overwrites through timestamp-based naming. The architecture includes ephemeral document handling with explicit read-back restrictions and comprehensive error handling for file system operations.

####### Implementation Approach

The implementation uses natural language trigger detection for `capture our chat` phrase recognition, automated topic extraction through conversation analysis with fallback to primary task identification, and standardized file naming through timestamp generation and `snake_case` topic conversion. The approach employs structured content formatting with `YAML` code blocks for user message highlighting, markdown preservation for assistant responses with syntax highlighting maintenance, and chronological conversation ordering with complete context preservation. File system operations implement directory creation with permission handling, atomic file writing with error recovery, and progressive snapshot management for multiple captures. The system uses template-driven content structure with standardized headers, conversation bodies, and completion footers while maintaining write-only access patterns and ephemeral document classification.

######## External Dependencies & Integration Points

**→ References:**
- `JESSE_MARKDOWN.md` - markdown file management standards and naming conventions for captured chat documentation
- `.coding_assistant/captured_chats/` directory - standardized location for conversation archive storage
- File system operations - directory creation, file writing, and permission management for conversation preservation
- Timestamp generation services - current time access for `YYYYMMDD-HHmm` format compliance
- Conversation context analysis - topic extraction and content formatting for structured documentation

**← Referenced By:**
- Development workflows - reference captured conversations for task context and implementation history
- Documentation processes - use conversation archives for project knowledge and decision tracking
- Quality assurance workflows - review captured chats for compliance verification and process improvement
- Training materials - leverage conversation examples for workflow demonstration and best practice illustration

**⚡ System role and ecosystem integration:**
- **System Role**: Auxiliary conversation archival workflow within the Jesse Framework development ecosystem, providing permanent record creation for interactive sessions and task completion documentation
- **Ecosystem Position**: Peripheral support tool enabling conversation preservation while maintaining strict write-only access patterns to prevent context pollution in ongoing development workflows
- **Integration Pattern**: Triggered by developers through natural language commands, consumes conversation context and file system services, produces structured markdown archives for reference without read-back integration into active workflows

######### Edge Cases & Error Handling

The workflow handles file writing failures through immediate user notification and alternative content display for manual saving when automated file creation fails. Directory creation issues are managed through permission validation and graceful error reporting with fallback instructions for manual directory setup. Multiple capture requests within single conversations trigger progressive snapshot creation with timestamp-based naming to prevent file overwrites while preserving conversation evolution. Topic extraction failures default to generic naming patterns with timestamp-based identification when conversation themes cannot be determined. File system permission errors provide clear guidance for access configuration and alternative storage locations. Network or system interruptions during capture operations implement recovery mechanisms with partial content preservation and retry capabilities for complete conversation archival.

########## Internal Implementation Details

The topic extraction algorithm analyzes initial user requests and conversation themes using keyword identification and context analysis with fallback to primary task or feature discussion topics. Timestamp generation uses system time at capture request moment with precise `YYYYMMDD-HHmm` format compliance and timezone handling for consistency. File path construction combines project root detection, standardized directory structure, timestamp formatting, and `snake_case` topic conversion with conflict resolution for existing files. Content formatting implements `YAML` code block wrapping for user messages, markdown preservation for assistant responses with syntax highlighting maintenance, and chronological ordering with complete context inclusion. File structure generation uses template processing with dynamic header insertion, conversation body assembly, and standardized footer completion with task result documentation. Recreation handling implements timestamp comparison and progressive file creation with unique naming to prevent overwrites while maintaining conversation continuity.

########### Code Usage Examples

This example demonstrates the basic workflow trigger and file path construction pattern. The standardized approach ensures consistent conversation archival with proper directory organization and timestamp-based naming.

```markdown
User: "Please capture our chat"
Assistant: ✅ Chat captured successfully!
📄 File: <project_root>/.coding_assistant/captured_chats/20250624-1430-feature_development.md
📝 Topic: Feature Development Discussion
💾 Size: Approximately 150 exchanges
```

This example shows the structured content formatting with YAML blocks for user messages and markdown preservation for assistant responses. The formatting ensures clear conversation distinction while maintaining code block integrity.

```yaml
User: We need to implement authentication for the new API endpoint
```

This example demonstrates assistant response formatting with embedded code blocks. The markdown structure preserves syntax highlighting while maintaining conversation flow and technical content integrity.

```markdown
I'll help you implement authentication for the API endpoint. Let's start by analyzing the current authentication system and then create the necessary middleware.
```

```python
def authenticate_request(request):
    token = request.headers.get('Authorization')
    if not token:
        raise AuthenticationError("Missing authorization token")
    return validate_token(token)
```

This example illustrates the progressive snapshot handling for multiple captures within single conversations. The timestamp-based naming prevents overwrites while preserving conversation evolution and enabling historical reference.

```markdown
# First capture at 14:30
File: 20250624-1430-authentication_implementation.md

# Second capture at 15:45 (same conversation)
File: 20250624-1545-authentication_implementation.md

# Both files preserved with complete conversation history up to capture point
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_do_your_magic.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `Jesse Do Your Magic` workflow for performing deep-dive compliance analysis on code files within the Jesse Framework ecosystem, providing automated verification of adherence to project standards, documentation requirements, and architectural principles. The workflow delivers systematic code quality assessment through structured analysis phases including documentation standards verification, code quality evaluation, and reference validation. Key semantic entities include the `Do your magic` trigger phrase, `MAGIC MODE` activation response, `COMPLIANCE ANALYSIS` structured output format, `VSCode` editor integration for scope determination, documentation standards references to `JESSE_CODE_COMMENTS.md`, `JESSE_CODE_GENERATION.md`, `JESSE_MARKDOWN.md`, and `JESSE_SCRATCHPAD.md`, priority-based findings classification (`Critical Issues`, `High Priority`, `Medium Priority`, `Low Priority`), remediation plan generation with user confirmation requirements, and integration with operational modes including `PLAN mode` and `DESIGN mode`. The system enables developers to maintain code quality consistency across the project through automated analysis workflows triggered by natural language commands.

##### Main Components

The workflow contains six primary operational sections: trigger detection mechanism responding to `Do your magic` command variations, scope determination logic supporting default VSCode visible files and custom file/directory specifications, five-step workflow execution including magic mode initiation, compliance analysis performance, findings presentation, and remediation planning, three-component analysis framework covering documentation standards checking, code quality analysis, and reference validation, implementation guidelines specifying analysis depth requirements and communication protocols, and integration specifications with existing operational modes and project standards. The workflow supports flexible scope targeting from single files to directory-wide analysis with structured output formatting and user confirmation requirements for remediation actions.

###### Architecture & Design

The architecture implements a trigger-response workflow pattern with structured analysis phases and priority-based output organization. The design uses command-pattern activation through natural language trigger detection, scope-flexible analysis supporting both default editor context and explicit file/directory targeting, and hierarchical analysis framework with three specialized components for comprehensive code evaluation. The system employs structured output formatting with consistent analysis reporting templates, priority-based findings classification enabling focused remediation efforts, and integration-aware design respecting existing operational mode constraints. The workflow follows a confirmation-required remediation pattern preventing automatic code modifications without explicit user approval, ensuring safe operation within development environments.

####### Implementation Approach

The implementation uses natural language trigger detection for workflow activation, context-aware scope determination leveraging VSCode editor state for default targeting, and systematic analysis execution through predefined evaluation criteria. The approach employs template-based output formatting with structured analysis reporting including specific line references and concrete examples, priority-based findings organization enabling efficient issue triage, and comprehensive standards validation against multiple project documentation sources. The system implements confirmation-gated remediation with explicit user approval requirements, multi-mode integration supporting workflow execution within existing operational constraints, and iterative analysis capabilities allowing re-verification of implemented fixes.

######## External Dependencies & Integration Points

**→ References:**
- `JESSE_CODE_COMMENTS.md` - code documentation standards and file header requirements for compliance verification
- `JESSE_CODE_GENERATION.md` - code generation standards and best practices for quality assessment
- `JESSE_MARKDOWN.md` - markdown formatting standards for documentation validation
- `JESSE_SCRATCHPAD.md` - scratchpad usage standards and reference validation rules
- `VSCode` editor integration - visible file detection and scope determination for default analysis targeting

**← Referenced By:**
- Development workflows - consume compliance analysis results for code quality maintenance
- Code review processes - integrate findings for systematic quality assessment
- Project maintenance activities - use remediation plans for systematic improvement efforts
- Quality assurance workflows - leverage analysis results for standards compliance verification

**⚡ System role and ecosystem integration:**
- **System Role**: Core quality assurance workflow within the Jesse Framework development ecosystem, providing automated compliance verification and remediation guidance for maintaining project standards consistency
- **Ecosystem Position**: Central development support tool integrating with editor environments and project documentation standards to enable systematic code quality maintenance
- **Integration Pattern**: Triggered by developers through natural language commands, consumes project standards documentation, and produces structured analysis reports with actionable remediation guidance

######### Edge Cases & Error Handling

The workflow handles scope determination failures by defaulting to currently visible VSCode files when custom scope specifications are invalid or inaccessible. Missing or outdated project standards documentation is addressed through graceful degradation with warnings about incomplete analysis coverage. Complex remediation scenarios trigger automatic escalation to `PLAN mode` for structured implementation planning when fixes require significant architectural changes. Analysis depth limitations are managed through clear communication about scope boundaries and analysis coverage when dealing with large directory structures or complex codebases. Integration conflicts with active operational modes are resolved through mode-aware execution that respects existing constraints while providing maximum analysis value within operational boundaries.

########## Internal Implementation Details

The trigger detection mechanism uses exact phrase matching for `Do your magic` with case-insensitive processing and support for scope specification parsing following the command. Scope determination logic implements fallback hierarchy from explicit file/directory specifications to VSCode visible files to current working directory when no context is available. Analysis execution follows structured template processing with line-specific reference generation, concrete example extraction, and priority classification based on predefined severity criteria. Output formatting uses consistent markdown structure with code block formatting for examples and structured lists for findings organization. Remediation planning employs complexity estimation algorithms and related fix grouping for efficient implementation workflows. Mode integration uses conditional execution paths that adapt workflow behavior based on active operational constraints while maintaining core analysis functionality.

########### Code Usage Examples

This example demonstrates the basic workflow trigger and response pattern for single file analysis. The structured output format provides consistent analysis reporting with clear status indicators and systematic evaluation criteria.

```
User: "Do your magic"
Assistant: ENTERING MAGIC MODE 😉! Performing deep-dive analysis on system prompt...

[COMPLIANCE ANALYSIS: current_file.py]
- Checking strict respect to documentation standards...
- Analyzing code structure against design principles...
- Verifying documentation references relevance...
```

This example shows custom scope specification for directory-wide analysis with structured findings presentation. The priority-based classification enables efficient issue triage and focused remediation efforts.

```
User: "Do your magic src/components/"
Assistant: [Analyzes all files in src/components/ directory]

Critical Issues:
- Missing file headers in 3 files (lines: src/components/auth.py:1)
- Violated design principles in authentication logic

High Priority:
- Misaligned function intents in user management module
- Complex code sections exceeding cyclomatic complexity thresholds
```

This example illustrates the remediation confirmation workflow with priority-based action planning. The confirmation-gated approach ensures safe operation by requiring explicit user approval before implementing any code modifications.

```
Remediation Plan:
1. Critical: Add missing file headers (Est: 30 min)
2. High: Refactor complex authentication logic (Est: 2 hours)
3. Medium: Update outdated dependency references (Est: 45 min)

CRITICAL: Do you want me to implement these recommendations? [Awaiting confirmation]
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_framework_upgrade.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow documentation provides a comprehensive framework upgrade system for the JESSE AI Best Practices Framework, designed to safely update framework installations while preserving user data and maintaining operational continuity. The system delivers temporary `WIP task loading` disablement for clean upgrade environments, automated framework installation execution through the documented `README.md` process, and session-scoped context management preventing upgrade interference. Key semantic entities include `WIP task auto-loading` session flag management, `${HOME}/Cline/Rules/` global installation paths, `.clinerules/` project-level installation directories, `JESSE_*.md` framework file updates, `https://github.com/jcjorel/jesse-ai-best-practices` repository integration, `/jesse_wip_task_new_session.md` post-upgrade initialization, `/jesse_framework_upgrade.md` workflow invocation, `AI-guided installation process` execution, `knowledge management system` preservation, and comprehensive upgrade verification procedures ensuring framework functionality and data integrity across both global and project-level installations.

##### Main Components

The workflow contains five sequential steps forming the complete upgrade process: WIP task loading disablement, user confirmation procedures, framework upgrade execution, upgrade verification protocols, and session restart recommendations. Primary components include session-only flag creation for WIP task context isolation, user confirmation dialogs with explicit upgrade intentions, automated installation command execution referencing the official GitHub repository, post-installation verification checks covering framework files and functionality, and comprehensive user guidance for session restoration. The workflow incorporates implementation notes covering upgrade safety principles, installation process integration details, context management strategies, and post-upgrade behavior specifications.

###### Architecture & Design

The architecture implements a non-destructive upgrade pattern with session-scoped context isolation and incremental framework updates. The design employs temporary WIP task disablement to prevent context confusion during upgrade operations, while maintaining all persistent data structures including knowledge bases, task histories, and user configurations. The system uses the documented AI-guided installation process as the core upgrade mechanism, leveraging existing framework installation procedures for consistency and reliability. The architectural pattern includes comprehensive verification loops ensuring successful upgrade completion and proper framework functionality restoration.

####### Implementation Approach

The implementation uses session-scoped flag management to temporarily disable WIP task auto-loading without modifying persistent configuration files. The approach employs direct execution of the documented installation command from the framework README, triggering the AI-guided installation process that handles both global and project-level installations appropriately. The system implements comprehensive verification procedures checking framework file updates, workflow accessibility, knowledge management system functionality, and basic framework operations. Post-upgrade procedures include explicit user guidance for session restart and WIP task context restoration through complementary workflows.

######## External Dependencies & Integration Points

**→ References:**
- `https://github.com/jcjorel/jesse-ai-best-practices` - official JESSE AI Framework repository for installation and updates
- `README.md` - framework installation documentation containing AI-guided installation process
- `${HOME}/Cline/Rules/` - global framework installation directory for system-wide framework files
- `.clinerules/` - project-level framework installation directory for project-specific configurations
- `JESSE_*.md` - framework files updated during upgrade process including workflows and templates
- `/jesse_wip_task_disable.md` - WIP task disablement mechanism used for upgrade context isolation
- `/jesse_wip_task_new_session.md` - post-upgrade initialization workflow for session restoration

**← Referenced By:**
- Cline AI development sessions - primary consumers executing framework upgrades through workflow invocation
- Framework maintenance procedures - automated or manual processes triggering framework updates
- Development team workflows - team procedures incorporating framework upgrade cycles
- Project initialization scripts - setup procedures that may include framework upgrade verification
- Troubleshooting documentation - support procedures referencing upgrade workflow for issue resolution

**⚡ System role and ecosystem integration:**
- **System Role**: Critical maintenance workflow for the JESSE AI Framework ecosystem, providing safe and reliable framework upgrade capabilities while preserving user data and operational continuity
- **Ecosystem Position**: Central infrastructure component that bridges framework development and user installations, ensuring consistent framework updates across global and project-level deployments
- **Integration Pattern**: Used by developers and AI assistants through direct workflow invocation, integrated with framework installation processes through GitHub repository references, and coordinated with session management workflows for complete upgrade cycles

######### Edge Cases & Error Handling

The workflow handles upgrade failures by providing specific error guidance and retry mechanisms without permanent changes to user configurations. Installation process failures preserve all user data and allow multiple upgrade attempts without data loss or configuration corruption. Missing or inaccessible framework repository scenarios provide fallback guidance and alternative installation approaches. The system addresses scenarios where WIP task context conflicts with upgrade operations by maintaining session-scoped isolation without affecting persistent task data. Error handling includes verification failures where framework files are not properly updated, requiring manual intervention or alternative installation methods. The workflow manages cases where user customizations conflict with framework updates, preserving user modifications while updating core framework components.

########## Internal Implementation Details

The workflow uses session-scoped flag mechanisms that create temporary variables preventing WIP task auto-loading without modifying persistent configuration files or user data structures. Upgrade execution leverages the documented AI-guided installation process from the framework README, ensuring consistency with official installation procedures and handling both global and project-level installation scenarios. Verification procedures implement comprehensive checks across framework files, workflow accessibility, knowledge management system functionality, and basic framework operations to ensure successful upgrade completion. Post-upgrade guidance includes specific instructions for session restart and WIP task context restoration, maintaining operational continuity while ensuring framework updates are properly integrated.

########### Code Usage Examples

This example demonstrates the basic framework upgrade invocation that initiates the complete upgrade process with user confirmation:

```bash
# Execute framework upgrade workflow with automatic WIP task isolation
User: /jesse_framework_upgrade.md
# System disables WIP task loading, confirms upgrade intention, executes installation
```

This example shows the complete upgrade cycle including post-upgrade session restoration for full operational continuity:

```bash
# Complete framework upgrade with session restoration workflow
User: /jesse_framework_upgrade.md
# AI confirms upgrade, disables WIP, executes installation from GitHub repository
# User starts new session after upgrade completion
User: /jesse_wip_task_new_session.md
# System restores WIP task context and verifies framework functionality
```

This example illustrates troubleshooting upgrade scenarios with retry mechanisms and error handling:

```bash
# Handle upgrade failures with retry and error resolution
User: /jesse_framework_upgrade.md
# AI attempts upgrade, encounters installation error, provides specific guidance
# User addresses specific issues (network, permissions, repository access)
User: /jesse_framework_upgrade.md
# System retries upgrade with resolved conditions
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_kb_git_clone_import.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `WIP Task Add Git Clone Workflow` for integrating external git repositories into the Jesse Framework's knowledge management system, providing structured documentation and automated processing of external codebases for reference and analysis. The workflow delivers systematic repository integration through nine execution steps including repository information gathering, standardized naming conventions, git clone operations, and knowledge base file generation. Key semantic entities include the `.knowledge/git-clones/` directory structure, `Perplexity MCP server` integration for repository research, standardized `[repo-name]_kb.md` knowledge base file format, `.knowledge/git-clones/README.md` index management, `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` essential knowledge base updates, large file processing thresholds at 4000 lines, `ISO timestamp` formatting, repository URL parsing with `https` and `ssh` protocol support, and integration with `/jesse_wip_task_process_large_file.md` workflow for detailed file processing. The system enables developers to systematically capture and organize external repository knowledge while maintaining security considerations and structured documentation standards.

##### Main Components

The workflow contains nine primary execution steps: repository information gathering with URL, purpose, key areas, and integration context collection; standardized repository name generation with lowercase underscore conversion; git clone operation to `.knowledge/git-clones/[repo-name]/` directory; Perplexity MCP server research for repository overview and architectural analysis; repository structure analysis identifying directories, key files, large files, documentation, and patterns; knowledge base file creation with structured markdown template; git clones index updates in `.knowledge/git-clones/README.md`; essential knowledge base updates in `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md`; and large file processing coordination for files exceeding 4000 lines. Supporting components include repository analysis guidelines for directory mapping and file significance assessment, workflow completion verification steps, comprehensive error handling procedures, security considerations for trusted source validation, and post-addition action recommendations.

###### Architecture & Design

The architecture implements a multi-phase integration workflow with structured knowledge capture and systematic documentation generation. The design uses standardized directory organization under `.knowledge/git-clones/` with consistent naming conventions, template-based knowledge base file generation following structured markdown format, and centralized index management for repository tracking. The system employs external research integration through Perplexity MCP server for automated repository analysis, hierarchical knowledge organization with directory structure mapping and file significance assessment, and threshold-based large file identification for specialized processing workflows. The workflow follows a verification-driven completion pattern with multiple checkpoint validations and comprehensive error handling for network connectivity, authentication, and repository size constraints.

####### Implementation Approach

The implementation uses automated repository name standardization through URL parsing and character conversion algorithms, git clone operations with directory structure validation and size checking, and external research integration through Perplexity MCP server queries for repository purpose and architectural analysis. The approach employs template-driven knowledge base file generation with structured markdown sections for repository overview, directory structure, usage knowledge, and large file identification. Repository analysis follows systematic directory mapping with purpose identification, key file documentation, and pattern recognition for architectural approaches. The system implements cascading index updates across multiple knowledge management files and provides threshold-based large file processing with priority assignment and access pattern documentation.

######## External Dependencies & Integration Points

**→ References:**
- `Perplexity MCP server` - external research service for repository analysis and architectural information gathering
- `git` command-line tool - repository cloning operations and version control functionality
- `.knowledge/git-clones/README.md` - centralized index file for repository tracking and management
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - essential knowledge base requiring updates for new repositories
- `/jesse_wip_task_process_large_file.md` - specialized workflow for processing files exceeding 4000 lines
- External git repositories - source repositories accessed via `https` and `ssh` protocols

**← Referenced By:**
- Knowledge management workflows - consume structured repository documentation for reference and analysis
- Large file processing workflows - use repository analysis results for targeted file processing
- Development workflows - reference cloned repositories and generated knowledge base files
- Security review processes - validate repository integration and access patterns

**⚡ System role and ecosystem integration:**
- **System Role**: Core repository integration workflow within the Jesse Framework knowledge management ecosystem, providing systematic external codebase capture and documentation generation
- **Ecosystem Position**: Central knowledge acquisition component bridging external repositories with internal knowledge management systems through structured documentation and analysis
- **Integration Pattern**: Triggered by developers for repository integration, consumes external research services and git operations, produces structured knowledge base files and index updates for consumption by knowledge management workflows

######### Edge Cases & Error Handling

The workflow handles git clone failures through URL verification and network connectivity validation with fallback options for authentication issues and repository access restrictions. Repository size constraints are managed through shallow clone options and branch-specific cloning when repositories exceed reasonable processing limits. Perplexity research failures trigger graceful degradation to manual analysis with preserved clone operations and retry documentation generation. Knowledge base creation failures preserve successful clone operations and enable retry mechanisms for documentation generation. Authentication requirements are handled through user guidance for credential configuration and access token management. Network connectivity issues provide clear error messaging and retry instructions with offline processing capabilities for previously cloned repositories.

########## Internal Implementation Details

The repository name generation algorithm extracts repository names from URLs using pattern matching and applies lowercase conversion with underscore substitution for special characters and conflict resolution with existing clones. Git clone operations target specific directory structures under `.knowledge/git-clones/` with verification of successful completion and repository integrity checking. Perplexity MCP server integration uses structured query templates for repository research with fallback handling for service unavailability. Knowledge base file generation follows template processing with dynamic content insertion and structured markdown formatting. Index management implements atomic updates with backup preservation and rollback capabilities for failed operations. Large file identification uses line counting algorithms with configurable thresholds and priority assignment based on file types and relevance scoring.

########### Code Usage Examples

This example demonstrates the basic workflow initiation and repository information gathering process. The structured approach ensures comprehensive repository integration with proper documentation and knowledge capture.

```markdown
Repository URL: https://github.com/user/example-repo
Repository Purpose: Reference implementation for authentication patterns
Key Areas of Interest: /src/auth/, /docs/security/, configuration files
Integration Context: Studying OAuth2 implementation patterns for current project
```

This example shows the standardized knowledge base file structure generated for each repository. The template provides consistent documentation format enabling systematic repository analysis and reference.

```markdown
# Git Clone Knowledge Base: Example Repo
*Last Updated: 2024-01-15T10:30:00Z*

## Repository Overview
**Purpose**: Authentication library with OAuth2 implementation
**Language**: Python
**License**: MIT
**Last Activity**: Active development with recent commits
**Clone URL**: https://github.com/user/example-repo

## Directory Structure
### src/auth/
**Purpose**: Core authentication modules and OAuth2 implementation
**Key Files**:
- `oauth2_client.py`: OAuth2 client implementation with token management
- `auth_middleware.py`: Authentication middleware for request processing
**Patterns**: Factory pattern for auth provider instantiation
```

This example illustrates the large file processing identification and priority assignment system. The structured approach enables efficient processing of complex repositories with size-based file categorization.

```markdown
## Large Files Requiring Processing
### auth_service.py (4500 lines)
**Purpose**: Comprehensive authentication service implementation
**Priority**: High - directly relevant to current authentication work
**Access Pattern**: Process in 500-line chunks focusing on OAuth2 sections
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_kb_pdf_import.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow specification defines a comprehensive PDF import and indexing system for the Jesse Framework's knowledge base, utilizing LLM-based visual understanding to create searchable, chunked PDF repositories. The functional intent centers on providing developers with a robust, resumable PDF processing pipeline that eliminates external OCR dependencies while maintaining precise page-to-chunk mapping for accurate content retrieval. Key semantic entities include `PyPDF2` for PDF manipulation, `.knowledge/pdf-knowledge/` directory structure for organized storage, `import_progress.json` for session state management, `PdfReader` and `PdfWriter` classes for chunking operations, `snake_case` filename sanitization, and mandatory page reference enforcement with `(chunk: filename.pdf)` notation. The workflow provides automatic WIP task disabling, multi-session resumability, context window monitoring, and comprehensive error handling to ensure reliable processing of large PDF documents across multiple Cline sessions.

##### Main Components

The workflow contains eleven primary execution steps: Check for Existing Import Session, Gather PDF Information, Validate PDF File, Initialize Import Session, Generate Directory Structure, Copy Original PDF, Execute PDF Chunking, Initialize or Load Knowledge Base File, Process Chunks with LLM, Generate Cross-References, and Finalize Import. Additional components include Session Initialization Override for WIP task disabling, Session Handoff Protocol for context window management, Multi-Session Coordination for state persistence, and comprehensive Error Handling for resumable and critical failures. The workflow integrates an embedded Python chunking script with resumable capabilities and enforces strict page reference compliance throughout the knowledge base creation process.

###### Architecture & Design

The architectural design implements a multi-session, resumable processing pattern with fail-safe state management and atomic progress tracking. The workflow separates concerns between PDF chunking operations, LLM-based content analysis, and knowledge base construction, enabling independent recovery from failures at each stage. The design utilizes file-based state persistence through `import_progress.json` and incremental knowledge base updates, ensuring no in-memory dependencies between sessions. Session handoff mechanisms monitor context window usage and provide clean transition points, while the page reference enforcement system maintains precise chunk-to-content mapping throughout the entire process.

####### Implementation Approach

The implementation strategy combines Python-based PDF processing with LLM vision analysis in a resumable pipeline architecture. The embedded Python script utilizes `PyPDF2` for chunk creation with automatic resume detection through existing file enumeration, while progress tracking employs JSON-based state files with timestamp management. Content analysis follows a chunk-by-chunk approach with context window monitoring, implementing automatic session handoff when usage exceeds 80%. The page reference enforcement mechanism requires immediate chunk filename annotation for every page number mention, ensuring precise content retrieval through standardized `(chunk: filename.pdf)` notation.

######## External Dependencies & Integration Points

**→ References:** [external systems and tools this workflow depends on]
- `PyPDF2` (external library) - PDF reading, writing, and manipulation operations
- `Python 3.11+` - runtime environment for embedded chunking script
- `.knowledge/pdf-knowledge/` - knowledge base storage directory structure
- `import_progress.json` - session state and progress tracking file
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - Essential Knowledge Base integration
- LLM vision capabilities - content analysis and understanding

**← Referenced By:** [systems that invoke or consume this workflow]
- Jesse Framework task management system - workflow execution trigger
- Cline session management - multi-session coordination and resumption
- Knowledge base search system - indexed PDF content consumption
- Developer workflow automation - PDF processing pipeline integration

**⚡ System role and ecosystem integration:**
- **System Role**: Serves as the primary PDF ingestion pipeline within the Jesse Framework knowledge management system, coordinating file processing with LLM-based content understanding
- **Ecosystem Position**: Core component bridging external PDF documents with searchable knowledge base infrastructure, enabling document-aware development workflows
- **Integration Pattern**: Invoked by developers through workflow commands with dependencies on Python runtime, file system access, and LLM vision capabilities for comprehensive PDF processing and indexing

######### Edge Cases & Error Handling

The workflow addresses multiple critical error scenarios including context window limit handling with automatic session handoff and progress preservation, chunk read failures with skip-and-continue logic, temporary LLM errors with retry mechanisms up to three attempts, and PDF corruption detection with partial import preservation. Critical error handling covers disk space issues with pause-and-intervention protocols, invalid PDF structure reporting with attempted partial imports, and file integrity validation using SHA256 hash verification. The resumable error system maintains state consistency through atomic progress updates, while multi-session coordination handles interrupted processing through comprehensive state restoration and validation mechanisms.

########## Internal Implementation Details

The internal implementation relies on file-based state management through JSON progress tracking with automatic timestamp updates, directory traversal algorithms for existing chunk detection and resume capability, and atomic file operations for chunk creation with integrity verification. The workflow maintains internal chunk mapping tables correlating page ranges with generated filenames, implements context window usage monitoring with percentage-based thresholds, and utilizes structured error reporting with specific resolution guidance. Session coordination employs state file locking mechanisms, progress validation through file existence checks, and comprehensive logging for debugging and maintenance operations across multiple processing sessions.

########### Code Usage Examples

The following examples demonstrate key workflow operations and integration patterns. PDF chunking script execution with resumable capability:

```python
# Embedded Python script for resumable PDF chunking
chunks, progress = chunk_pdf_resumable(input_pdf, output_dir)
print(f"Chunking complete: {len(chunks)} total chunks")
```

Progress tracking structure for multi-session coordination:

```json
{
  "pdf_path": "/path/to/original.pdf",
  "snake_case_name": "technical_manual",
  "total_pages": 1000,
  "chunks_processed": 25,
  "chunks_analyzed": 20,
  "status": "analyzing"
}
```

Page reference enforcement with mandatory chunk filename notation:

```markdown
# Knowledge base content with enforced chunk references
The authentication process on page 45 (chunk: manual_pages_041_060.pdf) describes the security protocols, while configuration details on pages 156-162 (chunks: manual_pages_141_160.pdf, manual_pages_161_180.pdf) provide implementation guidance.
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_archive.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `WIP Task Archive Workflow` for preserving incomplete Work-in-Progress tasks while removing them from active task management within the Jesse Framework ecosystem, providing structured archival with optional knowledge extraction and metadata preservation. The workflow delivers systematic task archival through nine execution steps including task selection, optional learning extraction, timestamped archive creation, and knowledge base updates. Key semantic entities include `.knowledge/work-in-progress/` directory structure with `_archived/` subdirectory organization, timestamped archive naming pattern `[task_name]_archived_[YYYYMMDD_HHMMSS]`, `ARCHIVE_INFO.md` metadata template with structured archive information, `WIP_TASK.md` and `PROGRESS.md` file preservation, `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` integration for learning extraction, `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` active task management, `intemporal writing` format for extracted learnings, `ISO timestamp` formatting for archive dates, read-only archive access patterns, rollback options for failed operations, and post-archive workflow suggestions including task creation and switching capabilities. The system enables developers to maintain organized task management while preserving valuable work context and enabling future reference access to incomplete tasks.

##### Main Components

The workflow contains nine primary execution steps: available task listing from `.knowledge/work-in-progress/` with status and metadata display, user task selection with archival confirmation and warning presentation, optional valuable learning extraction with persistent knowledge integration, timestamped archive directory creation in `_archived/` location, complete task file transfer with verification and cleanup, archive metadata generation using `ARCHIVE_INFO.md` template, Essential Knowledge Base updates for active task management, knowledge reference cleanup for consistency maintenance, and archive confirmation display with next action suggestions. Supporting components include archive information template specification with structured metadata fields, workflow completion verification procedures, comprehensive error handling for operation failures, special case management for active tasks and incomplete files, post-archive option presentation, and archive access documentation ensuring read-only reference availability with restoration possibilities.

###### Architecture & Design

The architecture implements a preservation-focused archival pattern with structured metadata generation and optional knowledge extraction capabilities. The design uses timestamped directory organization for conflict prevention, complete file preservation with verification protocols, and optional learning extraction with persistent knowledge integration. The system employs structured metadata templates for archive documentation, active task management integration for session state updates, and comprehensive error handling with rollback capabilities. The workflow follows a preservation-first approach ensuring no data loss during archival operations while maintaining knowledge consistency through reference cleanup and cross-reference validation across multiple knowledge storage locations.

####### Implementation Approach

The implementation uses directory scanning algorithms for task discovery with metadata extraction from `WIP_TASK.md` and `PROGRESS.md` files, timestamped naming generation with conflict resolution for unique archive identification, and optional knowledge extraction using `intemporal writing` format conversion for persistent storage. The approach employs complete file transfer operations with verification protocols, structured metadata generation using template processing with dynamic content insertion, and active task management updates through Essential Knowledge Base modification. Archive operations implement atomic file movement with rollback capabilities, knowledge reference scanning with cleanup protocols, and comprehensive verification procedures ensuring successful archival completion before confirmation display.

######## External Dependencies & Integration Points

**→ References:**
- `.knowledge/work-in-progress/` directory - active task storage requiring scanning and archival source operations
- `.knowledge/work-in-progress/_archived/` directory - archive destination requiring timestamped directory creation
- `WIP_TASK.md` and `PROGRESS.md` files - task documentation requiring preservation and metadata extraction
- `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` - persistent knowledge repository for optional learning extraction
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - Essential Knowledge Base requiring active task management updates
- `ARCHIVE_INFO.md` template - structured metadata format for archive documentation generation

**← Referenced By:**
- Task management workflows - consume archival services for incomplete task preservation and organization
- Knowledge management workflows - reference archived tasks for historical context and learning extraction
- Development workflows - access archived task information for project continuity and reference purposes
- Session management workflows - use archive operations for active task state transitions and cleanup

**⚡ System role and ecosystem integration:**
- **System Role**: Core task lifecycle management workflow within the Jesse Framework knowledge management ecosystem, serving as the primary mechanism for preserving incomplete work while maintaining organized active task management
- **Ecosystem Position**: Central task management component bridging active work-in-progress operations with long-term knowledge preservation through structured archival and optional learning extraction
- **Integration Pattern**: Invoked by developers for task lifecycle management, consumes task storage directories and knowledge bases, produces archived task collections with metadata for future reference and potential restoration

######### Edge Cases & Error Handling

The workflow handles non-existent WIP tasks by informing users and suggesting task creation workflows for proper task management initialization. Corrupted or missing task files trigger graceful handling with cleanup options and reference validation for consistency maintenance. Archive operation failures preserve tasks in original locations with rollback capabilities and detailed error reporting for resolution guidance. Essential Knowledge Base update failures restore previous active task states with transaction-like error recovery. Incomplete task files with missing `PROGRESS.md` or `WIP_TASK.md` receive graceful handling with partial archival and metadata generation. Large tasks with multiple files and subdirectories implement comprehensive transfer verification with progress tracking and failure recovery mechanisms.

########## Internal Implementation Details

The task listing mechanism scans `.knowledge/work-in-progress/` directory excluding `_archived/` subdirectory with metadata extraction from task files and status determination. Archive directory naming uses timestamp generation with `YYYYMMDD_HHMMSS` format and conflict resolution algorithms for unique identification. Learning extraction implements content analysis with `intemporal writing` conversion and structured insertion into persistent knowledge storage. File transfer operations use atomic movement with verification protocols and rollback capabilities for operation integrity. Metadata generation employs template processing with dynamic content insertion including archive dates, reasons, progress summaries, and file inventories. Knowledge reference cleanup uses scanning algorithms with pattern matching and cross-reference validation across multiple knowledge storage locations for consistency maintenance.

########### Code Usage Examples

This example demonstrates task listing and selection for archival operations. The structured approach provides comprehensive task information enabling informed archival decisions with status and metadata display.

```bash
# List available WIP tasks for archival with metadata extraction
ls -la .knowledge/work-in-progress/ | grep -v _archived
# Display task status and last updated information for selection
```

This example shows timestamped archive directory creation with conflict resolution. The naming pattern ensures unique archive identification while preserving chronological organization for future reference.

```bash
# Create timestamped archive directory with conflict prevention
mkdir -p ".knowledge/work-in-progress/_archived/task_name_archived_$(date +%Y%m%d_%H%M%S)"
```

This example illustrates complete task file transfer with verification protocols. The atomic operation ensures data integrity during archival with comprehensive file preservation and cleanup verification.

```bash
# Move task directory to archive location with verification
mv ".knowledge/work-in-progress/task_name" ".knowledge/work-in-progress/_archived/task_name_archived_20240115_143000/"
# Verify all files transferred successfully
ls -la ".knowledge/work-in-progress/_archived/task_name_archived_20240115_143000/"
```

This example demonstrates the structured archive metadata template for comprehensive task preservation. The template ensures consistent documentation with detailed context preservation for future reference and potential restoration.

```markdown
# Archive Information: Authentication System Implementation

## Archive Details
**Archived Date**: 2024-01-15T14:30:00Z
**Archive Reason**: Superseded by new authentication approach
**Final Status**: 60% complete - core implementation finished
**Progress at Archive**: 60%

## Original Task Information
**Started**: 2024-01-10T09:00:00Z
**Target Completion**: 2024-01-20T17:00:00Z
**Priority**: High
**Objective**: Implement OAuth2 authentication system for API endpoints

## Archive Summary
**Key Achievements**: OAuth2 flow implementation, token validation middleware
**Remaining Work**: Integration testing, error handling, documentation
**Learnings Extracted**: Yes - OAuth2 patterns added to persistent knowledge

## Access Information
**Original Location**: `.knowledge/work-in-progress/auth_system_implementation/`
**Archive Location**: `.knowledge/work-in-progress/_archived/auth_system_implementation_archived_20240115_143000/`
**Files Preserved**: WIP_TASK.md, PROGRESS.md, oauth_implementation.py, test_cases.md
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_capture_knowledge.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `WIP Task Knowledge Capture Workflow` for systematically capturing and structuring knowledge from various sources within the Jesse Framework ecosystem, providing organized storage for both task-specific and persistent knowledge management. The workflow delivers structured knowledge capture through six knowledge type classifications, dual storage location management, and comprehensive information gathering protocols with `intemporal writing` format conversion. Key semantic entities include knowledge type categories (`Perplexity Query Result`, `Web Resource`, `Pattern/Solution`, `API Knowledge`, `Discovery`, `Tool/Resource`), storage location options (`WIP Task Specific`, `Persistent Knowledge`, `Both`), structured information templates for each knowledge type, `intemporal writing` guidelines requiring present tense factual statements, file update targets including `WIP_TASK.md` and `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md`, knowledge consistency verification protocols, timestamp update requirements for `Last Updated` fields, automatic capture triggers (`remember this`, `capture this knowledge`, `save this information`, `document this finding`), and integration with `Perplexity MCP server` for query result processing. The system enables developers to maintain comprehensive knowledge repositories while ensuring consistency, accessibility, and structured organization across both immediate task context and long-term project knowledge bases.

##### Main Components

The workflow contains seven primary execution steps: knowledge type identification with six distinct categories for different information sources, storage location determination supporting task-specific and persistent knowledge options, structured information gathering with specialized templates for each knowledge type, intemporal writing format conversion ensuring present tense factual representation, appropriate file updates targeting `WIP_TASK.md` and `KNOWLEDGE_BASE.md`, knowledge consistency verification preventing contradictions, and timestamp update maintenance for modified files. Supporting components include knowledge quality standards specifying intemporal writing guidelines and completeness criteria, workflow completion verification procedures, comprehensive error handling for conflicts and failures, and automatic capture trigger recognition for natural language activation phrases enabling seamless knowledge capture integration into development workflows.

###### Architecture & Design

The architecture implements a dual-storage knowledge management pattern with structured categorization and format standardization across both task-specific and persistent knowledge repositories. The design uses knowledge type classification for appropriate template selection, storage location determination based on knowledge scope and applicability, and structured information gathering through specialized templates ensuring comprehensive capture. The system employs intemporal writing conversion for consistent knowledge representation, dual-target file update mechanisms supporting both immediate task context and long-term knowledge persistence, and consistency verification protocols maintaining single source of truth principles. The workflow follows an automatic trigger activation pattern enabling natural language knowledge capture integration while maintaining structured organization and format compliance.

####### Implementation Approach

The implementation uses knowledge type classification algorithms for appropriate template selection and information gathering, structured template processing for comprehensive knowledge capture across six distinct categories, and intemporal writing conversion ensuring present tense factual representation throughout all captured content. The approach employs dual-storage management with conditional file updates based on knowledge scope determination, consistency verification through comparison with existing entries and terminology validation, and timestamp maintenance for accurate change tracking. File update operations target specific sections within `WIP_TASK.md` including `Key Discoveries`, `Patterns Identified`, `Challenges & Solutions`, and `Task Resources`, while persistent knowledge updates target categorized sections in `KNOWLEDGE_BASE.md` including `Perplexity Query Results`, `Web Resources`, `Patterns and Solutions`, and `External APIs`.

######## External Dependencies & Integration Points

**→ References:**
- `Perplexity MCP server` - external research service providing query results for structured knowledge capture
- `WIP_TASK.md` - current task documentation requiring knowledge updates in specific sections
- `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` - persistent knowledge repository for long-term information storage
- `Essential Knowledge Base` - central knowledge coordination requiring timestamp updates for significant captures
- Web resources and external APIs - information sources requiring structured documentation and integration details

**← Referenced By:**
- Development workflows - consume captured knowledge for informed decision-making and implementation guidance
- Task management processes - reference structured knowledge for progress tracking and context maintenance
- Knowledge management workflows - use captured information for consistency verification and cross-referencing
- Future development sessions - access persistent knowledge for continued project understanding and implementation patterns

**⚡ System role and ecosystem integration:**
- **System Role**: Core knowledge capture workflow within the Jesse Framework knowledge management ecosystem, serving as the primary mechanism for structured information preservation and organization
- **Ecosystem Position**: Central knowledge acquisition component bridging external information sources with internal knowledge repositories through structured capture and format standardization
- **Integration Pattern**: Triggered automatically through natural language phrases or manually invoked, consumes external information sources and research results, produces structured knowledge entries in both task-specific and persistent storage locations

######### Edge Cases & Error Handling

The workflow handles knowledge conflicts with existing entries through user prompt resolution and dual-source updating to maintain consistency. File update failures preserve knowledge in temporary locations with rollback options and retry mechanisms for successful capture completion. Incomplete formatting scenarios prompt for missing information with validation requirements before knowledge storage. Storage location conflicts between task-specific and persistent knowledge trigger user guidance for appropriate categorization and potential dual storage. Network connectivity issues affecting external resource access implement graceful degradation with offline knowledge processing capabilities. Timestamp update failures provide alternative tracking mechanisms while preserving knowledge capture integrity and maintaining change history accuracy.

########## Internal Implementation Details

The knowledge type identification mechanism uses pattern matching and user prompt processing for appropriate template selection and information gathering structure. Structured information templates implement field validation and completeness checking for each knowledge category with specific requirements for URLs, contexts, applications, and implementation details. Intemporal writing conversion uses text processing algorithms for present tense conversion, factual statement restructuring, and terminology consistency validation. File update operations implement section-specific insertion with proper markdown formatting and existing content preservation. Consistency verification uses content comparison algorithms with terminology matching and conflict detection across multiple knowledge sources. Timestamp management implements ISO format generation with file modification tracking and change history maintenance for accurate knowledge evolution documentation.

########### Code Usage Examples

This example demonstrates automatic knowledge capture trigger activation for seamless workflow integration. The natural language recognition enables effortless knowledge preservation during development activities.

```markdown
User: "This API requires OAuth2 authentication with bearer tokens. Remember this for future reference."
Assistant: [Automatically triggers knowledge capture workflow]
Knowledge Type: API Knowledge
Storage Location: Persistent Knowledge
```

This example shows structured knowledge capture for Perplexity query results with comprehensive information organization. The template ensures complete context preservation and future accessibility.

```markdown
Query: "How to implement rate limiting in Python FastAPI applications"
Context: Investigating performance optimization for API endpoints
Key Findings: FastAPI supports rate limiting through slowapi middleware with Redis backend
Application: Implement rate limiting on authentication endpoints to prevent abuse
Follow-up Actions: Install slowapi package and configure Redis connection
```

This example illustrates pattern/solution knowledge capture with implementation guidance and benefit documentation. The structured approach enables reusable knowledge creation for future development scenarios.

```markdown
Pattern Name: Repository Pattern with Dependency Injection
Context: When separating data access logic from business logic in Python applications
Description: Abstract data access through repository interfaces with concrete implementations
Implementation: Create abstract base class with concrete implementations for different data sources
Benefits: Improved testability, loose coupling, and easier data source switching
```

This example demonstrates web resource knowledge capture with context and application information. The structured format ensures valuable external resources remain accessible and properly documented.

```markdown
URL: https://fastapi.tiangolo.com/advanced/security/
Title: FastAPI Advanced Security Documentation
Context: Researching OAuth2 implementation patterns for authentication system
Key Information: Comprehensive examples of OAuth2 flows with dependency injection
Application: Reference for implementing secure authentication in current API project
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_check_consistency.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow documentation provides a comprehensive knowledge consistency verification system for the Jesse Framework MCP project, designed to identify and resolve contradictions across distributed knowledge management files to maintain single source of truth principles. The system delivers systematic scanning capabilities across multiple knowledge bases including `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md`, `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md`, `WIP_TASK.md` files, and git clone knowledge bases, conflict detection and categorization with severity levels (`Critical`, `Major`, `Minor`, `Informational`), and resolution implementation with user-guided decision making. Key semantic entities include `Essential Knowledge Base` scanning, `Persistent Knowledge Base` analysis, `Active WIP Task Knowledge` extraction, `Git Clone Knowledge Bases` processing, `Terminology Consistency` verification, `Factual Consistency` validation, `Reference Consistency` checking, `Intemporal Writing Verification`, `Cross-Reference Validation`, `Duplicate Detection`, automated consistency rules, and comprehensive reporting mechanisms enabling systematic knowledge base maintenance and quality assurance across the entire Jesse Framework MCP ecosystem.

##### Main Components

The workflow contains eleven sequential execution steps forming the core consistency verification process, five consistency check categories for systematic analysis, automated consistency rules for validation, and comprehensive error handling mechanisms. Primary execution components include knowledge base scanning procedures (Essential, Persistent, WIP Task, Git Clone), conflict identification and severity categorization systems, user-guided resolution decision gathering, implementation procedures with file modification capabilities, and verification processes ensuring successful resolution. The workflow incorporates specialized consistency check categories covering terminology alignment, factual verification, and reference validation, supported by automated rules for intemporal writing standards, cross-reference validation, and duplicate content detection.

###### Architecture & Design

The architecture implements a sequential workflow pattern with systematic knowledge base traversal, conflict detection algorithms, and user-interactive resolution processes. The design employs a multi-source scanning approach that processes different knowledge repositories independently before cross-referencing for consistency analysis. The system uses severity-based conflict categorization enabling prioritized resolution workflows, with user-guided decision making for each identified inconsistency. The architectural pattern includes comprehensive verification loops ensuring resolution success and preventing introduction of new conflicts during the consistency enforcement process. The design incorporates automated rule engines for standard consistency checks while maintaining human oversight for complex resolution decisions.

####### Implementation Approach

The implementation uses systematic file scanning with content extraction and comparison algorithms to identify knowledge inconsistencies across multiple sources. The approach employs pattern matching for terminology consistency, factual statement comparison for contradiction detection, and reference validation for link integrity verification. The system implements user interaction patterns for resolution decision gathering, with structured options for updating sources, creating standards, consolidating information, or adding cross-references. File modification procedures maintain intemporal writing standards while preserving essential context and meaning. The implementation includes comprehensive reporting mechanisms with detailed conflict analysis, resolution tracking, and preventive recommendations for future consistency maintenance.

######## External Dependencies & Integration Points

**→ References:**
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - Essential Knowledge Base containing core project knowledge and terminology
- `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` - Persistent Knowledge Base with patterns, solutions, and API documentation
- `WIP_TASK.md` - Active work-in-progress task documentation with current learnings and discoveries
- Git clone knowledge base files - Repository-specific knowledge bases with integration patterns and API details
- External resource URLs - Web resources and documentation referenced in knowledge bases
- Perplexity query results - External research findings integrated into persistent knowledge

**← Referenced By:**
- Knowledge management workflows - Procedures that depend on consistent knowledge base state
- Development team processes - Team workflows requiring reliable knowledge base information
- Automated knowledge capture systems - Tools that validate against established consistency standards
- Project documentation generation - Systems that aggregate knowledge from multiple sources
- Quality assurance procedures - Processes that verify knowledge base integrity

**⚡ System role and ecosystem integration:**
- **System Role**: Critical quality assurance workflow for maintaining knowledge base integrity across the Jesse Framework MCP project's distributed knowledge management system
- **Ecosystem Position**: Central maintenance procedure that ensures reliability and consistency of all knowledge sources used by development teams and automated systems
- **Integration Pattern**: Used by knowledge managers and development teams through manual execution, integrated with knowledge capture workflows for validation, and referenced by automated systems requiring consistent knowledge base state

######### Edge Cases & Error Handling

The workflow handles missing or corrupted knowledge base files by continuing with available sources and noting issues in the comprehensive report. Resolution implementation failures preserve original content and log errors to prevent data loss during consistency enforcement. Cross-reference validation failures mark potentially broken references without interrupting the overall consistency check process. The system provides rollback options if consistency check procedures introduce new problems or conflicts. Error handling includes scenarios where automated consistency rules conflict with manual resolution decisions, requiring user intervention to establish precedence. The workflow addresses cases where circular references exist between knowledge sources, implementing detection mechanisms to prevent infinite loops during consistency verification.

########## Internal Implementation Details

The workflow uses content extraction algorithms that parse markdown files and identify knowledge entries, terminology definitions, and factual statements for comparison analysis. Conflict detection employs string matching, semantic analysis, and reference validation to identify inconsistencies across multiple knowledge sources. Resolution implementation uses file modification procedures that maintain markdown formatting while updating content according to user decisions. The system implements timestamp management for modified files and maintains audit trails of all changes made during consistency enforcement. Internal mechanisms include backup creation before modifications, validation of changes against consistency rules, and verification that cross-references remain valid after content updates.

########### Code Usage Examples

This example demonstrates the systematic knowledge base scanning process that forms the foundation of the consistency check workflow:

```markdown
# Execute comprehensive knowledge base scan across all sources
1. Read .clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md for essential knowledge
2. Process .knowledge/persistent-knowledge/KNOWLEDGE_BASE.md for patterns
3. Analyze active WIP_TASK.md for current discoveries
4. Scan all git clone knowledge bases for integration details
5. Extract terminology, facts, and references from each source
```

This example shows the conflict identification and categorization process used to prioritize resolution efforts:

```markdown
# Identify and categorize knowledge conflicts by severity
- Critical: API endpoint contradictions between sources
- Major: Terminology inconsistencies for same concepts
- Minor: Formatting differences in similar content
- Informational: Duplicate information requiring consolidation
```

This example illustrates the user-guided resolution process that ensures appropriate handling of each identified conflict:

```markdown
# Present conflicts with resolution options for user decision
Conflict: Authentication method described as "OAuth2" in Essential KB, "API Key" in Persistent KB
Options:
- Update Essential KB to match Persistent KB
- Update Persistent KB to match Essential KB  
- Create new standard terminology across both sources
- Add cross-reference linking both authentication methods
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_commit.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `WIP Task Commit Workflow` for creating standards-compliant git commit messages with multi-line structured documentation, leveraging git diff analysis and file history data to ensure accuracy and completeness within the Jesse Framework ecosystem. The workflow delivers systematic commit message generation through seven execution steps including change analysis, context extraction, structured message preparation, validation, mandatory user confirmation, and commit creation. Key semantic entities include `git diff` command integration with flags (`--staged`, `--stat`, `--name-only`), structured commit message format with mandatory sections (`[Commit intent]`, `[Implementation details]`, `[Testing performed]`, `[Impact analysis]`, `[Related items]`), commit type definitions (`feat`, `fix`, `refactor`, `docs`, `test`, `perf`, `style`, `build`, `ci`, `chore`), scope requirements for component identification, 72-character subject line limit, `[GenAI tool change history]` section extraction from file headers, `[Function intent]` and `[Design principles]` documentation integration, `[BREAKING CHANGE]` section for API modifications, `/jesse_wip_task_disable.md` workflow integration for repository-wide changes, mandatory user confirmation step, 4-line limits for implementation and impact sections with major change exceptions, `.gitmessage` template configuration, and comprehensive validation requirements with zero-tolerance enforcement policies. The system enables developers to maintain high-quality version control documentation while ensuring consistency, traceability, and comprehensive change documentation across all repository modifications.

##### Main Components

The workflow contains seven primary execution steps: git diff analysis using multiple command variations for comprehensive change assessment, file history context extraction from headers and documentation sections, structured commit message preparation following mandatory format requirements, required section completion including commit intent, implementation details, testing performed, impact analysis, and related items, commit message validation with completeness and format verification, mandatory user confirmation step with explicit approval requirements, and commit creation using git command options. Supporting components include commit message structure standards with type definitions and scope requirements, content quality standards specifying technical detail requirements and line limits, validation and enforcement protocols with pre-commit checks, special commit type handling for breaking changes and emergency fixes, git diff integration guidelines for data extraction, file history leveraging procedures for context alignment, and tooling automation including templates, IDE integration, and helpful command references.

###### Architecture & Design

The architecture implements a structured documentation-driven commit workflow with mandatory validation and user confirmation patterns. The design uses git diff integration for comprehensive change analysis, file history extraction for contextual alignment, and structured template processing for consistent message generation. The system employs mandatory section completion with specific content requirements, validation protocols ensuring completeness and format compliance, and user confirmation gates preventing automated commit execution. The workflow follows a quality-first approach with zero-tolerance enforcement policies, comprehensive validation requirements, and continuous improvement mechanisms. The architecture includes special handling for breaking changes, emergency fixes, and repository-wide modifications while maintaining integration with existing Jesse Framework workflows and documentation standards.

####### Implementation Approach

The implementation uses git diff command integration with multiple flag combinations for comprehensive change analysis including unstaged changes, staged changes, file statistics, and modified file lists. The approach employs file header parsing for context extraction from `[GenAI tool change history]`, `[Function intent]`, and `[Design principles]` sections with dependency and constraint documentation. Structured message generation uses template processing with mandatory section completion, content validation, and format compliance checking. User confirmation implements explicit approval requirements with revision capabilities and blocking mechanisms preventing unauthorized commits. Validation protocols use automated checking for required sections, character limits, format compliance, and content quality standards with descriptive error reporting and correction guidance.

######## External Dependencies & Integration Points

**→ References:**
- `git` command-line tool - version control system providing diff analysis, staging operations, and commit creation functionality
- `[GenAI tool change history]` sections - file header documentation providing change context and evolution patterns
- `[Function intent]` and `[Design principles]` documentation - code documentation providing implementation context and design alignment
- `/jesse_wip_task_disable.md` workflow - task management workflow affecting commit scope and context determination
- `.gitmessage` template file - git configuration template for structured commit message formatting
- File header documentation standards - Jesse Framework documentation requirements for context extraction

**← Referenced By:**
- Development workflows - consume commit message standards for version control documentation and change tracking
- Code review processes - reference commit message quality requirements for approval criteria and validation
- Issue tracking systems - use commit message linking and traceability for project management integration
- Documentation generation workflows - leverage commit messages for changelog creation and release documentation
- Quality assurance processes - enforce commit message standards for project compliance and consistency maintenance

**⚡ System role and ecosystem integration:**
- **System Role**: Core version control documentation workflow within the Jesse Framework development ecosystem, serving as the authoritative standard for git commit message creation and quality enforcement
- **Ecosystem Position**: Central development process component bridging code changes with comprehensive documentation through structured commit message generation and validation
- **Integration Pattern**: Invoked by developers during commit operations, consumes git diff data and file documentation, produces structured commit messages with mandatory validation and user confirmation for quality assurance

######### Edge Cases & Error Handling

The workflow handles missing git diff data by requiring comprehensive change analysis before commit message creation with fallback to manual file inspection when automated analysis fails. Repository-wide changes without WIP task context trigger scope adjustment with broader change documentation requirements and context adaptation. Incomplete file header documentation receives graceful handling with alternative context sources and manual documentation requirements. User confirmation rejection triggers revision workflows with iterative improvement capabilities and blocking mechanisms preventing substandard commits. Validation failures provide specific error reporting with correction guidance and retry mechanisms for compliance achievement. Emergency fix scenarios maintain full documentation requirements with expedited validation processes and critical change handling protocols.

########## Internal Implementation Details

The git diff integration mechanism uses command flag combinations (`-P diff`, `--staged`, `--stat`, `--name-only`) for comprehensive change data extraction with context analysis and file modification tracking. File header parsing implements pattern matching for `[GenAI tool change history]`, `[Function intent]`, and `[Design principles]` sections with content extraction and context alignment verification. Structured message generation uses template processing with mandatory section completion, content validation, and format compliance checking including character limits and line restrictions. User confirmation implements explicit approval workflows with revision capabilities, blocking mechanisms, and quality gate enforcement. Validation protocols use automated checking with descriptive error reporting, correction guidance, and retry mechanisms for compliance achievement. Commit creation uses git command integration with proper formatting and multi-line message support.

########### Code Usage Examples

This example demonstrates comprehensive git diff analysis for change assessment and context gathering. The multi-command approach ensures complete understanding of modifications before commit message creation.

```bash
# Analyze all types of changes for comprehensive commit message preparation
git -P diff                    # View unstaged changes
git -P diff --staged          # View staged changes  
git -P diff --staged --stat   # Get file statistics
git -P diff --staged --name-only  # Get modified file list
```

This example shows the mandatory structured commit message format with all required sections. The template ensures comprehensive documentation with specific content requirements and validation compliance.

```bash
# Complete commit message structure following mandatory format requirements
feat(auth): Add OAuth2 token refresh with automatic retry logic

[Commit intent]
Users experienced authentication failures during long sessions when tokens
expired. This change implements automatic token refresh to maintain seamless
user experience without requiring re-authentication.

[Implementation details]
- Modified auth_manager.py to add token refresh logic with exponential backoff
- Implemented refresh queue in token_service.py for concurrent request handling
- Added token expiration monitoring with 5-minute early refresh
- Used asyncio.Lock() for thread-safe token refresh operations

[Testing performed]
- Unit tests: 15 new tests for token refresh scenarios
- Integration tests: Verified 100 concurrent requests during refresh
- Manual testing: Confirmed seamless experience during token expiration
- Performance testing: No degradation in normal authentication flow

[Impact analysis]
- Eliminates authentication interruptions for long-running sessions
- Adds ~10ms latency during token refresh operations
- No API changes required for existing clients
- Requires TOKEN_REFRESH_ENABLED=true configuration

[Related items]
- Issue: #456 (Token expiration authentication failures)
- Docs: Updated AUTH_API.md with refresh behavior documentation
```

This example illustrates the mandatory user confirmation step with explicit approval requirements. The confirmation process ensures quality control and prevents automated commit execution without human oversight.

```bash
# Mandatory user confirmation workflow preventing automated commits
echo "Please review this commit message. Do you approve this commit message and confirm that the commit can proceed? (Yes/No)"
read -r user_response
if [[ "$user_response" != "Yes" ]]; then
    echo "Commit cancelled. Please revise the commit message."
    exit 1
fi
git commit  # Proceed only after explicit user approval
```

This example demonstrates git diff integration for extracting specific implementation details and file statistics. The data extraction ensures accurate technical documentation in commit messages with concrete evidence of changes.

```bash
# Extract specific change data for accurate commit message documentation
git -P diff --staged --word-diff  # Get granular change details
git -P diff --staged path/to/specific/file.py  # Analyze specific file changes
git -P diff --staged --numstat   # Get numerical change statistics
# Use extracted data to populate [Implementation details] section accurately
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_complete.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow documentation provides a comprehensive WIP task completion system for the Jesse Framework, designed to finalize work-in-progress tasks with integrated Git branch management, knowledge extraction to persistent storage, and proper task archival with lifecycle tracking. The system delivers active task verification with Essential Knowledge Base validation, sophisticated Git branch assessment including merge assistance with multiple strategy options (`Fast-Forward`, `Three-Way`, `Squash and Merge`, `Rebase and Merge`), and comprehensive knowledge extraction following intemporal writing standards. Key semantic entities include `WIP_TASK.md` Git Integration section processing, `.knowledge/work-in-progress/_archived/` timestamped archival directory structure, `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` knowledge persistence, `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` Essential Knowledge Base updates, Git command integration with `git checkout`, `git merge`, `git branch -d` operations, multiple WIP task detection and manual management warnings, parent branch switching for archival context, intemporal writing conversion from past to present tense, and comprehensive error handling with rollback capabilities ensuring consistent task lifecycle management and knowledge preservation across the Jesse Framework ecosystem.

##### Main Components

The workflow contains seven primary execution steps with comprehensive Git integration and knowledge management capabilities. Core components include Verify Active Task confirming task existence and displaying summary, Git Branch Assessment and Merge Assistance providing automated merge workflows with strategy selection, Extract Task Learnings processing reusable knowledge from task files, Update Persistent Knowledge Base appending extracted insights to permanent storage, Generate Task Completion Summary creating comprehensive completion documentation, Archive Task moving completed work to timestamped archived locations, and Update Essential Knowledge Base clearing active task status. The system incorporates specialized components including multiple WIP task detection with manual management warnings, merge conflict resolution guidance, parent branch switching for proper archival context, and comprehensive error handling with detailed failure recovery procedures.

###### Architecture & Design

The architecture implements a state-driven completion workflow with comprehensive Git integration and knowledge preservation mechanisms ensuring proper task lifecycle management. The design employs conditional Git assistance based on branch configuration and multi-task detection, providing automated merge workflows for single-task branches while requiring manual management for complex scenarios. The system uses structured knowledge extraction patterns converting task-specific learnings into reusable persistent knowledge following intemporal writing standards. The architectural pattern includes comprehensive error handling with rollback capabilities, parent branch context switching for proper archival, and multi-stage validation ensuring consistent completion across different Git repository states and task configurations.

####### Implementation Approach

The implementation uses Git command-line integration for branch assessment, merge operations, and repository state management, employing conditional logic to handle single-task versus multi-task branch scenarios. The approach employs structured knowledge extraction algorithms processing WIP task files to identify reusable patterns, solutions, and insights for persistent storage. Task archival uses timestamped directory creation in `.knowledge/work-in-progress/_archived/` with complete file preservation and metadata enhancement. The system implements intemporal writing conversion transforming historical task learnings into present-tense factual statements for knowledge base integration. Git merge assistance provides four distinct strategies with user selection and automated execution including conflict resolution guidance and branch cleanup options.

######## External Dependencies & Integration Points

**→ References:**
- `git` (external tool) - Git version control system for branch management, merge operations, and repository state assessment
- `.knowledge/work-in-progress/_archived/` - timestamped archival directory structure for completed task preservation
- `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` - persistent knowledge repository for extracted learnings and patterns
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - Essential Knowledge Base requiring active task status updates
- `WIP_TASK.md` - task definition files containing Git Integration sections and completion metadata
- `PROGRESS.md` - task progress tracking files requiring archival with completion timestamps
- Git branch naming conventions - standardized patterns for feature branch identification and parent branch relationships

**← Referenced By:**
- Jesse Framework knowledge management system - processes consuming completed task information and extracted learnings
- Git workflow management tools - systems requiring standardized merge strategies and branch cleanup procedures
- Task creation workflows - procedures referencing completion patterns for lifecycle management
- Project documentation systems - tools aggregating completed task insights for project knowledge
- Development team coordination processes - workflows requiring task completion awareness and knowledge sharing

**⚡ System role and ecosystem integration:**
- **System Role**: Critical task lifecycle completion component within the Jesse Framework ecosystem, providing comprehensive WIP task finalization with integrated Git workflow management and knowledge preservation
- **Ecosystem Position**: Core infrastructure component that completes the task management lifecycle, serving as the bridge between active development work and persistent project knowledge
- **Integration Pattern**: Used by development teams through direct workflow invocation, integrated with Git repositories for version control coordination, synchronized with knowledge management systems for learning preservation, and coordinated with archival systems for historical task reference and project continuity

######### Edge Cases & Error Handling

The workflow handles scenarios where no active task exists by providing user guidance and suggesting task switching or creation alternatives. Multiple WIP tasks on the same branch trigger manual management warnings with detailed responsibility explanations and complexity reduction recommendations. Git operation failures including merge conflicts, branch switching errors, and parent branch access issues provide comprehensive resolution guidance with fallback options. Parent branch switch failures during archival trigger detailed error analysis with user choice options for resolution or alternative archival approaches. Knowledge extraction failures preserve task archival while warning about lost learning opportunities. The system addresses partial completion failures with rollback options and state restoration capabilities ensuring consistent project state regardless of failure points.

########## Internal Implementation Details

The workflow uses Git command execution for repository state assessment including branch detection, merge conflict identification, and parent branch validation. Knowledge extraction employs pattern matching algorithms identifying reusable insights from task files and converting historical learnings to intemporal present-tense statements. Task archival implements atomic file system operations with timestamped directory creation and complete metadata preservation including completion summaries and learning extractions. Git merge assistance uses conditional strategy execution with user-selected approaches including fast-forward detection, three-way merge commit creation, squash commit generation, and rebase operations. Error handling implements comprehensive state validation with detailed error message generation and user guidance for manual resolution procedures.

########### Code Usage Examples

This example demonstrates the Git branch assessment and merge assistance workflow providing automated merge strategies:

```bash
# Git branch assessment and merge strategy execution
git checkout [parent_branch_name]
git merge --no-ff [branch_name]
# Provides automated merge assistance with strategy selection and conflict resolution
```

This example shows the parent branch switching procedure ensuring proper archival context:

```bash
# Parent branch context switching for proper task archival
git checkout [feature_branch_name]
git add .knowledge/work-in-progress/[task_name]/WIP_TASK.md
git commit -m "feat: Mark WIP task '[task_name]' as completed"
git checkout [parent_branch_name]
# Ensures task completion is recorded and archived in proper branch context
```

This example illustrates the comprehensive error handling for parent branch switch failures:

```text
# Parent branch switch failure handling with user options
❌ Parent Branch Switch Failed
Attempted to switch from [feature_branch] to [parent_branch] but failed.
🔧 Your Options:
1. Fix the Git issue manually and restart completion workflow
2. Complete archival on current branch (feature branch)
3. Cancel completion workflow to investigate
# Provides detailed error context and recovery options for Git operation failures
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_create.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow documentation provides a comprehensive WIP task creation system for the Jesse Framework, designed to establish structured work-in-progress tasks with integrated Git branch management, knowledge base synchronization, and project lifecycle tracking. The system delivers mandatory Git repository validation with uncommitted changes detection, structured task directory creation in `.knowledge/work-in-progress/` with standardized templates, and comprehensive Git branch management including automatic branch creation and parent branch selection. Key semantic entities include `git rev-parse --is-inside-work-tree` repository validation, `git status --porcelain` working directory checks, `.knowledge/work-in-progress/[task_name_snake_case]/` directory structure creation, `WIP_TASK.md` and `PROGRESS.md` template population, `snake_case` task name conversion, Git branch naming with `jesse-wip/[task_name_snake_case]` pattern, `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` Essential Knowledge Base integration, parallel task detection and warning systems, file restriction capabilities for multi-task scenarios, mandatory WIP task files commit requirements, and comprehensive error handling with complete rollback mechanisms ensuring consistent project state management and task isolation.

##### Main Components

The workflow contains seven primary execution steps with critical validation checkpoints and comprehensive error handling mechanisms. Core components include Git Repository Validation checking repository status and working directory cleanliness, Task Information Gathering collecting user requirements for task definition, Task Directory Structure Creation establishing standardized file organization, WIP_TASK.md Template Population with comprehensive task metadata, Git Branch Management Setup providing branch creation and selection options, PROGRESS.md Template Creation for milestone tracking, and Essential Knowledge Base Updates maintaining system-wide task awareness. The system incorporates specialized validation steps including Git Working Directory Prerequisites ensuring clean repository state, parallel task detection with risk warnings, mandatory WIP task files commit procedures, and comprehensive error handling with rollback capabilities.

###### Architecture & Design

The architecture implements a state-driven workflow pattern with mandatory validation checkpoints preventing inconsistent task creation and ensuring Git repository integrity. The design employs a fail-fast approach with comprehensive prerequisite validation before any file system modifications, ensuring clean rollback capabilities when validation fails. The system uses structured template-based task creation with standardized directory organization and file naming conventions enabling consistent task management across projects. The architectural pattern includes integrated Git workflow management with branch creation, parent branch selection, and automatic commit procedures ensuring proper version control integration. The design incorporates knowledge base synchronization maintaining system-wide awareness of active tasks and their status through Essential Knowledge Base updates.

####### Implementation Approach

The implementation uses Git command-line integration for repository validation and branch management operations, employing `git rev-parse --is-inside-work-tree` for repository detection and `git status --porcelain` for working directory validation. The approach employs structured template generation for task files with standardized markdown formats and comprehensive metadata sections. Task naming uses snake_case conversion algorithms ensuring consistent directory naming and Git branch creation patterns. The system implements comprehensive validation workflows with user confirmation dialogs and risk warnings for parallel task scenarios. File system operations use atomic creation patterns with rollback capabilities ensuring consistent state management during failures. Git integration employs standard branching workflows with automatic commit procedures and parent branch selection mechanisms.

######## External Dependencies & Integration Points

**→ References:**
- `git` (external tool) - Git version control system for repository validation, branch management, and commit operations
- `.knowledge/work-in-progress/` - dedicated directory structure for WIP task organization and file storage
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - Essential Knowledge Base requiring updates for active task tracking
- `WIP_TASK.md` template - standardized task definition format with Git integration metadata
- `PROGRESS.md` template - milestone tracking format for task progress monitoring
- Git branch naming convention `jesse-wip/[task_name_snake_case]` - standardized branch naming pattern
- Snake_case conversion algorithms - task name standardization for directory and branch naming

**← Referenced By:**
- Jesse Framework knowledge management system - processes consuming WIP task information for project coordination
- Git workflow management tools - systems requiring standardized branch naming and commit patterns
- Task completion workflows - procedures referencing WIP task structure for completion and cleanup operations
- Project status reporting systems - tools aggregating WIP task information for progress tracking
- Development team coordination processes - workflows requiring active task awareness and conflict prevention

**⚡ System role and ecosystem integration:**
- **System Role**: Critical task lifecycle management component within the Jesse Framework ecosystem, providing structured WIP task creation with integrated Git workflow management and knowledge base synchronization
- **Ecosystem Position**: Core infrastructure component that establishes the foundation for all work-in-progress task management, serving as the entry point for structured development workflows
- **Integration Pattern**: Used by development teams through direct workflow invocation, integrated with Git repositories for version control coordination, synchronized with knowledge management systems for project awareness, and coordinated with task completion workflows for full lifecycle management

######### Edge Cases & Error Handling

The workflow handles uncommitted Git changes by immediately failing with comprehensive guidance for resolution through commit, stash, or reset operations. Task name conflicts with existing tasks trigger alternative name prompts preventing directory structure collisions. File creation failures implement complete rollback procedures removing partial directory structures and restoring original system state. WIP task files commit failures trigger comprehensive cleanup including file removal and Essential Knowledge Base restoration. Git branch creation failures provide fallback options to current branch usage while maintaining task functionality. Essential Knowledge Base update failures implement complete rollback with previous state restoration. The system addresses parallel task scenarios with risk warnings and optional file restriction capabilities preventing task interference and state inconsistencies.

########## Internal Implementation Details

The workflow uses bash command execution for Git operations including `git rev-parse --is-inside-work-tree` for repository validation and `git status --porcelain` for working directory assessment. Task directory creation employs atomic file system operations with structured template population using markdown formatting standards. Snake_case conversion algorithms process user-provided task names ensuring consistent naming across directory structures and Git branches. Git branch management uses standard Git commands including `git checkout -b [branch_name] [parent_branch]` for branch creation and `git branch -a` for branch listing. Commit operations use structured commit messages with standardized formatting for task lifecycle tracking. Error handling implements comprehensive state validation with rollback procedures ensuring consistent system state during failures. Template population uses structured markdown generation with placeholder replacement and metadata integration.

########### Code Usage Examples

This example demonstrates the Git repository validation and working directory prerequisite checks that ensure clean task creation:

```bash
# Git repository validation and working directory assessment
git rev-parse --is-inside-work-tree
git status --porcelain
# Validates repository status and detects uncommitted changes before task creation
```

This example shows the mandatory WIP task files commit procedure ensuring proper Git integration:

```bash
# Mandatory commit of WIP task files for Git branch management
git add .knowledge/work-in-progress/[task_name]/
git add .clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md
git commit -m "feat: Create WIP task '[task_name]' with initial structure

- Add WIP_TASK.md with task definition and scope  
- Add PROGRESS.md for milestone tracking
- Update Essential Knowledge Base with active task"
# Ensures WIP task files are tracked and available across branches
```

This example illustrates the Git branch creation workflow with standardized naming patterns:

```bash
# Git branch creation with standardized naming convention
git checkout -b jesse-wip/[task_name_snake_case] [parent_branch]
git branch -a
# Creates dedicated task branch following Jesse Framework naming standards
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_disable.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow documentation provides a session-scoped WIP task disabling mechanism for the Jesse Framework, designed to temporarily prevent automatic loading of current work-in-progress task assets during Cline conversation sessions without affecting persistent task state or future session behavior. The system delivers temporary context isolation capabilities through in-memory session flags, selective knowledge base loading that maintains Essential Knowledge Base and Git clone knowledge bases while excluding WIP task files, and comprehensive user confirmation workflows ensuring intentional disabling actions. Key semantic entities include `Cline` conversation session management via `https://github.com/cline/cline` integration, session-only flag implementation preventing WIP task auto-loading, `/wip_task_disable` workflow invocation pattern, `/wip_task_enable` re-enabling mechanism, `[task_name]` placeholder for active task identification, Essential Knowledge Base preservation during selective loading, Git clone knowledge bases continued operation, and memory-based state management ensuring no persistent file modifications while providing clean context isolation for debugging, troubleshooting, and unrelated task work scenarios.

##### Main Components

The workflow contains four primary execution steps implementing session-scoped WIP task disabling functionality. Core components include Confirm Disable Action providing user verification with explicit task identification and session-only impact explanation, Set Session Flag creating memory-based flags preventing WIP task loading without persistent file modifications, Provide Confirmation delivering status updates with re-enabling instructions, and Document Session State ensuring ongoing session awareness of disabled WIP task loading. The system incorporates implementation notes covering session behavior specifications, knowledge management impact details, and re-enabling options through new session initiation or explicit workflow invocation.

###### Architecture & Design

The architecture implements a non-persistent session state management pattern using memory-based flags to control WIP task loading behavior without affecting underlying task files or future session initialization. The design employs selective knowledge base loading that maintains essential system knowledge while isolating WIP task context for clean debugging and troubleshooting environments. The system uses explicit user confirmation workflows preventing accidental disabling and ensuring users understand the session-scoped nature of the operation. The architectural pattern includes comprehensive state documentation ensuring session awareness and clear re-enabling pathways through both automatic session restart and explicit workflow invocation mechanisms.

####### Implementation Approach

The implementation uses in-memory session flag management to control WIP task auto-loading behavior without modifying persistent configuration files or task state. The approach employs selective knowledge base loading algorithms that continue processing Essential Knowledge Base and Git clone knowledge bases while skipping WIP task file initialization during session startup. User confirmation workflows implement explicit consent mechanisms with detailed explanations of session-scoped impact and task preservation guarantees. The system implements state documentation patterns ensuring ongoing session awareness of disabled WIP task loading through response annotations and status indicators. Re-enabling mechanisms provide both automatic restoration through new session initiation and explicit workflow-based restoration within current sessions.

######## External Dependencies & Integration Points

**→ References:**
- `https://github.com/cline/cline` - Cline conversation system providing session management and workflow execution environment
- `/wip_task_disable` - workflow invocation pattern for disabling WIP task auto-loading functionality
- `/wip_task_enable` - complementary workflow for re-enabling WIP task loading within current session
- Essential Knowledge Base - system knowledge repository continuing normal loading during WIP task disabling
- Git clone knowledge bases - external repository knowledge sources maintaining normal operation
- WIP task files - work-in-progress task assets subject to selective loading control
- Session memory management - in-memory flag storage preventing persistent state modifications

**← Referenced By:**
- Jesse Framework session initialization - startup procedures checking WIP task loading flags
- Knowledge management workflows - processes requiring clean context without WIP task interference
- Debugging and troubleshooting procedures - workflows benefiting from isolated context environments
- Task switching workflows - procedures requiring temporary WIP task context removal
- Session state management systems - components tracking and documenting session-scoped configuration changes

**⚡ System role and ecosystem integration:**
- **System Role**: Session-scoped context control mechanism within the Jesse Framework ecosystem, providing temporary WIP task isolation for debugging, troubleshooting, and unrelated work scenarios
- **Ecosystem Position**: Auxiliary workflow component that modifies session behavior without affecting persistent task state or system configuration
- **Integration Pattern**: Used by developers and AI assistants through direct workflow invocation, integrated with Cline session management for state control, coordinated with knowledge management systems for selective loading, and designed for seamless restoration through session restart or explicit re-enabling workflows

######### Edge Cases & Error Handling

The workflow handles scenarios where no active WIP task exists by providing appropriate messaging about the absence of tasks to disable. Multiple active WIP tasks scenarios require clarification of which specific task is being disabled or whether all WIP task loading should be suspended. Session state persistence failures are managed through memory-based flag implementation that automatically resets with new sessions, preventing permanent disabling states. User confirmation rejection scenarios maintain current WIP task loading behavior without any state changes. The system addresses re-enabling failures within the same session by providing fallback options through new session initiation. Knowledge base loading errors during selective processing continue with available knowledge sources while noting any loading limitations or failures.

########## Internal Implementation Details

The workflow uses memory-based session flag storage implementing boolean state variables that control WIP task loading behavior during knowledge base initialization procedures. Session state management employs temporary variable assignment preventing persistent file modifications while maintaining effective WIP task isolation throughout the current conversation session. User confirmation mechanisms implement explicit consent workflows with detailed impact explanations ensuring informed decision-making about session-scoped changes. Knowledge base loading modification uses conditional logic checking session flags before processing WIP task files while maintaining normal operation for Essential Knowledge Base and Git clone knowledge sources. State documentation employs response annotation patterns ensuring ongoing session awareness of modified loading behavior and available restoration options.

########### Code Usage Examples

This example demonstrates the basic workflow invocation pattern for disabling WIP task auto-loading in the current session:

```bash
# Invoke WIP task disable workflow for session-scoped context isolation
/wip_task_disable
# Temporarily prevents WIP task loading while preserving task state and enabling clean context
```

This example shows the user confirmation dialog ensuring intentional disabling with clear session-scoped impact explanation:

```text
# User confirmation workflow with explicit session scope and task preservation guarantees
"This will disable automatic loading of WIP task '[task_name]' for the current session only. 
The WIP task will remain active and will be loaded in future sessions unless explicitly disabled again.
Do you want to proceed?"
# Ensures informed consent for session-scoped WIP task context isolation
```

This example illustrates the session state documentation pattern maintaining awareness of disabled WIP task loading:

```text
# Session state documentation ensuring ongoing awareness of modified loading behavior
Note: WIP task auto-loading is currently disabled for this session
# Provides context about current session configuration and available restoration options
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_new_session.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `WIP Stack New Session Workflow` for enforcing strict adherence to knowledge management system rules by simulating fresh Cline session initialization within the Jesse Framework ecosystem. The workflow provides mandatory execution of all initialization steps from `JESSE_KNOWLEDGE_MANAGEMENT.md` without exception, ensuring complete system state reset and context loading when normal session startup procedures may have been skipped or incomplete. Key semantic entities include `Cline` session management integration via `https://github.com/cline/cline`, mandatory file loading from `.knowledge/JESSE_KNOWLEDGE_MANAGEMENT.md`, Essential Knowledge Base processing from `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md`, git clone knowledge loading from `.knowledge/git-clones/` directory with `[repo-name]_kb.md` files, WIP task context loading from `.knowledge/work-in-progress/[current_task]/WIP_TASK.md` and `PROGRESS.md`, structured status summary display format, compliance verification protocols, session readiness confirmation messages, strict execution order requirements, error handling with immediate stop conditions, and integration compatibility with `/jesse_wip_task_create.md`, `/jesse_wip_task_switch.md`, and `/jesse_wip_task_capture_knowledge.md` workflows. The system enables developers to guarantee complete knowledge management system initialization and context restoration when session state consistency is questionable or incomplete.

##### Main Components

The workflow contains seven mandatory execution steps: system rules reload requiring complete reading of `.knowledge/JESSE_KNOWLEDGE_MANAGEMENT.md`, Essential Knowledge Base loading from persistent knowledge storage, git clone knowledge loading with repository verification, WIP task context loading including active task identification and progress assessment, context summary display with structured status reporting, compliance verification for knowledge management rule activation, and session readiness confirmation with initialization completion status. Supporting components include implementation requirements specifying strict execution order and no conditional logic, comprehensive error handling procedures with immediate failure reporting and remediation steps, usage examples demonstrating basic invocation and specific focus scenarios, integration specifications with other knowledge management workflows, and success criteria validation including file processing verification and knowledge consistency checking.

###### Architecture & Design

The architecture implements a mandatory sequential execution pattern with strict adherence to knowledge management system initialization protocols. The design uses unconditional step execution regardless of current session state, comprehensive file loading from multiple knowledge storage locations, and structured status reporting with detailed context summaries. The system employs fail-fast error handling with immediate execution termination upon any step failure, mandatory verification requirements after each major step, and session state reset functionality while preserving persistent knowledge and WIP task progress. The workflow follows a compliance-first approach ensuring all knowledge management rules are actively enforced and session initialization is complete before normal operation resumption.

####### Implementation Approach

The implementation uses sequential mandatory step execution with no shortcuts or conditional logic, comprehensive file reading operations across multiple knowledge storage directories, and structured verification protocols after each major loading phase. The approach employs strict error handling with immediate execution termination and specific remediation step provision, detailed status summary generation with formatted output templates, and integration compatibility verification with existing workflow systems. File loading operations target specific paths including `.knowledge/JESSE_KNOWLEDGE_MANAGEMENT.md`, `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md`, `.knowledge/git-clones/` directory contents, and `.knowledge/work-in-progress/[current_task]/` files with comprehensive content processing and consistency validation.

######## External Dependencies & Integration Points

**→ References:**
- `.knowledge/JESSE_KNOWLEDGE_MANAGEMENT.md` - system rules and knowledge management directives requiring complete processing
- `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` - Essential Knowledge Base with accumulated project learnings
- `.knowledge/git-clones/` directory - external repository knowledge storage with `[repo-name]_kb.md` files
- `.knowledge/work-in-progress/[current_task]/WIP_TASK.md` - active task definition and context
- `.knowledge/work-in-progress/[current_task]/PROGRESS.md` - current task progress and status tracking
- `https://github.com/cline/cline` - Cline session management system for initialization simulation

**← Referenced By:**
- `/jesse_wip_task_create.md` - workflow requiring complete session initialization as prerequisite
- `/jesse_wip_task_switch.md` - workflow benefiting from full context loading and system state verification
- `/jesse_wip_task_capture_knowledge.md` - workflow requiring active knowledge management rule enforcement
- Development workflows - consume initialized session state for consistent knowledge management operation
- Debugging procedures - use session reset functionality for troubleshooting knowledge management issues

**⚡ System role and ecosystem integration:**
- **System Role**: Critical session initialization workflow within the Jesse Framework knowledge management ecosystem, serving as the authoritative method for ensuring complete system state compliance and context loading
- **Ecosystem Position**: Core infrastructure component providing mandatory initialization services for all knowledge management operations, essential for maintaining system consistency and rule adherence
- **Integration Pattern**: Invoked by developers through direct command execution, serves as prerequisite for other workflows, and provides session state reset functionality while preserving persistent knowledge and active task context

######### Edge Cases & Error Handling

The workflow handles missing or inaccessible knowledge files through immediate execution termination with specific failure point reporting and exact remediation step provision. Corrupted or inconsistent knowledge base content triggers verification failure with detailed error reporting and resolution guidance. Session state inconsistencies are resolved through complete system reset while preserving persistent knowledge and WIP task progress. File permission issues during knowledge loading provide clear access configuration guidance and alternative loading strategies. Network connectivity problems affecting external repository access implement graceful degradation with offline knowledge processing capabilities. Incomplete WIP task context scenarios trigger comprehensive task identification and progress reconstruction procedures with user guidance for manual context restoration.

########## Internal Implementation Details

The system rules reload mechanism performs complete file reading with content processing and session flag reset functionality. Essential Knowledge Base loading implements comprehensive content analysis with knowledge gap identification and consistency validation algorithms. Git clone knowledge loading uses directory scanning with repository verification and storage policy compliance checking. WIP task context loading employs active task identification through Essential Knowledge Base analysis and comprehensive file loading from task-specific directories. Status summary generation uses structured template processing with dynamic content insertion and comprehensive resource listing. Compliance verification implements rule activation checking with automatic knowledge capture enablement and consistency maintenance protocol activation. Session readiness confirmation uses multi-phase validation with completion status verification and user notification formatting.

########### Code Usage Examples

This example demonstrates basic workflow invocation for complete session initialization. The command triggers mandatory execution of all initialization steps without conditional logic or shortcuts.

```bash
User: /wip_stack_new_session
```

This example shows workflow usage with specific focus on current task context. The initialization process emphasizes WIP task progress and immediate next actions while maintaining complete system loading.

```bash
User: /wip_stack_new_session
Focus on the current WIP task progress and next actions.
```

This example illustrates workflow invocation after suspected system issues. The complete reinitialization addresses potential missed initialization steps and ensures full compliance with knowledge management rules.

```bash
User: /wip_stack_new_session
I think Cline missed some initialization steps. Please reload everything.
```

This example demonstrates the structured status summary output format providing comprehensive system state information. The template ensures consistent reporting of all loaded knowledge components and session readiness status.

```markdown
=== KNOWLEDGE MANAGEMENT SYSTEM STATUS ===
✓ System Rules: Loaded from JESSE_KNOWLEDGE_MANAGEMENT.md
✓ Essential Knowledge: [summary of key project knowledge]
✓ Git Clones: [list of available repositories and their status]
✓ Active WIP Task: [task_name] | Status: [current_status]
✓ Session State: Fully initialized and compliant

Current Task Context:
- Purpose: [WIP task purpose]
- Progress: [current progress summary]
- Next Actions: [immediate next steps]
- Priority: [task priority level]

Available Resources:
- [list of key knowledge resources]
- [list of relevant git clone repositories]
- [list of related documentation files]
=== END STATUS SUMMARY ===
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_process_large_file.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This file defines the comprehensive `WIP Task Process Large File Workflow` for handling files exceeding 4000 lines from git clones that surpass context window limits, providing detailed indexing and structured access patterns for efficient future reference within the Jesse Framework ecosystem. The workflow delivers systematic large file processing through ten execution steps including file identification, structure indexing, access pattern generation, and comprehensive documentation creation. Key semantic entities include the 4000-line threshold specification, `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` integration for file tracking, `Large Files Requiring Processing` section identification, priority-based processing with `**before any other tasks**` markers, `wc -l` command for line counting verification, comprehensive file structure indexing with function/class mapping and section identification, access pattern generation using `sed` and `grep` commands, `[repo-name]_kb.md` documentation targets, `ISO timestamp` formatting for processing records, quality assurance protocols with accuracy verification requirements, command-line tool integration for validation, and post-processing actions including knowledge base updates and processing summaries. The system enables developers to efficiently process and access large codebase files while maintaining structured documentation and creating reusable access patterns for complex file navigation.

##### Main Components

The workflow contains ten primary execution steps: file identification from persistent knowledge base with priority assessment, file selection with user interaction and processing confirmation, file size verification using `wc -l` and accessibility checking, comprehensive file structure indexing including line-by-line analysis and function mapping, access pattern generation with `sed` and `grep` command creation, code pattern and architecture analysis for high-level insights, detailed file documentation generation in repository knowledge bases, index accuracy verification using command-line validation, knowledge base file updates across multiple storage locations, and processing summary generation with statistics and recommendations. Supporting components include file analysis techniques for different programming languages, pattern recognition for design and architectural patterns, dependency mapping for external and internal references, workflow completion verification procedures, comprehensive error handling for accessibility and processing failures, and quality assurance protocols ensuring accuracy and completeness before marking files as processed.

###### Architecture & Design

The architecture implements a comprehensive file processing pipeline with structured indexing and documentation generation patterns. The design uses priority-based file selection from persistent knowledge tracking, systematic structure analysis with line-number precision indexing, and multi-format access pattern generation supporting various extraction methods. The system employs language-specific analysis techniques for different file types, comprehensive documentation templates with structured markdown formatting, and validation protocols ensuring accuracy through command-line tool verification. The workflow follows a quality-first approach with accuracy checking, completeness verification, and usability testing before completion, while maintaining integration with existing knowledge management systems through multiple knowledge base updates and cross-referencing capabilities.

####### Implementation Approach

The implementation uses systematic file identification through knowledge base scanning with priority-based selection algorithms, comprehensive structure analysis employing line-by-line scanning with function and class mapping, and access pattern generation creating `sed` and `grep` command templates for efficient content extraction. The approach employs language-specific analysis techniques with pattern recognition for architectural insights, structured documentation generation using markdown templates with dynamic content insertion, and validation protocols using command-line tools for accuracy verification. File processing operations implement chunk definition with logical boundaries, dependency mapping with location tracking, and integration point identification for system understanding. Quality assurance uses statistical sampling for accuracy verification and comprehensive testing of generated access patterns.

######## External Dependencies & Integration Points

**→ References:**
- `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` - persistent knowledge repository tracking files requiring processing with priority markers
- `[repo-name]_kb.md` files - repository-specific knowledge bases requiring detailed file documentation updates
- `wc -l` command-line tool - line counting utility for file size verification and threshold validation
- `sed` command-line tool - stream editor for content extraction pattern generation and validation
- `grep` command-line tool - pattern matching utility for content search and function identification
- `Essential Knowledge Base` - central knowledge coordination requiring updates for critical project information

**← Referenced By:**
- Git clone processing workflows - consume large file processing results for comprehensive repository analysis
- Development workflows - reference indexed large files for implementation guidance and pattern understanding
- Knowledge management workflows - use processed file documentation for cross-referencing and consistency maintenance
- Code analysis workflows - leverage structural indexes and access patterns for efficient large file navigation

**⚡ System role and ecosystem integration:**
- **System Role**: Specialized large file processing workflow within the Jesse Framework knowledge management ecosystem, serving as the primary mechanism for handling files exceeding context window limits through structured indexing and access pattern generation
- **Ecosystem Position**: Core processing component bridging git clone repositories with knowledge management systems through comprehensive file analysis and documentation generation
- **Integration Pattern**: Triggered by priority-based file identification from persistent knowledge tracking, consumes command-line tools for analysis and validation, produces structured documentation and access patterns for consumption by development and knowledge management workflows

######### Edge Cases & Error Handling

The workflow handles inaccessible files by marking them as `processing failed` with specific reason documentation and preservation of partial analysis results. Binary or encrypted files trigger limitation notation with analysis skipping while maintaining processing records for future reference. Line counting failures implement estimation based on file size with continued processing using approximate metrics. Incomplete indexing scenarios preserve partial results with limitation documentation and fallback option provision for manual completion. Automated analysis failures provide alternative processing methods with user guidance for manual intervention. File permission issues during processing implement graceful degradation with alternative access strategies and clear error reporting for resolution guidance.

########## Internal Implementation Details

The file identification mechanism scans `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` for `Large Files Requiring Processing` sections with priority parsing and file detail extraction. Structure indexing implements line-by-line scanning with function definition detection, class boundary identification, and section mapping using language-specific patterns. Access pattern generation creates command templates with line number substitution, content extraction optimization, and validation command generation. Documentation generation uses structured markdown templates with dynamic content insertion, line reference formatting, and cross-reference linking. Quality assurance implements statistical sampling with random line reference validation, completeness checking through major component verification, and usability testing with access pattern execution. Knowledge base updates target multiple files with section-specific insertion and timestamp maintenance for accurate change tracking.

########### Code Usage Examples

This example demonstrates file identification and priority assessment from the persistent knowledge base. The structured approach ensures systematic processing of large files based on priority markers and processing requirements.

```bash
# Check for files requiring processing with priority assessment
grep -A 10 "Large Files Requiring Processing" .knowledge/persistent-knowledge/KNOWLEDGE_BASE.md
```

This example shows line counting verification and file accessibility checking before processing initiation. The validation ensures accurate threshold assessment and processing feasibility determination.

```bash
# Verify file size and accessibility for processing threshold validation
wc -l /path/to/large/file.py
test -r /path/to/large/file.py && echo "File accessible" || echo "Access denied"
```

This example illustrates comprehensive structure indexing with function and class mapping. The systematic analysis creates detailed indexes with precise line number references for efficient future access.

```bash
# Generate function and class index with line numbers for structure mapping
grep -n "^def \|^class \|^function " /path/to/large/file.py > structure_index.txt
```

This example demonstrates access pattern generation with `sed` and `grep` command creation. The templates enable efficient content extraction and navigation for large file sections.

```bash
# Extract specific function using generated sed command for content access
sed -n '150,200p' /path/to/large/file.py  # Extract lines 150-200
grep -n "specific_pattern" /path/to/large/file.py  # Find pattern occurrences
```

This example shows the structured documentation template for comprehensive file analysis results. The markdown format ensures consistent documentation with detailed access patterns and architectural insights.

```markdown
## Large File: example_service.py (5500 lines)
*Last Processed: 2024-01-15T10:30:00Z*

### Structure Index
#### Functions/Methods (45 total)
- `initialize_service()` (lines 50-75): Service initialization and configuration
- `ServiceClass.process_request()` (lines 200-350): Main request processing logic

### Access Patterns
#### Extract Specific Function
```bash
sed -n '50,75p' example_service.py
```

#### Find Function Definitions
```bash
grep -n "^def \|^class " example_service.py
```
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows/jesse_wip_task_switch.md

*Last Updated: 2025-07-06T10:11:00Z*

#### Functional Intent & Features

This workflow specification defines the complete process for safely switching between existing Work-in-Progress tasks within the Jesse Framework development environment. The functional intent centers on providing developers with a robust task context switching mechanism that maintains Git repository integrity while preserving task state and progress information. Key semantic entities include `git status --porcelain` for repository validation, `.knowledge/work-in-progress/` directory structure for task storage, `WIP_TASK.md` and `PROGRESS.md` files for task metadata, `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` for Essential Knowledge Base updates, and `git checkout` operations for branch switching. The workflow provides comprehensive Git safety validation, multi-task warning systems, branch compatibility checking, and automated context loading to ensure seamless transitions between parallel development efforts without data loss or state corruption.

##### Main Components

The workflow contains seven primary execution steps: Git Repository Safety Validation, List Available WIP Tasks, Display Multiple WIP Tasks Warning, Display Current Active Task, Prompt for Task Selection, Git Branch Safety Validation, Load Selected Task Context, and Update Essential Knowledge Base. Additional components include comprehensive error handling for uncommitted changes, branch switch failures, and missing task files, plus special case handling for scenarios like no active tasks, same task selection, and detached HEAD states. The workflow integrates with the Jesse Framework's knowledge management system through specific file structures and validation checkpoints.

###### Architecture & Design

The architectural design implements a multi-stage validation pattern with fail-fast error handling and rollback capabilities. The workflow follows a linear progression with mandatory safety checkpoints at each Git operation, ensuring repository integrity throughout the switching process. The design separates concerns between Git operations, file system interactions, and knowledge base updates, allowing for granular error recovery and state consistency. Branch switching operations are isolated with explicit user confirmation, while task context loading operates independently of Git state changes to prevent partial failures.

####### Implementation Approach

The implementation strategy utilizes Git porcelain commands for repository state validation, file system scanning for task discovery, and structured markdown parsing for task metadata extraction. The workflow employs conditional branching based on Git repository state, with explicit user prompts for potentially destructive operations like branch switching. Task context loading involves parsing multiple markdown files to extract objective, progress, and milestone information, while Essential Knowledge Base updates follow a structured template format for consistency across task switches.

######## External Dependencies & Integration Points

**→ References:** [external systems and files this workflow depends on]
- `git status --porcelain` - Git repository state validation command
- `.knowledge/work-in-progress/` - task storage directory structure
- `WIP_TASK.md` - individual task definition and context files
- `PROGRESS.md` - task progress tracking and milestone files
- `.clinerules/JESSE_KNOWLEDGE_MANAGEMENT.md` - Essential Knowledge Base file
- `git checkout` - Git branch switching operations

**← Referenced By:** [systems that invoke this workflow]
- Jesse Framework task management system - primary workflow consumer
- Developer workflow automation tools - task switching triggers
- CI/CD pipeline integration - automated task context management

**⚡ System role and ecosystem integration:**
- **System Role**: Serves as the core task switching orchestrator within the Jesse Framework development workflow, coordinating Git operations with knowledge management systems
- **Ecosystem Position**: Central component bridging Git repository management with task-based development workflows, ensuring data integrity during context switches
- **Integration Pattern**: Invoked by developers through command-line interfaces or IDE integrations, with dependencies on Git CLI tools and file system access for task metadata management

######### Edge Cases & Error Handling

The workflow addresses multiple critical error scenarios including uncommitted changes detection with immediate failure and clear resolution guidance, Git branch switch failures with automatic rollback to previous branch state, missing or corrupted task files with template recreation options, and Essential Knowledge Base update failures with previous active task restoration. Special handling covers no WIP tasks scenarios with creation workflow suggestions, partial switch failures ensuring complete success or rollback, branch validation errors for missing Git integration information, and detached HEAD state management for repository consistency.

########## Internal Implementation Details

The internal implementation relies on Git porcelain command parsing for repository state detection, directory traversal algorithms for task discovery excluding archived tasks, markdown file parsing for extracting task metadata including objectives and progress percentages, and template-based Essential Knowledge Base updates with timestamp management. The workflow maintains internal state tracking for rollback operations, implements atomic operations for Git branch switching, and utilizes structured error reporting with specific resolution guidance for each failure scenario.

########### Code Usage Examples

The following examples demonstrate key workflow validation patterns. Git safety validation ensures clean working directory before task switching:

```bash
# Git repository state validation command
git status --porcelain
```

Task selection interface provides numbered options with branch information:

```markdown
# Available WIP Tasks:
1️⃣ feature-authentication (branch: auth-implementation) - 65% complete
2️⃣ api-refactoring (branch: api-cleanup) - 30% complete
3️⃣ documentation-update (branch: main) - 85% complete
```

Branch switching confirmation dialog for different target branches:

```markdown
⚠️ Git Branch Switch Required
Current Task: feature-authentication
Current Branch: auth-implementation
Target Task: api-refactoring
Target Branch: api-cleanup
Continue with branch switch? [1/2]:
```

---
*Generated: 2025-07-06T10:11:00Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/embedded_content/workflows*
*Total Files: 16*
*Total Subdirectories: 0*

# End of workflows_kb.md