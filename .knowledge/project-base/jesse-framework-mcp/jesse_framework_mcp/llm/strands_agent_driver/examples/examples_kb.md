<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples/

## Global Summary

#### Functional Intent & Features

This directory implements a comprehensive collection of educational demonstration scripts for the Claude 4 Sonnet driver within the Jesse Framework MCP Server ecosystem, providing hands-on examples of AWS Bedrock integration patterns including basic conversations, streaming responses, prompt caching optimization, and reasoning suppression capabilities for developer learning and validation purposes. The examples directory enables developers to understand and implement advanced AI conversation features through practical, executable demonstrations with detailed performance analysis and comprehensive error handling. Key semantic entities include `StrandsClaude4Driver` class for AWS Bedrock Claude 4 integration, `Claude4SonnetConfig` configuration class with factory methods `create_optimized_for_conversations()`, `create_optimized_for_analysis()`, and `create_optimized_for_performance()`, core methods `start_conversation()`, `send_message()`, `stream_conversation()`, and `get_conversation_stats()`, configuration parameters `streaming`, `enable_prompt_caching`, `suppress_reasoning_output`, `cache_ttl_seconds`, `max_cache_entries`, and `temperature`, response attributes `content`, `tokens_used`, `from_cache`, and `is_complete`, exception classes `BedrockConnectionError` and `StrandsDriverError`, AWS environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, performance measurement using `time.time()`, comprehensive documentation in `README.md`, and async-first architecture with context manager patterns for resource lifecycle management and detailed console output formatting for educational demonstration purposes.

##### Main Components

The directory contains five primary files providing comprehensive coverage of Claude 4 Sonnet driver capabilities and educational guidance. The `basic_conversation.py` script demonstrates fundamental conversation patterns with sequential question-answer interactions, response metadata collection, and statistics tracking. The `streaming_conversation.py` script showcases real-time response delivery through chunk-based streaming with performance comparison analysis between streaming and non-streaming modes. The `caching_example.py` script illustrates prompt caching optimization with cache hit analysis, performance measurement, and cache management strategies including eviction testing. The `reasoning_suppression_demo.py` script explores reasoning output control with side-by-side comparisons of suppressed versus enabled reasoning modes and configuration override examples. The `README.md` documentation provides comprehensive setup instructions, configuration examples, troubleshooting guidance, and integration patterns for Jesse MCP Server applications with detailed console output samples and performance metrics explanations.

###### Architecture & Design

The architecture implements a demonstration-focused design pattern with clear separation between educational examples and comprehensive documentation, following progressive complexity from basic conversation concepts to advanced optimization strategies. The design emphasizes hands-on learning through executable scripts with detailed console output formatting, performance measurement, and statistical analysis for educational value. Key design patterns include the educational demonstration pattern with structured question sequences and comprehensive output formatting, performance comparison pattern with side-by-side timing analysis, factory method pattern usage for optimized configurations, async context manager pattern for resource management, streaming response pattern for real-time user experience, cache optimization pattern for performance improvement, and configuration override pattern for customization flexibility. The system uses conversation isolation through unique identifiers, comprehensive exception handling with specific error types, structured console formatting with emoji indicators and section dividers, and detailed documentation with executable examples and troubleshooting guidance.

####### Implementation Approach

The implementation uses async-first architecture with comprehensive context manager patterns for proper resource lifecycle management across all demonstration scripts. Configuration management employs factory method patterns with explicit parameter overrides for different optimization strategies including conversations, analysis, and performance scenarios. Performance measurement implements high-precision timing using `time.time()` with detailed statistical analysis including response times, cache hit rates, chunk processing metrics, and user experience impact calculations. Error handling uses specific exception types with graceful degradation and informative error messages including troubleshooting guidance and setup instructions. Console output employs structured formatting with emoji indicators, section dividers, performance metrics display, and detailed explanatory text to enhance educational value. Documentation integration provides comprehensive setup instructions, configuration examples, and integration patterns with executable code samples and detailed output explanations.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for demonstration execution, streaming processing, and timing measurements across all example scripts
- `sys` (external library) - Python path manipulation for module imports and exit handling with status codes for proper demonstration lifecycle management
- `os` (external library) - environment variable access for AWS credentials and region configuration with comprehensive validation and setup guidance
- `time` (external library) - high-precision timing measurements for performance analysis, cache comparison, and streaming metrics collection
- `logging` (external library) - structured logging setup with timestamp formatting for debugging and educational output enhancement
- `pathlib.Path` (external library) - cross-platform path operations for module import path construction and file system compatibility
- `strands_agent_driver:StrandsClaude4Driver` - main driver class for AWS Bedrock Claude 4 integration with conversation management, streaming, and caching capabilities
- `strands_agent_driver:Claude4SonnetConfig` - configuration class with factory methods and parameter customization for optimization strategies
- `strands_agent_driver:StrandsDriverError` - driver-specific exception handling for operational error management
- `strands_agent_driver:BedrockConnectionError` - AWS Bedrock connection error handling for authentication and access issues
- `Amazon Bedrock` service - AWS managed AI service providing Claude 4 Sonnet model access and API integration
- `uv` package manager - Python dependency management and virtual environment handling for example execution

**← Outbound:**
- Developer education workflows - consuming demonstration outputs for understanding Claude 4 Sonnet driver capabilities and AWS Bedrock integration patterns
- Jesse Framework MCP Server integration projects - using configuration examples and implementation patterns for production deployment
- Performance testing and validation processes - using example results to verify driver functionality, optimization strategies, and user experience improvements
- Documentation and training materials - referencing example outputs, configuration patterns, and troubleshooting guidance for educational content
- AWS Bedrock service integration - generating actual API calls, streaming responses, and cache operations for live demonstration when credentials are available

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive educational demonstration hub for Claude 4 Sonnet driver within Jesse Framework MCP Server ecosystem, providing hands-on examples of AWS Bedrock integration, performance optimization, and advanced conversation features for developer learning and validation
- **Ecosystem Position**: Peripheral educational component supporting developer adoption and integration of core driver functionality, bridging standalone examples with production MCP server usage through practical demonstrations and comprehensive documentation
- **Integration Pattern**: Used by developers through direct script execution for learning driver capabilities, consumed by integration projects for configuration guidance and implementation patterns, referenced by educational workflows for hands-on learning experiences, and integrated with AWS Bedrock services for live demonstration when proper credentials are configured

######### Edge Cases & Error Handling

The system handles missing AWS credentials gracefully across all examples by detecting environment variables and providing comprehensive setup guidance without failing demonstrations. AWS Bedrock connection errors are managed with specific exception handling including detailed troubleshooting steps for credential validation, service access verification, and model availability confirmation. Driver operational errors are caught with descriptive error messages and fallback behavior to educational content when live demonstrations fail. Keyboard interrupts are handled with clean exit messages and proper signal handling using structured exit codes. Performance measurement edge cases include zero response times, division by zero scenarios, and infinity handling for speedup calculations with appropriate conditional logic. Streaming interruption scenarios and incomplete chunk processing are managed with comprehensive exception handling and graceful degradation. Cache statistics retrieval handles missing or unavailable data with conditional display logic and error reporting. The documentation provides fallback testing approaches for environments without AWS access through local test suite execution and comprehensive troubleshooting guidance for common setup issues.

########## Internal Implementation Details

The demonstration scripts use hardcoded test questions designed to trigger specific Claude 4 Sonnet behaviors including reasoning processes, longer responses for streaming, and cache-friendly repeated queries for effective feature demonstration. Configuration management employs explicit parameter values including temperature settings (0.7, 0.8), cache TTL (300 seconds), cache size limits (10, 3 entries), and streaming enablement flags with detailed transparency in console output. Performance timing uses millisecond precision measurements with comprehensive statistical calculations including speedup ratios, cache hit rates, chunk processing metrics, and user experience impact analysis. Conversation IDs are explicitly set with descriptive names for clear session isolation and educational clarity. Console output uses structured formatting with specific emoji indicators, section dividers using `=` and `-` characters, detailed statistical reporting including percentages and ratios, and comprehensive explanatory text for enhanced educational value. Error handling implements specific exception types with detailed error messages, graceful degradation paths, and comprehensive troubleshooting guidance including AWS region information and credential setup instructions.

########### Usage Examples

Basic driver initialization demonstrates the foundational pattern for Claude 4 Sonnet integration with factory method configuration. This approach provides the essential setup pattern used across all demonstration scripts for consistent driver initialization and resource management.

```python
# Initialize Claude 4 Sonnet driver with factory method configuration for educational demonstrations
from strands_agent_driver import StrandsClaude4Driver, Claude4SonnetConfig

config = Claude4SonnetConfig.create_optimized_for_conversations()
async with StrandsClaude4Driver(config) as driver:
    conversation_id = "educational_example"
    await driver.start_conversation(conversation_id, {"example": "demonstration"})
```

Comprehensive feature demonstration showcases the integration pattern combining multiple driver capabilities for advanced use cases. This pattern demonstrates how to leverage streaming, caching, and performance measurement together for optimal user experience and educational value.

```python
# Comprehensive demonstration combining streaming, caching, and performance measurement
config = Claude4SonnetConfig(
    streaming=True,
    enable_prompt_caching=True,
    cache_ttl_seconds=300,
    max_cache_entries=10,
    temperature=0.7
)

async with StrandsClaude4Driver(config) as driver:
    await driver.start_conversation("comprehensive_demo")
    
    # Measure streaming performance with caching
    start_time = time.time()
    full_response = ""
    chunk_count = 0
    
    async for chunk in driver.stream_conversation("Explain machine learning concepts", "comprehensive_demo"):
        print(chunk.content, end="", flush=True)
        full_response += chunk.content
        chunk_count += 1
        if chunk.is_complete:
            break
    
    # Display comprehensive metrics
    end_time = time.time()
    stats = await driver.get_conversation_stats("comprehensive_demo")
    print(f"Streaming time: {end_time - start_time:.2f}s")
    print(f"Chunks: {chunk_count}, Tokens: {stats['total_tokens']}")
```

## Subdirectory Knowledge Integration

*No subdirectories processed*

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples/basic_conversation.py

*Last Updated: 2025-07-05T12:16:42Z*

#### Functional Intent & Features

This file implements a basic conversation demonstration script for the Claude 4 Sonnet driver, showcasing fundamental conversation capabilities through sequential question-answer interactions with comprehensive statistics tracking and error handling for educational and testing purposes. The script enables developers to understand and validate basic conversation patterns with the Strands Agent Driver system using live AWS Bedrock integration, demonstrating conversation lifecycle management and response metadata collection. Key semantic entities include `basic_conversation_example()` function for primary conversation demonstration, `StrandsClaude4Driver` class for AWS Bedrock integration, `Claude4SonnetConfig` configuration class with factory method `create_optimized_for_conversations()`, `start_conversation()` method for session initialization, `send_message()` method for message processing, `get_conversation_stats()` method for statistics retrieval, conversation identifier `basic_example_conversation`, response attributes `content`, `tokens_used`, and `from_cache`, configuration properties `model_id`, `temperature`, `memory_strategy`, `enable_prompt_caching`, `enable_extended_thinking`, and `suppress_reasoning_output`, `BedrockConnectionError` and `StrandsDriverError` exception classes, AWS environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, and comprehensive logging setup with structured formatting. The system implements async-first architecture with context manager patterns for resource lifecycle management and detailed console output formatting for educational demonstration purposes.

##### Main Components

The file contains two primary async functions providing comprehensive basic conversation demonstration capabilities. The `basic_conversation_example()` function performs the main conversation demonstration with predefined question sequences, response metadata display, conversation statistics collection, and global driver statistics reporting. The `main()` function serves as the orchestration entry point with AWS credential validation, region detection, and error handling for the demonstration execution. The script includes structured logging configuration with timestamp formatting, path manipulation for module imports, and detailed console output with emoji-based visual indicators for different conversation phases. The conversation flow uses a predefined list of four questions covering introduction, AI benefits, prompt caching explanation, and conversation closure with systematic processing and metadata reporting for each interaction.

###### Architecture & Design

The architecture implements a demonstration-focused design pattern with clear separation between conversation execution and orchestration logic, following educational progression through structured question sequences and comprehensive output formatting. The design emphasizes conversation lifecycle management through proper session initialization, message processing, and statistics collection. Key design patterns include the demonstration pattern with sequential question processing, factory method pattern usage for optimized configuration, async context manager pattern for resource management, and educational pattern with detailed explanatory output and metadata display. The system uses conversation isolation through unique identifiers, comprehensive exception handling with specific error types, and structured console formatting with emoji indicators and section dividers for enhanced readability.

####### Implementation Approach

The implementation uses async context managers for proper resource lifecycle management with `StrandsClaude4Driver` instances and factory method configuration through `create_optimized_for_conversations()` for optimized settings. Conversation processing employs sequential question iteration with `asyncio.sleep(1)` delays between questions for demonstration pacing. Response handling includes comprehensive metadata extraction and display including token usage, cache status, and content presentation. The approach implements detailed statistics collection at both conversation and global levels with structured data presentation. Error handling uses specific exception types with user-friendly error messages and troubleshooting guidance. Console output employs structured formatting with emoji indicators, section dividers, and detailed explanatory text to enhance educational value.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for demonstration execution and sleep delays between questions
- `sys` (external library) - Python path manipulation for module imports and exit handling with status codes
- `os` (external library) - environment variable access for AWS credentials and region configuration
- `logging` (external library) - structured logging setup with timestamp formatting and level configuration
- `pathlib.Path` (external library) - cross-platform path operations for module import path construction
- `strands_agent_driver:StrandsClaude4Driver` - main driver class for AWS Bedrock Claude 4 integration and conversation management
- `strands_agent_driver:Claude4SonnetConfig` - configuration class with factory methods for optimized conversation settings
- `strands_agent_driver:StrandsDriverError` - driver-specific exception handling for operational errors
- `strands_agent_driver:BedrockConnectionError` - AWS Bedrock connection error handling for authentication issues

**← Outbound:**
- Developer education workflows - consuming basic conversation demonstration output for understanding driver usage patterns
- Testing and validation processes - using conversation results to verify basic driver functionality and response handling
- Documentation and training materials - referencing conversation patterns and configuration examples for educational content
- AWS Bedrock service integration - generating actual API calls for live conversation demonstration when credentials are available

**⚡ System role and ecosystem integration:**
- **System Role**: Educational demonstration component for Strands Agent Driver basic conversation capabilities, providing foundational examples of conversation lifecycle management and response processing for developers learning the system
- **Ecosystem Position**: Peripheral educational component supporting developer onboarding and basic functionality validation, demonstrating core driver conversation features without being part of production workflows
- **Integration Pattern**: Used by developers through direct script execution for learning basic conversation patterns, consumed by educational processes for driver capability demonstration, and integrated with AWS Bedrock services for live conversation testing when proper credentials are configured

######### Edge Cases & Error Handling

The system handles missing AWS credentials gracefully by detecting environment variables and providing informative warnings with setup guidance without failing the demonstration. AWS Bedrock connection errors are caught with specific `BedrockConnectionError` handling and detailed troubleshooting steps including credential validation, Bedrock access verification, and model access confirmation. Driver operational errors are managed through `StrandsDriverError` exception handling with descriptive error messages. Keyboard interrupts are handled with clean exit messages and proper signal handling using `sys.exit(1)`. The script manages conversation initialization failures and message sending errors with comprehensive exception handling. Statistics retrieval handles missing or unavailable data gracefully with conditional display logic and error reporting.

########## Internal Implementation Details

The demonstration uses a hardcoded list of four questions including introduction, AI benefits inquiry, prompt caching explanation, and conversation closure for consistent educational flow. Configuration display shows specific properties including `model_id`, `temperature`, `memory_strategy.value`, `enable_prompt_caching`, `enable_extended_thinking`, and `suppress_reasoning_output` for comprehensive configuration transparency. Conversation ID is explicitly set to `basic_example_conversation` for clear session identification. Response processing includes content display with section dividers using `-` characters and metadata reporting including token usage and cache status. Statistics collection accesses both conversation-specific and global driver statistics with structured data presentation. Console output uses structured formatting with specific emoji indicators and detailed explanatory text for enhanced educational value.

########### Code Usage Examples

Basic conversation setup demonstrates the essential pattern for Claude 4 Sonnet driver initialization and configuration. This approach shows factory method usage for optimized conversation settings and proper async context management for resource lifecycle.

```python
# Initialize Claude 4 Sonnet driver with optimized conversation configuration
config = Claude4SonnetConfig.create_optimized_for_conversations()
async with StrandsClaude4Driver(config) as driver:
    conversation_id = "basic_example_conversation"
    await driver.start_conversation(conversation_id, {"example": "basic"})
```

Sequential conversation processing showcases the pattern for structured question-answer interactions with comprehensive metadata collection. This pattern demonstrates proper message sending, response handling, and statistics tracking for educational conversation flows.

```python
# Process sequential questions with response metadata and statistics tracking
questions = [
    "Hello! Can you introduce yourself?",
    "What are the key benefits of using AI in software development?",
    "Can you explain what prompt caching is and why it's useful?",
    "Thank you for the conversation!"
]

for i, question in enumerate(questions, 1):
    print(f"👤 Question {i}: {question}")
    response = await driver.send_message(question, conversation_id)
    print(response.content)
    print(f"📊 Tokens used: {response.tokens_used}")
    print(f"💾 From cache: {response.from_cache}")
    
    if i < len(questions):
        await asyncio.sleep(1)
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples/caching_example.py

*Last Updated: 2025-07-05T12:16:42Z*

#### Functional Intent & Features

This file implements a comprehensive demonstration script for prompt caching capabilities in the Claude 4 Sonnet driver, showcasing performance optimization through cache hit analysis, response time comparisons, and cache management strategies for educational and testing purposes. The script enables developers to understand and validate the behavior of prompt caching configurations with live AWS Bedrock integration, demonstrating cost savings and performance improvements through repeated query optimization. Key semantic entities include `caching_demonstration()` function for primary cache testing, `cache_efficiency_test()` function for cache eviction and hit rate analysis, `StrandsClaude4Driver` class for AWS Bedrock integration, `Claude4SonnetConfig` configuration class with caching parameters, `enable_prompt_caching` configuration flag, `cache_ttl_seconds` TTL configuration with 300-second default, `max_cache_entries` size limit configuration, `from_cache` response attribute for cache hit detection, `send_message()` method for cached message processing, `get_conversation_stats()` method for cache statistics retrieval, `clear_conversation()` method for cache reset functionality, conversation identifiers `caching_example_conversation` and `cache_efficiency_test`, `BedrockConnectionError` and `StrandsDriverError` exception classes, and comprehensive performance metrics collection including response times, cache hit rates, and cost savings analysis. The system implements async-first architecture with detailed console output formatting and educational demonstration patterns.

##### Main Components

The file contains three primary async functions providing comprehensive prompt caching demonstration and analysis capabilities. The `caching_demonstration()` function performs the main caching test with identical question repetition, cache sensitivity analysis with question variations, and cache expiration demonstration through conversation clearing. The `cache_efficiency_test()` function implements cache eviction testing with a smaller cache size limit, multiple different questions to trigger cache replacement, and detailed hit rate analysis with statistical reporting. The `main()` function serves as the orchestration entry point with AWS credential validation, region detection, and sequential execution of both demonstration functions with comprehensive error handling and educational summary output. The script includes detailed performance timing using `time.time()` measurements, cache statistics retrieval and display, and structured console output with emoji-based visual indicators for different test phases.

###### Architecture & Design

The architecture implements a demonstration-focused design pattern with clear separation between basic caching validation and advanced cache efficiency testing, following educational progression from simple cache hits to complex eviction scenarios. The design emphasizes performance measurement and comparison through detailed timing analysis and statistical reporting. Key design patterns include the demonstration pattern with before-and-after performance comparisons, cache sensitivity testing pattern with question variations, cache eviction testing pattern with limited cache size, and educational pattern with detailed explanatory output and key takeaways. The system uses async context manager patterns for resource management, conversation isolation through unique identifiers, and comprehensive exception handling with specific error types and user-friendly messages for different failure scenarios.

####### Implementation Approach

The implementation uses async context managers for proper resource lifecycle management with `StrandsClaude4Driver` instances and explicit cache configuration through `Claude4SonnetConfig` parameters. Performance measurement employs `time.time()` before and after message sending with precise timing calculations and speedup ratio analysis. Cache testing uses identical question repetition to demonstrate cache hits, question variations to show cache sensitivity, and conversation clearing to reset cache state for controlled testing. The approach implements comprehensive error handling with specific exception types for AWS Bedrock connection issues and driver errors. Console output uses structured formatting with emoji indicators, performance metrics display, and detailed statistical analysis including cache hit rates, response time comparisons, and cost savings calculations.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for demonstration execution and timing measurements
- `sys` (external library) - Python path manipulation for module imports and exit handling with status codes
- `os` (external library) - environment variable access for AWS credentials and region configuration
- `time` (external library) - high-precision timing measurements for performance analysis and cache comparison
- `pathlib.Path` (external library) - cross-platform path operations for module import path construction
- `strands_agent_driver:StrandsClaude4Driver` - main driver class for AWS Bedrock Claude 4 integration with caching support
- `strands_agent_driver:Claude4SonnetConfig` - configuration class with prompt caching parameters and TTL settings
- `strands_agent_driver:StrandsDriverError` - driver-specific exception handling for operational errors
- `strands_agent_driver:BedrockConnectionError` - AWS Bedrock connection error handling for authentication issues

**← Outbound:**
- Developer education workflows - consuming caching demonstration output for understanding performance optimization strategies
- Performance testing and validation processes - using cache efficiency results to verify driver caching functionality
- Documentation and training materials - referencing cache performance metrics and optimization patterns for educational content
- AWS Bedrock service integration - generating actual API calls and cache operations for live demonstration when credentials are available

**⚡ System role and ecosystem integration:**
- **System Role**: Educational demonstration component for Strands Agent Driver prompt caching feature, providing hands-on performance analysis and cache optimization examples for developers learning efficient API usage patterns
- **Ecosystem Position**: Peripheral educational component supporting developer understanding of caching strategies and performance optimization, demonstrating core driver functionality without being part of production workflows
- **Integration Pattern**: Used by developers through direct script execution for learning cache optimization, consumed by performance testing processes for validation, and integrated with AWS Bedrock services for live cache demonstration when proper credentials are configured

######### Edge Cases & Error Handling

The system handles missing AWS credentials gracefully by detecting environment variables and providing informative warnings without failing the demonstration. AWS Bedrock connection errors are caught with specific `BedrockConnectionError` handling and user-friendly messages explaining authentication requirements. Driver operational errors are managed through `StrandsDriverError` exception handling with detailed error context. Keyboard interrupts are handled with clean exit messages and proper signal handling using `sys.exit(1)`. The script manages cache expiration scenarios through conversation clearing and fresh conversation initialization. Performance measurement edge cases include zero response times with infinity handling for speedup calculations. Cache statistics retrieval handles missing or unavailable cache data gracefully with conditional display logic.

########## Internal Implementation Details

The demonstration uses hardcoded test questions including "What are the main principles of object-oriented programming?" for consistent cache testing and multiple variations for sensitivity analysis. Cache configuration employs specific parameter values including 300-second TTL, 10-entry maximum for main demonstration, and 3-entry maximum for efficiency testing. Performance timing uses `time.time()` measurements with millisecond precision and speedup calculations using division with infinity handling. Conversation IDs are explicitly set to `caching_example_conversation` and `cache_efficiency_test` for clear session isolation. Console output uses structured formatting with specific emoji indicators, section dividers using `=` characters, and detailed statistical reporting including percentages and ratios. Cache statistics access uses `get_conversation_stats()` with conditional checking for cache availability and structured data display.

########### Code Usage Examples

Basic prompt caching configuration demonstrates the essential setup pattern for enabling cache optimization. This approach shows explicit parameter configuration for TTL, cache size limits, and caching enablement for performance-focused applications.

```python
# Configure Claude 4 Sonnet driver with prompt caching enabled for performance optimization
config = Claude4SonnetConfig(
    enable_prompt_caching=True,
    cache_ttl_seconds=300,  # 5 minutes
    max_cache_entries=10,
    temperature=0.7
)

async with StrandsClaude4Driver(config) as driver:
    conversation_id = "caching_example_conversation"
    await driver.start_conversation(conversation_id, {"example": "caching"})
```

Cache performance measurement showcases the timing analysis pattern for comparing cached versus non-cached responses. This pattern demonstrates how to measure and analyze the performance benefits of prompt caching with detailed metrics collection.

```python
# Measure cache performance with timing analysis and hit rate detection
test_question = "What are the main principles of object-oriented programming?"

# First call - should go to API
start_time = time.time()
response1 = await driver.send_message(test_question, conversation_id)
first_call_time = time.time() - start_time

# Second call - should come from cache
start_time = time.time()
response2 = await driver.send_message(test_question, conversation_id)
second_call_time = time.time() - start_time

# Calculate performance improvement
if response2.from_cache:
    speedup = first_call_time / second_call_time if second_call_time > 0 else float('inf')
    print(f"Speed increase: {speedup:.1f}x faster")
    print(f"Response identical: {response1.content == response2.content}")
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples/README.md

*Last Updated: 2025-07-05T12:16:42Z*

#### Functional Intent & Features

This documentation provides comprehensive guidance for standalone example applications demonstrating Claude 4 Sonnet driver capabilities within the Jesse Framework MCP Server ecosystem, enabling developers to understand and implement AWS Bedrock integration patterns with practical, executable demonstrations. The content serves as both educational material and operational reference for developers working with the Strands Agent Driver system, offering step-by-step setup instructions, configuration examples, and troubleshooting guidance. Key semantic entities include `basic_conversation.py`, `streaming_conversation.py`, and `caching_example.py` example files, `Claude4SonnetConfig` configuration class with factory methods `create_optimized_for_conversations()`, `create_optimized_for_analysis()`, and `create_optimized_for_performance()`, `StrandsClaude4Driver` main driver class, AWS environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, Amazon Bedrock service integration, `ConversationMemoryStrategy.SUMMARIZING` memory management, prompt caching system with TTL configuration, streaming response processing, token usage tracking, and comprehensive error handling patterns including `NoCredentialsError`, `AccessDenied`, and model availability issues. The system implements async-first architecture with context manager patterns for resource lifecycle management and detailed performance metrics collection.

##### Main Components

The documentation contains six primary content sections providing comprehensive coverage of the Claude 4 Sonnet driver example ecosystem. The Prerequisites section outlines AWS credential configuration, Amazon Bedrock access requirements, and dependency installation procedures. The Available Examples section details three standalone demonstration scripts including basic conversation management, streaming response processing, and prompt caching optimization with specific execution commands and feature descriptions. The Example Output section provides formatted console output samples showing actual execution results with performance metrics and statistics. The Configuration Examples section demonstrates four different configuration patterns optimized for conversations, analysis, performance, and custom use cases. The Troubleshooting section addresses common issues including credential problems, access denied errors, model availability, and SDK installation with specific solutions. The Integration section shows how to incorporate the driver into Jesse MCP Server applications with practical code examples.

###### Architecture & Design

The architecture implements a documentation-first design pattern with clear separation between setup requirements, practical examples, and integration guidance, following educational progression from basic concepts to advanced implementation patterns. The design emphasizes hands-on learning through executable examples with comprehensive output formatting and detailed explanations of each feature demonstration. Key design patterns include the progressive complexity pattern moving from basic conversation to advanced caching, factory method pattern documentation for configuration optimization, troubleshooting pattern with specific error scenarios and solutions, and integration pattern showing real-world usage within the Jesse MCP Server ecosystem. The system uses structured formatting with emoji indicators, code block highlighting, and consistent section organization to enhance readability and developer experience.

####### Implementation Approach

The implementation uses executable Python scripts as primary teaching tools with comprehensive setup instructions and dependency management through `uv` package manager. Example execution employs standardized command patterns with `uv run python examples/` prefix for consistent developer experience across different environments. Configuration demonstration uses factory method patterns with specific parameter examples showing temperature settings, memory strategies, caching options, and streaming configurations. Output formatting implements structured console display with emoji indicators, section dividers, performance metrics, and detailed statistics to enhance educational value. Error handling documentation provides specific error messages with corresponding solutions and debugging approaches. Integration examples show practical usage patterns within larger application contexts with async patterns and session management.

######## External Dependencies & Integration Points

**→ References:**
- `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE` environment variables - AWS credential configuration for Bedrock service authentication
- `Amazon Bedrock` service - AWS managed AI service providing Claude 4 Sonnet model access and API integration
- `uv` package manager - Python dependency management and virtual environment handling for example execution
- `strands-agents` package - core SDK providing Claude 4 Sonnet driver implementation and configuration classes
- `basic_conversation.py`, `streaming_conversation.py`, `caching_example.py` - standalone example applications demonstrating specific driver features
- `test_strands_driver.py` - test suite for driver installation verification and functionality validation
- `requirements.txt` - Python dependency specification for alternative installation methods

**← Referenced By:**
- Developer onboarding workflows - consuming setup instructions and example execution patterns for learning driver integration
- Jesse MCP Server integration projects - using configuration examples and integration patterns for production implementation
- Documentation and training materials - referencing example outputs and troubleshooting guidance for educational content
- Testing and validation processes - using example applications for driver functionality verification and regression testing

**⚡ System role and ecosystem integration:**
- **System Role**: Educational documentation hub for Claude 4 Sonnet driver within Jesse Framework MCP Server ecosystem, providing comprehensive guidance for AWS Bedrock integration and practical implementation patterns
- **Ecosystem Position**: Peripheral educational component supporting developer adoption and integration of core driver functionality, bridging standalone examples with production MCP server usage
- **Integration Pattern**: Used by developers through direct documentation reference and example execution, consumed by integration projects for configuration guidance, and referenced by educational workflows for hands-on learning experiences

######### Edge Cases & Error Handling

The system addresses missing AWS credentials through detailed environment variable configuration with multiple authentication methods including direct key specification and AWS profile usage. Amazon Bedrock access issues are handled with specific guidance for model access requests and IAM permission configuration. Model availability problems are addressed through region-specific guidance and model ID verification procedures. SDK installation issues are resolved through multiple installation methods including `uv sync` and traditional `pip install` approaches. Debug mode activation provides detailed logging configuration for troubleshooting complex integration issues. Connection failures include specific error message patterns with corresponding diagnostic steps and resolution procedures. The documentation provides fallback testing approaches for environments without AWS access through local test suite execution.

########## Internal Implementation Details

The documentation uses structured markdown formatting with consistent emoji indicators for different content types including prerequisites (📋), configuration (🌡️), execution commands (🚀), and troubleshooting (❌). Code examples employ syntax highlighting with language-specific formatting for bash commands, Python code, and configuration snippets. Performance metrics display includes specific formatting patterns for token usage, response times, cache statistics, and cost optimization data. Error message formatting uses consistent patterns with error codes, descriptions, and solution steps. Configuration examples show explicit parameter values including temperature settings (0.7, 0.8), token limits (4096), retry counts (3), and cache TTL values (300s). Integration patterns demonstrate async context manager usage, session management, and response processing with specific method calls and parameter passing.

########### Code Usage Examples

AWS credential configuration demonstrates the essential setup pattern for Bedrock service access. This approach provides multiple authentication methods to accommodate different deployment environments and security requirements.

```bash
# Environment variable configuration for AWS Bedrock access
export AWS_ACCESS_KEY_ID=your_access_key
export AWS_SECRET_ACCESS_KEY=your_secret_key
export AWS_REGION=us-east-1

# Alternative profile-based configuration
export AWS_PROFILE=your_profile_name
```

Driver configuration and integration showcases the practical implementation pattern for Jesse MCP Server integration. This pattern demonstrates factory method usage, async context management, and session-based conversation handling for production applications.

```python
# Jesse MCP Server integration with Claude 4 Sonnet driver
from llm.claude4_driver import StrandsClaude4Driver, Claude4SonnetConfig

class JESSEMCPServer:
    def __init__(self):
        config = Claude4SonnetConfig.create_optimized_for_conversations()
        self.claude_driver = StrandsClaude4Driver(config)
    
    async def handle_user_message(self, message: str, session_id: str):
        response = await self.claude_driver.send_message(message, session_id)
        return response.content
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples/reasoning_suppression_demo.py

*Last Updated: 2025-07-05T12:16:42Z*

#### Functional Intent & Features

This file implements a demonstration script for the reasoning suppression feature in the Claude 4 Sonnet driver, showcasing the difference between suppressed and enabled reasoning output modes for educational and testing purposes. The script enables developers to understand and validate the behavior of reasoning suppression configurations in the Strands Agent Driver system with live AWS Bedrock integration. Key semantic entities include `demonstrate_reasoning_suppression()` function for live feature demonstration, `demonstrate_manual_configuration()` function for configuration examples, `StrandsClaude4Driver` class for AWS Bedrock integration, `Claude4SonnetConfig` configuration class with factory methods, `create_optimized_for_conversations()` and `create_optimized_for_analysis()` factory methods, `suppress_reasoning_output` configuration parameter, `stream_conversation()` method for real-time response streaming, `start_conversation()` method for session initialization, `StrandsDriverError` and `BedrockConnectionError` exception classes, AWS environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, conversation identifiers `reasoning_demo_suppressed` and `reasoning_demo_enabled`, and comprehensive error handling with graceful degradation for missing AWS credentials. The system implements async-first architecture with streaming response processing and detailed console output formatting for educational demonstration purposes.

##### Main Components

The file contains three primary async functions providing comprehensive reasoning suppression demonstration capabilities. The `demonstrate_reasoning_suppression()` function performs live testing with both suppressed and enabled reasoning configurations, using different conversation IDs and streaming response processing to show behavioral differences. The `demonstrate_manual_configuration()` function provides educational examples of explicit configuration options including override patterns for factory defaults. The `main()` function serves as the entry point with AWS credential validation, region detection, and orchestrated execution of both configuration examples and live demonstrations. The script includes comprehensive logging setup with structured formatting, path manipulation for module imports, and detailed console output with emoji-based visual indicators for different demonstration phases.

###### Architecture & Design

The architecture implements a demonstration-focused design pattern with clear separation between educational configuration examples and live AWS Bedrock integration testing. The design follows async-first principles with comprehensive error handling and graceful degradation when AWS credentials are unavailable. Key design patterns include the demonstration pattern with side-by-side comparison of different configurations, factory method pattern usage for optimized configurations, streaming response pattern for real-time output processing, and educational pattern with detailed console formatting and explanatory text. The system uses context manager patterns for resource management, conversation isolation through unique identifiers, and comprehensive exception handling with user-friendly error messages and fallback behavior for missing dependencies.

####### Implementation Approach

The implementation uses async context managers for proper resource lifecycle management with `StrandsClaude4Driver` instances. Configuration comparison employs factory methods `create_optimized_for_conversations()` and `create_optimized_for_analysis()` with different `suppress_reasoning_output` settings to demonstrate behavioral differences. Response streaming uses async iteration over `stream_conversation()` results with metadata inspection for reasoning event detection and content type classification. The approach implements comprehensive error handling with try-catch blocks around AWS Bedrock operations and graceful degradation when credentials are missing. Console output uses structured formatting with emoji indicators, section dividers, and detailed explanatory text to enhance educational value. Path manipulation adds the parent directory structure to Python path for module imports without installation requirements.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for demonstration execution and streaming response processing
- `sys` (external library) - Python path manipulation for module imports and exit handling
- `os` (external library) - environment variable access for AWS credentials and region configuration
- `logging` (external library) - structured logging setup with timestamp formatting for debugging
- `pathlib.Path` (external library) - cross-platform path operations for module import path construction
- `jesse_framework_mcp.llm.strands_agent_driver:StrandsClaude4Driver` - main driver class for AWS Bedrock Claude 4 integration
- `jesse_framework_mcp.llm.strands_agent_driver:Claude4SonnetConfig` - configuration class with reasoning suppression settings
- `jesse_framework_mcp.llm.strands_agent_driver:StrandsDriverError` - driver-specific exception handling
- `jesse_framework_mcp.llm.strands_agent_driver:BedrockConnectionError` - AWS Bedrock connection error handling

**← Outbound:**
- Developer education workflows - consuming demonstration output for understanding reasoning suppression behavior
- Testing and validation processes - using demonstration results to verify driver functionality
- Documentation and training materials - referencing demonstration patterns for feature explanation
- AWS Bedrock service integration - generating actual API calls for live demonstration when credentials are available

**⚡ System role and ecosystem integration:**
- **System Role**: Educational demonstration component for Strands Agent Driver reasoning suppression feature, providing hands-on examples and live testing capabilities for developers learning the system
- **Ecosystem Position**: Peripheral educational component supporting developer onboarding and feature validation, demonstrating core driver functionality without being part of production workflows
- **Integration Pattern**: Used by developers through direct script execution for learning and testing, consumed by documentation processes for feature explanation, and integrated with AWS Bedrock services for live demonstration when proper credentials are configured

######### Edge Cases & Error Handling

The system handles missing AWS credentials gracefully by detecting environment variables and providing informative warnings without failing the demonstration. AWS Bedrock connection errors are caught and handled with user-friendly messages explaining that failures are expected without proper access. Keyboard interrupts are handled with clean exit messages and proper signal handling. The script manages import path issues by dynamically adding parent directories to Python path for module access. Configuration errors are handled with detailed exception information and fallback to showing configuration examples only. Streaming response errors during live demonstration are caught and reported while allowing the demonstration to continue with educational content. The system provides comprehensive error context including specific AWS region information and credential setup guidance.

########## Internal Implementation Details

The demonstration uses hardcoded test questions designed to trigger Claude's reasoning process for effective feature demonstration. Conversation IDs are explicitly set to `reasoning_demo_suppressed` and `reasoning_demo_enabled` for clear session isolation. Response streaming implements chunk processing with content accumulation and metadata inspection for reasoning event detection. Console output uses structured formatting with specific character counts, section dividers using `=` and `-` characters, and emoji indicators for different phases. Error handling implements specific exception types with detailed error messages and graceful degradation paths. AWS credential detection checks multiple environment variables including `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_PROFILE` with default region fallback to `us-east-1`. The script maintains educational focus with detailed explanatory text and summary sections explaining the practical implications of different configuration choices.

########### Code Usage Examples

Basic reasoning suppression demonstration shows the core pattern for comparing different configuration behaviors. This approach provides side-by-side comparison of suppressed versus enabled reasoning output for educational purposes.

```python
# Demonstrate reasoning suppression with factory configurations
async def compare_reasoning_modes():
    # Configuration for suppressed reasoning (conversations)
    config_suppressed = Claude4SonnetConfig.create_optimized_for_conversations()
    
    # Configuration for enabled reasoning (analysis)
    config_enabled = Claude4SonnetConfig.create_optimized_for_analysis()
    
    test_question = "What are the pros and cons of microservices versus monolithic architecture?"
    
    # Test with suppressed reasoning
    async with StrandsClaude4Driver(config_suppressed) as driver:
        await driver.start_conversation("demo_suppressed")
        async for chunk in driver.stream_conversation(test_question, "demo_suppressed"):
            if chunk.content:
                print(chunk.content, end="", flush=True)
```

Manual configuration override demonstrates how to customize reasoning suppression settings beyond factory defaults. This pattern shows explicit parameter control for specific use cases requiring different behavior than the optimized presets.

```python
# Manual configuration with explicit reasoning suppression control
def create_custom_configurations():
    # Explicitly suppress reasoning with custom temperature
    config_custom_suppressed = Claude4SonnetConfig(
        suppress_reasoning_output=True,
        temperature=0.7
    )
    
    # Override conversation default to show reasoning
    config_override = Claude4SonnetConfig.create_optimized_for_conversations(
        suppress_reasoning_output=False  # Override default suppression
    )
    
    # Override analysis default to hide reasoning
    config_analysis_override = Claude4SonnetConfig.create_optimized_for_analysis(
        suppress_reasoning_output=True  # Override default enabling
    )
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples/streaming_conversation.py

*Last Updated: 2025-07-05T12:16:42Z*

#### Functional Intent & Features

This file implements a comprehensive streaming conversation demonstration script for the Claude 4 Sonnet driver, showcasing real-time response delivery through chunk-based streaming with performance comparison analysis between streaming and non-streaming modes for educational and testing purposes. The script enables developers to understand and validate streaming conversation patterns with the Strands Agent Driver system using live AWS Bedrock integration, demonstrating user experience improvements through immediate response feedback and detailed performance metrics collection. Key semantic entities include `streaming_conversation_example()` function for primary streaming demonstration, `compare_streaming_vs_normal()` function for performance comparison analysis, `StrandsClaude4Driver` class for AWS Bedrock integration, `Claude4SonnetConfig` configuration class with factory method `create_optimized_for_conversations()`, `stream_conversation()` method for chunk-based response streaming, `streaming` configuration parameter for enabling real-time delivery, chunk attributes `content` and `is_complete` for stream processing, conversation identifiers `streaming_example_conversation`, `normal_test`, and `streaming_test`, performance timing using `time.time()` measurements, `BedrockConnectionError` and `StrandsDriverError` exception classes, AWS environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, and comprehensive streaming statistics including chunk count, response times, average chunk sizes, and user experience metrics. The system implements async-first architecture with detailed console output formatting and educational demonstration patterns for streaming optimization understanding.

##### Main Components

The file contains three primary async functions providing comprehensive streaming conversation demonstration and analysis capabilities. The `streaming_conversation_example()` function performs the main streaming demonstration with predefined longer-form questions designed to generate substantial responses, real-time chunk processing with immediate console output, and detailed streaming statistics collection including chunk counts and timing analysis. The `compare_streaming_vs_normal()` function implements performance comparison testing between streaming and non-streaming modes, measuring time to first content delivery and total response times with user experience impact analysis. The `main()` function serves as the orchestration entry point with AWS credential validation, region detection, and sequential execution of both demonstration functions with comprehensive error handling and educational summary output. The script includes detailed performance timing using `time.time()` measurements, streaming statistics calculation and display, and structured console output with emoji-based visual indicators for different streaming phases.

###### Architecture & Design

The architecture implements a demonstration-focused design pattern with clear separation between streaming validation and performance comparison analysis, following educational progression from basic streaming concepts to advanced performance optimization understanding. The design emphasizes real-time user experience through immediate chunk display and comprehensive performance measurement for educational value. Key design patterns include the streaming demonstration pattern with real-time chunk processing, performance comparison pattern with side-by-side timing analysis, async iteration pattern for chunk-based response handling, and educational pattern with detailed explanatory output and statistical reporting. The system uses conversation isolation through unique identifiers, comprehensive exception handling with specific error types, and structured console formatting with emoji indicators and section dividers for enhanced readability and learning experience.

####### Implementation Approach

The implementation uses async context managers for proper resource lifecycle management with `StrandsClaude4Driver` instances and explicit streaming configuration through `Claude4SonnetConfig` factory method with `streaming=True` parameter. Streaming processing employs async iteration over `stream_conversation()` results with real-time chunk display using `print(chunk.content, end="", flush=True)` for immediate user feedback. Performance measurement uses `time.time()` before and after streaming operations with precise timing calculations for first chunk delivery and total response times. The approach implements comprehensive statistics collection including chunk counting, response length measurement, and average chunk size calculation. Error handling uses specific exception types with user-friendly error messages and troubleshooting guidance. Console output employs structured formatting with emoji indicators, performance metrics display, and detailed comparative analysis for educational value.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for streaming demonstration execution and sleep delays between questions
- `sys` (external library) - Python path manipulation for module imports and exit handling with status codes
- `os` (external library) - environment variable access for AWS credentials and region configuration
- `time` (external library) - high-precision timing measurements for streaming performance analysis and comparison
- `pathlib.Path` (external library) - cross-platform path operations for module import path construction
- `strands_agent_driver:StrandsClaude4Driver` - main driver class for AWS Bedrock Claude 4 integration with streaming capabilities
- `strands_agent_driver:Claude4SonnetConfig` - configuration class with streaming parameters and factory methods
- `strands_agent_driver:StrandsDriverError` - driver-specific exception handling for operational errors
- `strands_agent_driver:BedrockConnectionError` - AWS Bedrock connection error handling for authentication issues

**← Outbound:**
- Developer education workflows - consuming streaming demonstration output for understanding real-time response delivery patterns
- Performance testing and validation processes - using streaming comparison results to verify driver streaming functionality and user experience improvements
- Documentation and training materials - referencing streaming performance metrics and optimization patterns for educational content
- AWS Bedrock service integration - generating actual streaming API calls for live demonstration when credentials are available

**⚡ System role and ecosystem integration:**
- **System Role**: Educational demonstration component for Strands Agent Driver streaming conversation capabilities, providing hands-on examples of real-time response delivery and performance optimization for developers learning efficient user experience patterns
- **Ecosystem Position**: Peripheral educational component supporting developer understanding of streaming strategies and user experience optimization, demonstrating core driver streaming features without being part of production workflows
- **Integration Pattern**: Used by developers through direct script execution for learning streaming optimization, consumed by performance testing processes for validation, and integrated with AWS Bedrock services for live streaming demonstration when proper credentials are configured

######### Edge Cases & Error Handling

The system handles missing AWS credentials gracefully by detecting environment variables and providing informative warnings with setup guidance without failing the demonstration. AWS Bedrock connection errors are caught with specific `BedrockConnectionError` handling and detailed troubleshooting steps including credential validation, Bedrock access verification, and model access confirmation. Driver operational errors are managed through `StrandsDriverError` exception handling with descriptive error messages. Keyboard interrupts are handled with clean exit messages and proper signal handling using `sys.exit(1)`. The script manages streaming interruption scenarios and incomplete chunk processing with comprehensive exception handling. Performance measurement edge cases include zero response times and division by zero scenarios with appropriate handling. Streaming statistics calculation handles empty responses and zero chunk counts with conditional logic to prevent calculation errors.

########## Internal Implementation Details

The demonstration uses hardcoded questions designed to generate longer responses including machine learning explanations, storytelling requests, and architecture discussions for effective streaming demonstration. Streaming configuration employs `create_optimized_for_conversations(streaming=True)` with explicit streaming enablement. Performance timing uses `time.time()` measurements with millisecond precision for first chunk detection and total response time calculation. Conversation IDs are explicitly set to `streaming_example_conversation`, `normal_test`, and `streaming_test` for clear session isolation. Console output uses structured formatting with specific emoji indicators, section dividers using `-` and `=` characters, and detailed statistical reporting including percentages and ratios. Streaming statistics include chunk counting, response length measurement, average chunk size calculation, and user experience impact analysis with comparative metrics display.

########### Code Usage Examples

Basic streaming configuration demonstrates the essential setup pattern for enabling real-time response delivery. This approach shows factory method usage with streaming parameter override and proper async context management for streaming operations.

```python
# Configure Claude 4 Sonnet driver with streaming enabled for real-time response delivery
config = Claude4SonnetConfig.create_optimized_for_conversations(streaming=True)

async with StrandsClaude4Driver(config) as driver:
    conversation_id = "streaming_example_conversation"
    await driver.start_conversation(conversation_id, {"example": "streaming"})
```

Streaming response processing showcases the async iteration pattern for real-time chunk handling with immediate user feedback. This pattern demonstrates how to process streaming responses with comprehensive statistics collection and performance measurement.

```python
# Process streaming responses with real-time chunk display and performance metrics
question = "Please write a detailed explanation of how machine learning works."

start_time = time.time()
full_response = ""
chunk_count = 0

async for chunk in driver.stream_conversation(question, conversation_id):
    print(chunk.content, end="", flush=True)
    full_response += chunk.content
    chunk_count += 1
    
    if chunk.is_complete:
        break

end_time = time.time()
print(f"Chunks received: {chunk_count}")
print(f"Total time: {end_time - start_time:.2f}s")
print(f"Avg chunk size: {len(full_response) // chunk_count if chunk_count > 0 else 0} chars")
```

---
*Generated: 2025-07-05T12:16:42Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples*
*Total Files: 5*
*Total Subdirectories: 0*

# End of examples_kb.md