<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/

## Global Summary

#### Functional Intent & Features

This directory implements a comprehensive Claude 4 Sonnet driver package for Amazon Bedrock integration using the Strands Agent SDK, providing a complete asyncio-based conversation system with streaming capabilities, intelligent caching, memory management, and educational examples within the Jesse Framework MCP Server ecosystem. The package enables developers to integrate advanced AI conversation features through pure asyncio interfaces with real-time streaming, prompt caching optimization, multiple memory management strategies, and complete independence from Jesse MCP Server components while offering clean integration pathways. Key semantic entities include `StrandsClaude4Driver` main driver class with async context manager support, `ConversationManager` for session and cache management, `Claude4SonnetConfig` configuration class with factory methods `create_optimized_for_conversations()`, `create_optimized_for_analysis()`, and `create_optimized_for_performance()`, `PromptCache` class for in-memory response caching with TTL and LRU eviction, `ConversationMemoryStrategy` enum with `SUMMARIZING`, `SLIDING_WINDOW`, and `NULL` options, `Claude4SonnetModel` enum with official model identifier `us.anthropic.claude-sonnet-4-20250514-v1:0`, core methods `start_conversation()`, `send_message()`, `stream_conversation()`, `get_conversation_stats()`, streaming response classes `StreamingResponse` and `ConversationResponse`, comprehensive exception hierarchy including `StrandsDriverError`, `ConversationError`, `ModelConfigurationError`, `CacheError`, `BedrockConnectionError`, `StreamingError`, and `TokenLimitError`, AWS environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, Strands Agent SDK components `Agent`, `BedrockModel`, and `AgentResult`, and educational demonstration scripts in `examples/` directory with comprehensive documentation and troubleshooting guidance. The system implements async-first architecture with context manager patterns, real streaming capabilities through Strands Agent SDK, intelligent memory management based on token limits, and comprehensive error handling with graceful degradation.

##### Main Components

The directory contains six primary files and one subdirectory providing complete Claude 4 Sonnet driver functionality and educational resources. The `__init__.py` module serves as the package initialization and public API definition with 11 exported symbols including main classes, configuration components, and exception hierarchy. The `driver.py` file implements the main `StrandsClaude4Driver` class with streaming capabilities, conversation management, and AWS Bedrock integration through Strands Agent SDK. The `conversation.py` module provides `ConversationManager` and `PromptCache` classes for session persistence, intelligent caching, and memory management strategies. The `models.py` file defines configuration classes including `Claude4SonnetConfig`, `ConversationContext`, and enums for model identifiers and memory strategies with comprehensive validation and factory methods. The `exceptions.py` module implements a hierarchical exception system with seven specialized exception classes for precise error handling and debugging support. The `README.md` documentation provides comprehensive guidance for installation, configuration, usage patterns, and integration with Jesse MCP Server applications. The `examples/` subdirectory contains five demonstration scripts and documentation showcasing basic conversations, streaming responses, prompt caching, reasoning suppression, and performance optimization with detailed educational content.

###### Architecture & Design

The architecture implements a layered design pattern with clear separation between driver logic, conversation management, configuration handling, and error management, following async-first principles with comprehensive context manager support for resource lifecycle management. The design emphasizes modularity through well-defined interfaces, performance optimization through intelligent caching and memory management, and developer experience through comprehensive documentation and educational examples. Key design patterns include the async context manager pattern for automatic resource management, factory method pattern for optimized configuration presets, strategy pattern for memory management with pluggable algorithms, cache-aside pattern for prompt response caching, adapter pattern for Strands SDK integration with graceful degradation, streaming iterator pattern for real-time response delivery, hierarchical exception pattern for precise error handling, and facade pattern for unified API access through package initialization. The system uses composition over inheritance with specialized classes for different concerns, dependency injection for configuration management, and comprehensive logging throughout all components for operational visibility and debugging support.

####### Implementation Approach

The implementation uses Python dataclasses with post-initialization validation for type-safe configuration management and async context managers with proper resource lifecycle handling across all components. Strands SDK integration employs conditional imports with availability checking and mock class definitions for type safety when dependencies are unavailable. Streaming implementation leverages real Strands Agent SDK streaming through `stream_async()` method with event processing for different stream types including data, reasoning, and tool usage events. Memory management implements three distinct strategies through configurable algorithms: conversation summarization when token thresholds are reached, sliding window approach keeping recent messages within limits, and null strategy for stateless interactions. Caching employs SHA-256 hashing for key generation combining prompt content, conversation ID, and configuration hash with TTL-based expiration and LRU eviction policies. The approach implements comprehensive retry logic with exponential backoff for both regular and streaming operations, token estimation using character-to-token ratio approximation, and conversation persistence through in-memory dictionaries with efficient access patterns. Error handling uses specific exception types with detailed context and graceful degradation for missing dependencies or configuration issues.

######## External Dependencies & Integration Points

**→ Inbound:**
- `strands:Agent` (external library) - Strands Agent SDK main class for Claude 4 Sonnet interaction and real-time streaming capabilities
- `strands.models:BedrockModel` (external library) - Bedrock model wrapper for AWS integration and configuration management
- `strands.types:AgentResult` (external library) - response type for Strands Agent operations with optional availability checking
- `boto3` (external library) - AWS SDK for Python enabling Amazon Bedrock service access and authentication
- `asyncio` (external library) - async event loop management for driver operations, streaming processing, and context manager lifecycle
- `typing` (external library) - comprehensive type annotations for type safety across all components
- `dataclasses` (external library) - structured configuration management with validation and factory methods
- `hashlib` (external library) - SHA-256 hashing for cache key generation and configuration fingerprinting
- `json` (external library) - configuration serialization for hash generation and data structure handling
- `time` (external library) - timestamp generation for cache TTL management and performance tracking
- `datetime` (external library) - ISO format timestamp generation for conversation tracking and message timestamping
- `logging` (external library) - structured logging for operations, error tracking, and debugging information
- `Amazon Bedrock` service - AWS managed AI service providing Claude 4 Sonnet model access with official inference profile ID
- AWS environment variables `AWS_REGION`, `AWS_PROFILE`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` - authentication and configuration

**← Outbound:**
- Jesse Framework MCP Server integration - consuming driver package through async context manager for Claude 4 Sonnet capabilities
- Application integration layers - using driver API for conversation management, streaming functionality, and performance optimization
- Example demonstration scripts - importing driver components for educational examples and feature validation
- Testing frameworks - consuming driver exports for functionality verification and regression testing
- Documentation generation systems - using package metadata and exports for API documentation
- Performance monitoring systems - consuming conversation statistics, cache performance metrics, and operational logs
- AWS Bedrock service integration - generating actual API calls, streaming responses, and cache operations for live interaction

**⚡ System role and ecosystem integration:**
- **System Role**: Complete Claude 4 Sonnet driver package within Jesse Framework MCP Server ecosystem, providing comprehensive AWS Bedrock integration with streaming, caching, conversation management, and memory optimization capabilities for production AI applications
- **Ecosystem Position**: Central driver component serving as the primary interface for Claude 4 Sonnet functionality, designed for independence from Jesse MCP Server while enabling seamless integration through well-defined APIs and comprehensive configuration management
- **Integration Pattern**: Used by applications through standard Python package imports and async context managers, consumed by Jesse MCP Server through direct driver instantiation, integrated with AWS Bedrock services through Strands Agent SDK adapter pattern, and supported by educational examples and comprehensive documentation for developer adoption

######### Edge Cases & Error Handling

The system handles missing Strands Agent SDK through conditional imports with `STRANDS_AVAILABLE` flag and mock class definitions for type checking when dependencies are unavailable. AWS Bedrock connection failures are managed through `BedrockConnectionError` with region context and detailed troubleshooting guidance including credential validation and service access verification. Configuration validation raises `ModelConfigurationError` for invalid parameters with comprehensive constraint checking including temperature ranges, token limits, and logical consistency between related settings. Conversation management errors use `ConversationError` for session-specific issues with conversation ID context for debugging and automatic session creation fallbacks. Streaming failures employ `StreamingError` with retry logic and exponential backoff for transient network issues and incomplete chunk processing scenarios. Cache operation failures are handled through try-catch blocks with warning-level logging to prevent cache errors from disrupting conversation flow. Token limit violations trigger intelligent memory management strategies including conversation summarization and sliding window application to maintain context within Claude 4 Sonnet's 200K token window. The system provides comprehensive logging for all error conditions with appropriate log levels, detailed context information for debugging, and graceful degradation paths that maintain functionality even when optional components fail.

########## Internal Implementation Details

The driver uses lazy initialization with `_is_initialized` flag and async lock for thread-safe initialization of Strands components including `BedrockModel` with configuration parameters and `Agent` with empty tools list for non-MCP usage. Cache implementation employs SHA-256 hash truncation to 16 characters for keys balancing uniqueness with storage efficiency, TTL-based expiration with periodic cleanup, and LRU eviction when size limits are exceeded. Memory management thresholds use configurable values including `conversation_summary_threshold` (150000 tokens) for summarization triggers and `max_context_tokens` (180000 tokens) for sliding window limits with conversation summarization keeping the last 3 messages while summarizing older content. Configuration dataclass uses specific field defaults including temperature (0.7), max_tokens (200000), streaming (True), enable_prompt_caching (True), cache_ttl_seconds (3600), max_retries (3), and exponential_backoff (True) with post-initialization validation and AWS environment variable integration. Streaming implementation processes different event types including data events for text content, reasoning events for Claude 4 thinking output with suppression control, and tool usage events with metadata inspection. The package maintains separate dictionaries for conversation contexts and message arrays enabling efficient access patterns, uses relative imports with dot notation for clean namespace organization, and implements comprehensive statistics tracking including cache hit rates, token usage, conversation metrics, and performance measurements.

########### Usage Examples

Basic driver integration demonstrates the essential pattern for Claude 4 Sonnet setup with factory method configuration and async context management. This approach provides the foundational usage pattern for production applications requiring AI conversation capabilities.

```python
# Initialize and use Claude 4 Sonnet driver with optimized configuration and async context management
from strands_agent_driver import StrandsClaude4Driver, Claude4SonnetConfig, ConversationMemoryStrategy

async def production_conversation():
    config = Claude4SonnetConfig.create_optimized_for_conversations(
        enable_prompt_caching=True,
        memory_strategy=ConversationMemoryStrategy.SUMMARIZING,
        aws_region="us-west-2"
    )
    
    async with StrandsClaude4Driver(config) as driver:
        # Start conversation and process messages with caching and memory management
        await driver.start_conversation("user_session_123")
        response = await driver.send_message("Analyze this data...", "user_session_123")
        
        print(f"Response: {response.content}")
        print(f"Cached: {response.from_cache}")
        print(f"Tokens: {response.tokens_used}")
```

Advanced streaming and error handling showcases the comprehensive pattern for real-time response processing with robust error management and performance optimization. This pattern demonstrates production-ready implementation with comprehensive exception handling and streaming capabilities.

```python
# Advanced streaming conversation with comprehensive error handling and performance monitoring
from strands_agent_driver import (
    StrandsClaude4Driver, Claude4SonnetConfig, 
    BedrockConnectionError, StreamingError, TokenLimitError
)

async def advanced_streaming_conversation():
    config = Claude4SonnetConfig.create_optimized_for_analysis(
        streaming=True,
        suppress_reasoning_output=False,
        thinking_timeout_seconds=600
    )
    
    try:
        async with StrandsClaude4Driver(config) as driver:
            await driver.start_conversation("analysis_session")
            
            async for chunk in driver.stream_conversation("Complex analysis task...", "analysis_session"):
                if chunk.metadata.get("stream_event") == "data":
                    print(chunk.content, end="", flush=True)
                elif chunk.metadata.get("stream_event") == "reasoning":
                    print(f"\n[Thinking: {chunk.content}]")
                elif chunk.is_complete:
                    break
            
            # Monitor performance and resource usage
            stats = await driver.get_conversation_stats("analysis_session")
            print(f"\nTokens used: {stats['total_tokens']}")
            
    except BedrockConnectionError as e:
        print(f"AWS connection failed: {e.region}")
    except TokenLimitError as e:
        print(f"Token limit exceeded: {e.current_tokens}/{e.max_tokens}")
    except StreamingError as e:
        print(f"Streaming failed at position: {e.stream_position}")
```

## Subdirectory Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/examples/
*Last Updated: 2025-07-05T12:26:07Z*

This directory implements a comprehensive collection of educational demonstration scripts for the Claude 4 Sonnet driver within the Jesse Framework MCP Server ecosystem, providing hands-on examples of AWS Bedrock integration patterns including basic conversations, streaming responses, prompt caching optimization, and reasoning suppression capabilities for developer learning and validation purposes. The examples directory enables developers to understand and implement advanced AI conversation features through practical, executable demonstrations with detailed performance analysis and comprehensive error handling. Key semantic entities include `StrandsClaude4Driver` class for AWS Bedrock Claude 4 integration, `Claude4SonnetConfig` configuration class with factory methods `create_optimized_for_conversations()`, `create_optimized_for_analysis()`, and `create_optimized_for_performance()`, core methods `start_conversation()`, `send_message()`, `stream_conversation()`, and `get_conversation_stats()`, configuration parameters `streaming`, `enable_prompt_caching`, `suppress_reasoning_output`, `cache_ttl_seconds`, `max_cache_entries`, and `temperature`, response attributes `content`, `tokens_used`, `from_cache`, and `is_complete`, exception classes `BedrockConnectionError` and `StrandsDriverError`, AWS environment variables `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_PROFILE`, and `AWS_REGION`, performance measurement using `time.time()`, comprehensive documentation in `README.md`, and async-first architecture with context manager patterns for resource lifecycle management and detailed console output formatting for educational demonstration purposes.

##### Main Components

The directory contains five primary files providing comprehensive coverage of Claude 4 Sonnet driver capabilities and educational guidance. The `basic_conversation.py` script demonstrates fundamental conversation patterns with sequential question-answer interactions, response metadata collection, and statistics tracking. The `streaming_conversation.py` script showcases real-time response delivery through chunk-based streaming with performance comparison analysis between streaming and non-streaming modes. The `caching_example.py` script illustrates prompt caching optimization with cache hit analysis, performance measurement, and cache management strategies including eviction testing. The `reasoning_suppression_demo.py` script explores reasoning output control with side-by-side comparisons of suppressed versus enabled reasoning modes and configuration override examples. The `README.md` documentation provides comprehensive setup instructions, configuration examples, troubleshooting guidance, and integration patterns for Jesse MCP Server applications with detailed console output samples and performance metrics explanations.

###### Architecture & Design

The architecture implements a demonstration-focused design pattern with clear separation between educational examples and comprehensive documentation, following progressive complexity from basic conversation concepts to advanced optimization strategies. The design emphasizes hands-on learning through executable scripts with detailed console output formatting, performance measurement, and statistical analysis for educational value. Key design patterns include the educational demonstration pattern with structured question sequences and comprehensive output formatting, performance comparison pattern with side-by-side timing analysis, factory method pattern usage for optimized configurations, async context manager pattern for resource management, streaming response pattern for real-time user experience, cache optimization pattern for performance improvement, and configuration override pattern for customization flexibility. The system uses conversation isolation through unique identifiers, comprehensive exception handling with specific error types, structured console formatting with emoji indicators and section dividers, and detailed documentation with executable examples and troubleshooting guidance.

####### Implementation Approach

The implementation uses async-first architecture with comprehensive context manager patterns for proper resource lifecycle management across all demonstration scripts. Configuration management employs factory method patterns with explicit parameter overrides for different optimization strategies including conversations, analysis, and performance scenarios. Performance measurement implements high-precision timing using `time.time()` with detailed statistical analysis including response times, cache hit rates, chunk processing metrics, and user experience impact calculations. Error handling uses specific exception types with graceful degradation and informative error messages including troubleshooting guidance and setup instructions. Console output employs structured formatting with emoji indicators, section dividers, performance metrics display, and detailed explanatory text to enhance educational value. Documentation integration provides comprehensive setup instructions, configuration examples, and integration patterns with executable code samples and detailed output explanations.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for demonstration execution, streaming processing, and timing measurements across all example scripts
- `sys` (external library) - Python path manipulation for module imports and exit handling with status codes for proper demonstration lifecycle management
- `os` (external library) - environment variable access for AWS credentials and region configuration with comprehensive validation and setup guidance
- `time` (external library) - high-precision timing measurements for performance analysis, cache comparison, and streaming metrics collection
- `logging` (external library) - structured logging setup with timestamp formatting for debugging and educational output enhancement
- `pathlib.Path` (external library) - cross-platform path operations for module import path construction and file system compatibility
- `strands_agent_driver:StrandsClaude4Driver` - main driver class for AWS Bedrock Claude 4 integration with conversation management, streaming, and caching capabilities
- `strands_agent_driver:Claude4SonnetConfig` - configuration class with factory methods and parameter customization for optimization strategies
- `strands_agent_driver:StrandsDriverError` - driver-specific exception handling for operational error management
- `strands_agent_driver:BedrockConnectionError` - AWS Bedrock connection error handling for authentication and access issues
- `Amazon Bedrock` service - AWS managed AI service providing Claude 4 Sonnet model access and API integration
- `uv` package manager - Python dependency management and virtual environment handling for example execution

**← Outbound:**
- Developer education workflows - consuming demonstration outputs for understanding Claude 4 Sonnet driver capabilities and AWS Bedrock integration patterns
- Jesse Framework MCP Server integration projects - using configuration examples and implementation patterns for production deployment
- Performance testing and validation processes - using example results to verify driver functionality, optimization strategies, and user experience improvements
- Documentation and training materials - referencing example outputs, configuration patterns, and troubleshooting guidance for educational content
- AWS Bedrock service integration - generating actual API calls, streaming responses, and cache operations for live demonstration when credentials are available

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive educational demonstration hub for Claude 4 Sonnet driver within Jesse Framework MCP Server ecosystem, providing hands-on examples of AWS Bedrock integration, performance optimization, and advanced conversation features for developer learning and validation
- **Ecosystem Position**: Peripheral educational component supporting developer adoption and integration of core driver functionality, bridging standalone examples with production MCP server usage through practical demonstrations and comprehensive documentation
- **Integration Pattern**: Used by developers through direct script execution for learning driver capabilities, consumed by integration projects for configuration guidance and implementation patterns, referenced by educational workflows for hands-on learning experiences, and integrated with AWS Bedrock services for live demonstration when proper credentials are configured

######### Edge Cases & Error Handling

The system handles missing AWS credentials gracefully across all examples by detecting environment variables and providing comprehensive setup guidance without failing demonstrations. AWS Bedrock connection errors are managed with specific exception handling including detailed troubleshooting steps for credential validation, service access verification, and model availability confirmation. Driver operational errors are caught with descriptive error messages and fallback behavior to educational content when live demonstrations fail. Keyboard interrupts are handled with clean exit messages and proper signal handling using structured exit codes. Performance measurement edge cases include zero response times, division by zero scenarios, and infinity handling for speedup calculations with appropriate conditional logic. Streaming interruption scenarios and incomplete chunk processing are managed with comprehensive exception handling and graceful degradation. Cache statistics retrieval handles missing or unavailable data with conditional display logic and error reporting. The documentation provides fallback testing approaches for environments without AWS access through local test suite execution and comprehensive troubleshooting guidance for common setup issues.

########## Internal Implementation Details

The demonstration scripts use hardcoded test questions designed to trigger specific Claude 4 Sonnet behaviors including reasoning processes, longer responses for streaming, and cache-friendly repeated queries for effective feature demonstration. Configuration management employs explicit parameter values including temperature settings (0.7, 0.8), cache TTL (300 seconds), cache size limits (10, 3 entries), and streaming enablement flags with detailed transparency in console output. Performance timing uses millisecond precision measurements with comprehensive statistical calculations including speedup ratios, cache hit rates, chunk processing metrics, and user experience impact analysis. Conversation IDs are explicitly set with descriptive names for clear session isolation and educational clarity. Console output uses structured formatting with specific emoji indicators, section dividers using `=` and `-` characters, detailed statistical reporting including percentages and ratios, and comprehensive explanatory text for enhanced educational value. Error handling implements specific exception types with detailed error messages, graceful degradation paths, and comprehensive troubleshooting guidance including AWS region information and credential setup instructions.

########### Usage Examples

Basic driver initialization demonstrates the foundational pattern for Claude 4 Sonnet integration with factory method configuration. This approach provides the essential setup pattern used across all demonstration scripts for consistent driver initialization and resource management.

```python

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/__init__.py

*Last Updated: 2025-07-05T12:26:07Z*

#### Functional Intent & Features

This file serves as the package initialization module for the Strands Claude 4 Sonnet Driver, providing a centralized public API interface for Amazon Bedrock Claude 4 Sonnet integration using the Strands Agent SDK within the Jesse Framework MCP Server ecosystem. The module enables developers to access all driver functionality through a single import point with comprehensive conversation management, prompt caching, streaming support, and complete independence from Jesse MCP Server components. Key semantic entities include `StrandsClaude4Driver` main driver class, `ConversationManager` for session and cache management, `Claude4SonnetConfig` configuration class, `ConversationMemoryStrategy` enum for memory management options, exception classes `StrandsDriverError`, `ConversationError`, `ModelConfigurationError`, `CacheError`, `BedrockConnectionError`, `StreamingError`, and `TokenLimitError`, package metadata `__version__` set to "0.1.0", `__author__` attributed to "JESSE Framework", and `__all__` list defining the complete public API surface with 11 exported symbols. The system implements standard Python package initialization patterns with explicit import statements from submodules including `.driver`, `.conversation`, `.models`, and `.exceptions` for comprehensive functionality exposure.

##### Main Components

The file contains import statements from four internal modules providing comprehensive driver functionality. The `.driver` module exports `StrandsClaude4Driver` as the main driver class for Claude 4 Sonnet integration. The `.conversation` module provides `ConversationManager` for session and cache management capabilities. The `.models` module exports `Claude4SonnetConfig` configuration class and `ConversationMemoryStrategy` enum for memory management options. The `.exceptions` module provides seven exception classes including `StrandsDriverError`, `ConversationError`, `ModelConfigurationError`, `CacheError`, `BedrockConnectionError`, `StreamingError`, and `TokenLimitError` for comprehensive error handling. The module includes package metadata definitions and a complete `__all__` list ensuring controlled public API exposure with 11 total exported symbols.

###### Architecture & Design

The architecture implements a standard Python package initialization pattern with explicit public API definition through `__all__` list and centralized import management from submodules. The design emphasizes clean API surface exposure with comprehensive functionality access through a single import point, following Python packaging best practices with explicit symbol exports. Key design patterns include the facade pattern providing unified access to distributed functionality across multiple modules, namespace pattern organizing related functionality into logical submodules, and explicit export pattern through `__all__` list controlling public API surface. The system uses relative imports for internal module access, package metadata for version and authorship tracking, and comprehensive exception hierarchy for error handling across all driver components.

####### Implementation Approach

The implementation uses relative imports with dot notation for accessing internal modules including `.driver`, `.conversation`, `.models`, and `.exceptions` for clean namespace organization. Package metadata employs standard Python conventions with `__version__` string for semantic versioning and `__author__` attribution for package ownership. The approach implements explicit API control through `__all__` list containing 11 symbols ensuring only intended functionality is exposed during wildcard imports. Import organization follows logical grouping with main classes first, followed by configuration and enum types, and comprehensive exception hierarchy for complete error handling coverage. The system maintains package-level documentation describing core capabilities including Strands Agent SDK integration, prompt caching, streaming support, and Jesse MCP Server independence.

######## External Dependencies & Integration Points

**→ Inbound:**
- `.driver:StrandsClaude4Driver` - main driver class providing Claude 4 Sonnet integration with AWS Bedrock through Strands Agent SDK
- `.conversation:ConversationManager` - conversation and cache management component for session persistence and performance optimization
- `.models:Claude4SonnetConfig` - configuration class providing model parameters, AWS settings, and memory management options
- `.models:ConversationMemoryStrategy` - enum defining memory management strategies including summarizing, sliding window, and null options
- `.exceptions:StrandsDriverError` - base exception class for all driver-related errors with contextual information
- `.exceptions:ConversationError` - conversation-specific exception for session management and context errors
- `.exceptions:ModelConfigurationError` - configuration validation exception for parameter and setup errors
- `.exceptions:CacheError` - cache operation exception for storage and retrieval errors
- `.exceptions:BedrockConnectionError` - AWS Bedrock connection exception for service integration errors
- `.exceptions:StreamingError` - streaming operation exception for real-time response delivery errors
- `.exceptions:TokenLimitError` - token limit exception for memory management and resource constraint errors

**← Outbound:**
- Jesse Framework MCP Server integration - consuming package through single import for Claude 4 Sonnet capabilities
- Application integration layers - using package API for conversation management and streaming functionality
- Example demonstration scripts - importing package components for educational and testing purposes
- Testing frameworks - consuming package exports for functionality verification and regression testing
- Documentation generation systems - using package metadata and exports for API documentation

**⚡ System role and ecosystem integration:**
- **System Role**: Package initialization and public API definition for Strands Claude 4 Sonnet Driver within Jesse Framework ecosystem, providing centralized access point for all driver functionality including conversation management, caching, and streaming capabilities
- **Ecosystem Position**: Central API gateway serving as the primary interface for Claude 4 Sonnet integration, enabling clean separation between internal implementation and external consumption through controlled symbol exports
- **Integration Pattern**: Used by applications through standard Python import mechanisms, consumed by Jesse MCP Server through package-level imports, and integrated with development workflows through explicit API surface definition and comprehensive exception handling

######### Edge Cases & Error Handling

The system handles import failures gracefully through Python's standard import mechanism with potential `ImportError` exceptions if internal modules are missing or corrupted. Package initialization provides comprehensive exception hierarchy through seven distinct exception classes covering all potential failure scenarios including driver errors, conversation management issues, configuration problems, cache failures, AWS Bedrock connection issues, streaming errors, and token limit violations. The `__all__` list ensures controlled API exposure preventing accidental access to internal implementation details while maintaining comprehensive functionality access. Module organization handles circular import scenarios through careful dependency management and relative import usage. Package metadata provides version tracking for compatibility management and debugging support.

########## Internal Implementation Details

The package uses relative imports with single dot notation for accessing sibling modules within the same package structure. The `__all__` list contains exactly 11 symbols including 2 main classes, 1 configuration class, 1 enum, and 7 exception classes for comprehensive API coverage. Package metadata follows Python conventions with string literals for version ("0.1.0") and author ("JESSE Framework") information. Import statements are organized logically with main functionality first, followed by configuration components, and comprehensive exception hierarchy last. The module maintains minimal implementation with focus on API exposure and metadata definition, delegating all functional implementation to specialized submodules for clean separation of concerns.

########### Code Usage Examples

Basic package import demonstrates the standard pattern for accessing driver functionality through the public API. This approach provides clean access to all driver capabilities through a single import statement with explicit symbol access.

```python
# Import main driver components through package-level API for clean access to functionality
from strands_agent_driver import StrandsClaude4Driver, Claude4SonnetConfig, ConversationMemoryStrategy

# Initialize driver with configuration for Claude 4 Sonnet integration
config = Claude4SonnetConfig.create_optimized_for_conversations()
driver = StrandsClaude4Driver(config)
```

Comprehensive error handling showcases the exception hierarchy pattern for robust error management across all driver operations. This pattern demonstrates how to leverage the complete exception hierarchy for specific error handling and debugging support.

```python
# Import complete exception hierarchy for comprehensive error handling across driver operations
from strands_agent_driver import (
    StrandsDriverError, ConversationError, ModelConfigurationError,
    CacheError, BedrockConnectionError, StreamingError, TokenLimitError
)

try:
    # Driver operations that may raise various exceptions
    async with StrandsClaude4Driver(config) as driver:
        response = await driver.send_message("Hello", "conversation_id")
except BedrockConnectionError as e:
    print(f"AWS Bedrock connection failed: {e}")
except ConversationError as e:
    print(f"Conversation management error: {e}")
except StrandsDriverError as e:
    print(f"General driver error: {e}")
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/conversation.py

*Last Updated: 2025-07-05T12:26:07Z*

#### Functional Intent & Features

This file implements comprehensive conversation management capabilities with intelligent caching and memory management strategies for Claude 4 Sonnet interactions, providing conversation persistence, context tracking, prompt caching for performance optimization, and multiple memory management approaches including summarizing, sliding window, and null strategies. The module enables developers to maintain conversation state across interactions while optimizing performance through intelligent caching and managing token limits through configurable memory strategies. Key semantic entities include `ConversationManager` class for session and cache management, `PromptCache` class for in-memory response caching with TTL and LRU eviction, core methods `start_conversation()`, `add_message()`, `get_conversation_messages()`, `get_conversation_context()`, `check_cached_response()`, `cache_response()`, `clear_conversation()`, and `clear_all_conversations()`, memory management methods `_manage_conversation_memory()`, `_summarize_conversation()`, and `_apply_sliding_window()`, cache management methods `get()`, `set()`, `clear()`, and `stats()`, utility methods `_generate_key()`, `_is_expired()`, `_evict_expired()`, `_evict_lru()`, `_estimate_tokens()`, `_create_summary_text()`, and `_generate_config_hash()`, `ConversationMemoryStrategy` enum integration with `SUMMARIZING`, `SLIDING_WINDOW`, and `NULL` options, exception classes `ConversationError`, `CacheError`, and `TokenLimitError`, configuration integration through `Claude4SonnetConfig` and `ConversationContext` dataclasses, and comprehensive statistics tracking with cache hit rates, token usage, and conversation metrics. The system implements async-first architecture with in-memory storage, SHA-256 hashing for cache keys, and intelligent memory management based on token limits and conversation length.

##### Main Components

The file contains two primary classes providing comprehensive conversation and caching management capabilities. The `PromptCache` class implements an in-memory cache with TTL expiration and LRU eviction policies, including methods for key generation, expiration checking, cache eviction, response storage and retrieval, statistics tracking, and cache clearing. The `ConversationManager` class serves as the main orchestrator for conversation lifecycle management, integrating conversation persistence, message tracking, memory management strategies, cache integration, and statistics collection. The module includes comprehensive utility methods for token estimation, conversation summarization, sliding window memory management, configuration hashing, and error handling. Both classes implement async interfaces for non-blocking operation and include detailed logging for operational visibility and debugging support.

###### Architecture & Design

The architecture implements a layered design pattern with clear separation between caching logic and conversation management, following composition over inheritance principles with the ConversationManager integrating PromptCache functionality. The design emphasizes performance optimization through intelligent caching with configurable TTL and size limits, memory management through multiple strategies based on conversation length and token usage, and scalability through in-memory storage with efficient eviction policies. Key design patterns include the strategy pattern for memory management with pluggable algorithms, cache-aside pattern for prompt response caching, factory pattern for conversation context creation, observer pattern for conversation state updates, and template method pattern for memory management workflows. The system uses dependency injection for configuration management, composition for cache integration, and async patterns for non-blocking operations with comprehensive error handling and logging throughout.

####### Implementation Approach

The implementation uses SHA-256 hashing for cache key generation combining prompt content, conversation ID, and configuration hash for unique identification. Cache management employs TTL-based expiration with periodic cleanup and LRU eviction when cache size limits are exceeded. Memory management implements three distinct strategies: summarizing older messages when token thresholds are reached, sliding window approach keeping recent messages within token limits, and null strategy for stateless interactions. The approach implements token estimation using character-to-token ratio approximation for performance optimization. Conversation persistence uses in-memory dictionaries with conversation ID keys for fast access and message arrays for chronological ordering. Configuration hashing ensures cache invalidation when model parameters change, preventing stale responses with different settings.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for non-blocking conversation and cache operations
- `hashlib` (external library) - SHA-256 hashing for cache key generation and configuration fingerprinting
- `json` (external library) - configuration serialization for hash generation and data structure handling
- `time` (external library) - timestamp generation for cache TTL management and access time tracking
- `datetime` (external library) - ISO format timestamp generation for conversation tracking and message timestamping
- `typing` (external library) - comprehensive type annotations including Dict, List, Optional, Any, AsyncIterator, Tuple for type safety
- `dataclasses` (external library) - asdict function for configuration serialization and data structure conversion
- `logging` (external library) - structured logging for conversation operations, cache management, and error tracking
- `.models:Claude4SonnetConfig` - configuration class providing memory strategy settings, cache parameters, and token limits
- `.models:ConversationContext` - context dataclass for conversation metadata, token tracking, and session information
- `.models:ConversationMemoryStrategy` - enum defining memory management strategies for conversation handling
- `.exceptions:ConversationError` - conversation-specific exception for session management errors
- `.exceptions:CacheError` - cache-specific exception for storage and retrieval errors
- `.exceptions:TokenLimitError` - token limit exception for memory management constraint violations

**← Outbound:**
- Strands Claude 4 Driver components - consuming ConversationManager for session management and response caching
- Driver streaming operations - using conversation context and message history for multi-turn conversations
- Performance optimization systems - using cache statistics and hit rates for monitoring and tuning
- Memory management workflows - consuming conversation summaries and token usage data for optimization decisions
- Logging and monitoring systems - consuming conversation statistics and cache performance metrics for operational visibility

**⚡ System role and ecosystem integration:**
- **System Role**: Core conversation and cache management infrastructure for Claude 4 Sonnet driver, providing session persistence, intelligent caching, and memory management capabilities essential for multi-turn conversation support
- **Ecosystem Position**: Central support component serving the main driver with conversation state management, performance optimization through caching, and memory constraint handling for token limit compliance
- **Integration Pattern**: Used by StrandsClaude4Driver through direct instantiation and method calls, consumed by streaming operations for conversation context, and integrated with configuration management for cache behavior and memory strategy selection

######### Edge Cases & Error Handling

The system handles missing conversations through `ConversationError` exceptions with conversation ID context for debugging and automatic conversation creation in driver methods. Cache operation failures are managed through try-catch blocks with warning-level logging to prevent cache errors from disrupting conversation flow. Token limit violations trigger memory management strategies including conversation summarization and sliding window application to maintain context within limits. Cache eviction handles full cache scenarios through LRU policy implementation and expired entry cleanup to maintain performance. Configuration changes invalidate cached responses through configuration hash comparison preventing stale responses with different model parameters. Memory management edge cases include conversations with insufficient messages for summarization and token estimation accuracy limitations with fallback to conservative estimates. The system provides comprehensive logging for all error conditions with appropriate log levels and detailed context information for debugging and operational monitoring.

########## Internal Implementation Details

The cache implementation uses SHA-256 hash truncation to 16 characters for cache keys balancing uniqueness with storage efficiency. Token estimation employs a 4:1 character-to-token ratio approximation based on English text patterns for performance optimization. Memory management thresholds use configurable values including `conversation_summary_threshold` for summarization triggers and `max_context_tokens` for sliding window limits. Conversation summarization keeps the last 3 messages while summarizing older content into system messages with summary markers. Cache statistics track total entries, expired entries, active entries, maximum capacity, and TTL settings for operational monitoring. Configuration hashing includes model ID, temperature, max tokens, top_p, and top_k parameters to ensure cache invalidation when model behavior changes. The system maintains separate dictionaries for conversation contexts and message arrays enabling efficient access patterns and memory management operations.

########### Code Usage Examples

Basic conversation management demonstrates the essential pattern for session lifecycle and message tracking. This approach provides fundamental conversation persistence with automatic context updates and token tracking for memory management decisions.

```python
# Initialize conversation manager with configuration and start conversation session
from strands_agent_driver.conversation import ConversationManager
from strands_agent_driver.models import Claude4SonnetConfig

config = Claude4SonnetConfig.create_optimized_for_conversations()
manager = ConversationManager(config)

# Start conversation and add messages with automatic token tracking
context = await manager.start_conversation("chat_session_1", {"user": "developer"})
await manager.add_message("chat_session_1", "user", "Hello, Claude!")
await manager.add_message("chat_session_1", "assistant", "Hello! How can I help you today?")

# Retrieve conversation history and context for processing
messages = await manager.get_conversation_messages("chat_session_1")
context = await manager.get_conversation_context("chat_session_1")
```

Advanced caching and memory management showcases the optimization patterns for performance and resource management. This pattern demonstrates how to leverage caching for response optimization and memory strategies for token limit compliance.

```python
# Demonstrate caching and memory management with performance optimization
# Check cache before processing and store responses for future use
cached_response = await manager.check_cached_response("What is Python?", "chat_session_1")
if not cached_response:
    # Process new response and cache for future requests
    response = "Python is a high-level programming language..."
    await manager.cache_response("What is Python?", "chat_session_1", response)

# Monitor conversation statistics and cache performance
stats = manager.get_stats()
print(f"Total conversations: {stats['total_conversations']}")
print(f"Cache hit rate: {stats['cache_stats']['active_entries']}/{stats['cache_stats']['total_entries']}")

# Clear conversations when memory limits are reached
if context.is_near_limit(config):
    await manager.clear_conversation("chat_session_1")
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/driver.py

*Last Updated: 2025-07-05T12:26:07Z*

#### Functional Intent & Features

This file implements the main driver class for Claude 4 Sonnet integration using the Strands Agent SDK, providing a pure asyncio interface with streaming conversation capabilities, prompt caching, and conversation management designed for complete independence from Jesse MCP Server while offering clean integration interfaces. The driver enables developers to interact with Claude 4 Sonnet through AWS Bedrock with advanced features including real-time streaming, intelligent caching, multiple memory management strategies, and automatic retry logic with exponential backoff. Key semantic entities include `StrandsClaude4Driver` main driver class with async context manager support, `StreamingResponse` class for real-time response chunks with `content`, `is_complete`, and `metadata` attributes, `ConversationResponse` class for complete responses with `content`, `conversation_id`, `tokens_used`, `from_cache`, and `metadata` attributes, core methods `initialize()`, `send_message()`, `stream_conversation()`, `start_conversation()`, `get_conversation_stats()`, `clear_conversation()`, and `clear_all_conversations()`, internal methods `_build_conversation_prompt()`, `_send_with_retry()`, and `_stream_with_retry()`, `ConversationManager` integration for session and cache management, exception classes `StrandsDriverError`, `ConversationError`, `ModelConfigurationError`, `BedrockConnectionError`, `StreamingError`, and `TokenLimitError`, Strands SDK components `Agent`, `BedrockModel`, and `AgentResult`, convenience functions `create_driver()` and `conversation_session()` context manager, streaming event types including `data`, `reasoning`, `tool_use`, and `complete`, and comprehensive error handling with retry logic and graceful degradation for missing dependencies. The system implements async-first architecture with context manager patterns for resource lifecycle management and real streaming capabilities through the Strands Agent SDK.

##### Main Components

The file contains three primary classes and two convenience functions providing comprehensive Claude 4 Sonnet driver functionality. The `StrandsClaude4Driver` class serves as the main driver with initialization, conversation management, streaming capabilities, and resource cleanup through async context manager support. The `StreamingResponse` class represents individual streaming chunks with content, completion status, metadata, and timestamp information for real-time response processing. The `ConversationResponse` class encapsulates complete conversation responses with content, conversation tracking, token usage, cache status, metadata, and timestamp information. The `create_driver()` function provides a convenience factory for driver initialization with automatic setup. The `conversation_session()` async context manager enables session-scoped driver usage with automatic conversation initialization and cleanup. The module includes comprehensive error handling, Strands SDK integration with availability checking, logging infrastructure, and retry logic with exponential backoff for robust operation.

###### Architecture & Design

The architecture implements an async-first design pattern with comprehensive context manager support for resource lifecycle management, following clean separation between driver logic, conversation management, and streaming response handling. The design emphasizes independence from Jesse MCP Server while providing clean integration interfaces through well-defined APIs and response objects. Key design patterns include the async context manager pattern for automatic resource management, factory pattern for driver creation and configuration presets, adapter pattern for Strands SDK integration with graceful degradation, streaming iterator pattern for real-time response delivery, retry pattern with exponential backoff for reliability, and composition pattern with ConversationManager for session and cache management. The system uses dependency injection for configuration management, lazy initialization for Strands components, and comprehensive error handling with specific exception types for different failure scenarios.

####### Implementation Approach

The implementation uses async context managers with `__aenter__` and `__aexit__` methods for proper resource lifecycle management and automatic cleanup. Strands SDK integration employs conditional imports with availability checking and mock class definitions for type safety when the SDK is unavailable. Streaming implementation leverages real Strands Agent SDK streaming through `stream_async()` method with event processing for different stream types including data, reasoning, and tool usage events. The approach implements retry logic with exponential backoff using configurable delay and maximum retry attempts for both regular and streaming operations. Conversation management uses prompt building with role-based message formatting and context accumulation for multi-turn conversations. Error handling employs specific exception types with detailed error context and graceful degradation for missing dependencies or configuration issues.

######## External Dependencies & Integration Points

**→ Inbound:**
- `asyncio` (external library) - async event loop management for driver operations, streaming processing, and context manager lifecycle
- `logging` (external library) - structured logging for driver operations, error tracking, and debugging information
- `typing` (external library) - comprehensive type annotations including Dict, List, Optional, Any, AsyncIterator, Union for type safety
- `contextlib` (external library) - asynccontextmanager decorator for convenience context manager creation
- `time` (external library) - timestamp generation for response objects and performance tracking
- `strands:Agent` (external library) - Strands Agent SDK main class for Claude 4 Sonnet interaction and streaming capabilities
- `strands.models:BedrockModel` (external library) - Bedrock model wrapper for AWS integration and configuration management
- `strands.types:AgentResult` (external library) - response type for Strands Agent operations with optional availability
- `.models:Claude4SonnetConfig` - configuration class providing model parameters and AWS settings
- `.models:ConversationContext` - context management class for session tracking and metadata
- `.conversation:ConversationManager` - conversation and cache management component for session handling
- `.exceptions` module - comprehensive exception classes for error handling and debugging

**← Outbound:**
- Jesse Framework MCP Server integration - consuming driver through async context manager for Claude 4 Sonnet capabilities
- Example demonstration scripts - using driver for educational examples and feature validation
- Testing frameworks - consuming driver API for functionality verification and regression testing
- Application integration layers - using convenience functions and context managers for simplified integration
- Logging and monitoring systems - consuming log output for operational visibility and debugging

**⚡ System role and ecosystem integration:**
- **System Role**: Core driver implementation for Claude 4 Sonnet integration within Jesse Framework ecosystem, providing complete async interface for AWS Bedrock interaction with streaming, caching, and conversation management capabilities
- **Ecosystem Position**: Central driver component serving as the primary interface for Claude 4 Sonnet functionality, designed for independence from Jesse MCP Server while enabling clean integration through well-defined APIs
- **Integration Pattern**: Used by applications through async context manager pattern, consumed by Jesse MCP Server through direct instantiation and method calls, and integrated with Strands Agent SDK through adapter pattern with graceful degradation for missing dependencies

######### Edge Cases & Error Handling

The system handles missing Strands Agent SDK through conditional imports with `STRANDS_AVAILABLE` flag and mock class definitions for type checking when the SDK is unavailable. Driver initialization failures are managed through `BedrockConnectionError` with region context and detailed error messages for AWS Bedrock connection issues. Conversation management errors use `ConversationError` for session-specific issues with conversation ID context for debugging. Streaming failures employ `StreamingError` with retry logic and exponential backoff for transient network issues. Token limit scenarios are handled through `TokenLimitError` with current and maximum token information for resource management. Configuration validation raises `ModelConfigurationError` for invalid parameters with model ID context. The system provides comprehensive retry logic with configurable maximum attempts and exponential backoff for both regular and streaming operations, graceful degradation for missing conversations with automatic session creation, and detailed logging for all error conditions with appropriate log levels.

########## Internal Implementation Details

The driver uses lazy initialization with `_is_initialized` flag and async lock for thread-safe initialization of Strands components. Strands SDK integration employs `BedrockModel` initialization with configuration parameters from `to_strands_model_kwargs()` method and `Agent` initialization with empty tools list for non-MCP usage. Streaming implementation processes different event types including data events for text content, reasoning events for Claude 4 thinking output with suppression control, and tool usage events for MCP integration capabilities. Retry logic implements exponential backoff with configurable delay starting at `retry_delay_seconds` and doubling on each retry when `exponential_backoff` is enabled. Conversation prompt building uses role-based formatting with "Human:", "Assistant:", and "System:" prefixes for proper Claude 4 interaction patterns. Response processing handles different result types from Strands Agent including string responses, objects with content attributes, and generic object conversion to string. The system maintains conversation state through ConversationManager integration with automatic message addition and cache management for performance optimization.

########### Code Usage Examples

Basic driver usage demonstrates the async context manager pattern for automatic resource management and conversation handling. This approach provides essential driver lifecycle management with proper initialization and cleanup for reliable Claude 4 Sonnet interaction.

```python
# Use async context manager for automatic driver lifecycle management
from strands_agent_driver import StrandsClaude4Driver, Claude4SonnetConfig

async def basic_conversation():
    config = Claude4SonnetConfig.create_optimized_for_conversations()
    
    async with StrandsClaude4Driver(config) as driver:
        # Start conversation and send message
        await driver.start_conversation("my_chat")
        response = await driver.send_message("Hello, Claude!", "my_chat")
        
        print(f"Response: {response.content}")
        print(f"From cache: {response.from_cache}")
        print(f"Tokens used: {response.tokens_used}")
```

Advanced streaming usage showcases the real-time response processing pattern with comprehensive event handling and metadata inspection. This pattern demonstrates how to leverage streaming capabilities for immediate user feedback and different event type processing.

```python
# Process streaming responses with real-time event handling and metadata inspection
async def streaming_conversation():
    config = Claude4SonnetConfig(streaming=True, suppress_reasoning_output=False)
    
    async with StrandsClaude4Driver(config) as driver:
        await driver.start_conversation("streaming_chat")
        
        async for chunk in driver.stream_conversation("Explain quantum computing", "streaming_chat"):
            if chunk.metadata.get("stream_event") == "data":
                print(chunk.content, end="", flush=True)
            elif chunk.metadata.get("stream_event") == "reasoning":
                print(f"\n[Thinking: {chunk.content}]")
            elif chunk.is_complete:
                print("\n--- Response complete ---")
                break
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/exceptions.py

*Last Updated: 2025-07-05T12:26:07Z*

#### Functional Intent & Features

This file implements a comprehensive exception hierarchy for the Strands Claude 4 Sonnet Driver, providing specialized error handling capabilities for different failure scenarios in AWS Bedrock integration and conversation management operations. The module enables precise error classification and debugging support through domain-specific exception classes with contextual metadata for troubleshooting and error recovery strategies. Key semantic entities include `StrandsDriverError` base exception class with `message`, `error_code`, and `details` attributes, `ConversationError` for conversation management failures with `conversation_id` context, `ModelConfigurationError` for model setup issues with `model_id` tracking, `CacheError` for caching operation failures with `cache_key` identification, `BedrockConnectionError` for AWS service connectivity problems with `region` specification, `StreamingError` for real-time response delivery issues with `stream_position` tracking, `TokenLimitError` for token quota violations with `current_tokens` and `max_tokens` limits, `Optional` and `Any` type annotations from `typing` module, and structured error context through keyword argument inheritance patterns. The system implements hierarchical exception design with specialized error contexts enabling precise error handling and debugging capabilities across the Strands Agent SDK integration.

##### Main Components

The file contains seven exception classes providing comprehensive error coverage for Strands Claude 4 Sonnet Driver operations. The `StrandsDriverError` base class establishes the foundation with message, error code, and details attributes for all driver-related errors. The `ConversationError` class handles conversation management failures with conversation ID context for session-specific debugging. The `ModelConfigurationError` class manages model initialization and configuration issues with model ID tracking. The `CacheError` class addresses caching operation failures with cache key identification for performance optimization debugging. The `BedrockConnectionError` class handles AWS Bedrock service connectivity problems with region specification for infrastructure troubleshooting. The `StreamingError` class manages real-time response delivery issues with stream position tracking for streaming operation debugging. The `TokenLimitError` class handles token quota violations with current and maximum token limits for resource management.

###### Architecture & Design

The architecture implements a hierarchical exception design pattern with a single base class providing common functionality and specialized derived classes adding domain-specific context attributes. The design follows Python exception best practices with proper inheritance from the built-in `Exception` class and consistent constructor patterns using keyword arguments for extensibility. Key design patterns include the template method pattern for consistent exception initialization, composition pattern for error context through attributes, and inheritance hierarchy pattern for specialized error handling. The system uses optional type annotations for flexible error context while maintaining backward compatibility, structured attribute access for debugging information, and consistent parameter passing through keyword argument inheritance for maintainable exception handling across different error scenarios.

####### Implementation Approach

The implementation uses Python's standard exception inheritance with `super().__init__()` calls to maintain proper exception chain behavior and message propagation. Constructor patterns employ optional parameters with default values for flexible error context specification while ensuring required message parameters. The approach implements consistent attribute assignment for error context including conversation IDs, model identifiers, cache keys, regions, stream positions, and token limits. Error context storage uses dictionary-based details with fallback to empty dictionaries for extensible metadata without breaking existing code. Keyword argument forwarding enables derived classes to pass additional context to base classes while maintaining clean constructor interfaces. Type annotations use `Optional` for nullable context attributes and flexible parameter specifications for robust error handling.

######## External Dependencies & Integration Points

**→ Inbound:**
- `typing` (external library) - type annotations including Optional and Any for flexible error context specification and type safety

**← Outbound:**
- Strands Claude 4 Sonnet Driver components - consuming exception classes for error handling in conversation management, model configuration, and streaming operations
- AWS Bedrock integration modules - using BedrockConnectionError for service connectivity error handling and region-specific troubleshooting
- Caching subsystems - using CacheError for cache operation failure handling and performance optimization debugging
- Token management systems - using TokenLimitError for quota violation handling and resource limit enforcement
- Example demonstration scripts - using exception classes for educational error handling and troubleshooting guidance

**⚡ System role and ecosystem integration:**
- **System Role**: Core error handling infrastructure for Strands Claude 4 Sonnet Driver, providing specialized exception classes for precise error classification and debugging support across AWS Bedrock integration and conversation management operations
- **Ecosystem Position**: Central support component serving all driver functionality with domain-specific error handling, enabling robust error recovery and debugging capabilities throughout the system
- **Integration Pattern**: Used by all driver components through direct exception raising and catching, consumed by error handling workflows for precise error classification, and integrated with debugging and logging systems for comprehensive error context and troubleshooting support

######### Edge Cases & Error Handling

The system handles missing error context gracefully through optional parameters with default values, ensuring exceptions can be raised with minimal required information while supporting rich context when available. Constructor parameter validation uses keyword argument patterns to prevent parameter conflicts and enable flexible error context specification. The base class provides fallback behavior for missing details through empty dictionary defaults, preventing attribute access errors during exception handling. Error message propagation maintains proper exception chain behavior through `super().__init__()` calls, ensuring standard Python exception handling works correctly. Type annotation compatibility handles both typed and untyped usage scenarios through `Optional` specifications. The exception hierarchy prevents inappropriate exception catching through specific class inheritance, enabling precise error handling without overly broad exception catching patterns.

########## Internal Implementation Details

The base exception class uses attribute assignment after `super().__init__()` to store error context including message, error code, and details dictionary. Derived classes implement consistent constructor patterns with domain-specific parameters followed by keyword argument forwarding to base classes. Optional parameter handling uses default `None` values with conditional assignment to prevent attribute errors. Dictionary-based details storage uses `or {}` patterns to ensure non-None dictionary attributes for safe attribute access. Constructor signatures maintain consistency with message as required first parameter and optional context parameters with keyword argument inheritance. Type annotations specify `Optional[str]` for nullable string attributes and `Optional[dict]` for extensible details storage. The implementation maintains Python exception conventions while adding structured error context for debugging and error recovery operations.

########### Code Usage Examples

Basic exception raising demonstrates the standard pattern for driver error handling with contextual information. This approach provides essential error context while maintaining clean exception handling patterns for debugging and error recovery.

```python
# Raise domain-specific exceptions with contextual information for precise error handling
try:
    # Conversation operation that might fail
    result = await driver.start_conversation("invalid_id")
except ConversationError as e:
    print(f"Conversation failed: {e.message}")
    print(f"Conversation ID: {e.conversation_id}")
    print(f"Error details: {e.details}")
```

Advanced exception handling showcases the pattern for comprehensive error context and recovery strategies. This pattern demonstrates how to leverage specialized exception attributes for detailed debugging and appropriate error recovery based on specific failure types.

```python
# Comprehensive exception handling with specialized error context and recovery strategies
try:
    response = await driver.send_message(long_message, conversation_id)
except TokenLimitError as e:
    print(f"Token limit exceeded: {e.current_tokens}/{e.max_tokens}")
    # Implement token limit recovery strategy
    truncated_message = long_message[:1000]
    response = await driver.send_message(truncated_message, conversation_id)
except BedrockConnectionError as e:
    print(f"AWS Bedrock connection failed in region: {e.region}")
    print(f"Error code: {e.error_code}")
    # Implement connection retry or fallback strategy
except StreamingError as e:
    print(f"Streaming failed at position: {e.stream_position}")
    # Implement streaming recovery or fallback to non-streaming
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/models.py

*Last Updated: 2025-07-05T12:26:07Z*

#### Functional Intent & Features

This file implements comprehensive configuration management for Claude 4 Sonnet model integration with Amazon Bedrock through the Strands Agent SDK, providing structured configuration classes, validation mechanisms, and optimization presets for different use cases within the Jesse Framework MCP Server ecosystem. The module enables developers to configure and manage Claude 4 Sonnet interactions with precise control over model parameters, memory strategies, caching behavior, and AWS integration settings through type-safe dataclasses and enums. Key semantic entities include `Claude4SonnetConfig` dataclass with comprehensive configuration parameters, `Claude4SonnetModel` enum with official model identifier `us.anthropic.claude-sonnet-4-20250514-v1:0`, `ConversationMemoryStrategy` enum with `SUMMARIZING`, `SLIDING_WINDOW`, and `NULL` options, `ConversationContext` dataclass for session management, factory methods `create_optimized_for_conversations()`, `create_optimized_for_analysis()`, and `create_optimized_for_performance()`, configuration parameters `temperature`, `max_tokens`, `top_p`, `top_k`, `streaming`, `aws_region`, `aws_profile`, `memory_strategy`, `max_context_tokens`, `conversation_summary_threshold`, `enable_prompt_caching`, `cache_ttl_seconds`, `max_cache_entries`, `max_retries`, `retry_delay_seconds`, `exponential_backoff`, `enable_extended_thinking`, `thinking_timeout_seconds`, `enable_tool_use`, and `suppress_reasoning_output`, validation methods `_validate_config()` and `_set_aws_defaults()`, conversion methods `to_bedrock_params()` and `to_strands_model_kwargs()`, context management methods `should_summarize()` and `is_near_limit()`, and `ModelConfigurationError` exception integration from the exceptions module. The system implements dataclass-based configuration with post-initialization validation and environment variable integration for AWS settings.

##### Main Components

The file contains three primary classes and two enums providing comprehensive configuration management for Claude 4 Sonnet integration. The `Claude4SonnetModel` enum defines official model identifiers with the AWS Bedrock inference profile ID for Claude 4 Sonnet. The `ConversationMemoryStrategy` enum specifies memory management approaches including summarizing, sliding window, and null strategies. The `Claude4SonnetConfig` dataclass serves as the main configuration container with model parameters, AWS settings, conversation management options, caching configuration, retry logic, and advanced Claude 4 features including extended thinking and reasoning output control. The `ConversationContext` dataclass manages session-specific information including token counts, message tracking, timestamps, summaries, and metadata with utility methods for summarization and limit checking. The module includes comprehensive validation logic, environment variable integration, and conversion methods for different integration contexts.

###### Architecture & Design

The architecture implements a dataclass-based configuration pattern with comprehensive validation and factory method design for optimized presets, following type-safe configuration management principles with enum-based option specification. The design emphasizes immutable configuration objects with post-initialization validation and environment variable integration for flexible deployment scenarios. Key design patterns include the dataclass pattern for structured configuration with type annotations, enum pattern for constrained option sets, factory method pattern for optimized configuration presets, validation pattern with comprehensive parameter checking, and conversion pattern for different integration contexts. The system uses composition over inheritance with separate classes for different concerns, environment variable integration for AWS configuration defaults, and utility methods for context-aware decision making in conversation management.

####### Implementation Approach

The implementation uses Python dataclasses with field defaults and post-initialization hooks for comprehensive configuration validation and environment variable integration. Configuration validation employs range checking for numerical parameters, logical consistency validation for related settings, and model-specific constraint enforcement for Claude 4 Sonnet limitations. Factory methods implement preset configurations with parameter override capabilities using dictionary merging and keyword argument forwarding. The approach implements type-safe configuration through enum constraints, optional type annotations for nullable parameters, and structured data organization through dataclass fields. Conversion methods provide integration bridges to different SDK interfaces including Bedrock API parameters and Strands model kwargs with conditional parameter inclusion based on configuration state.

######## External Dependencies & Integration Points

**→ Inbound:**
- `os` (external library) - environment variable access for AWS configuration defaults including AWS_REGION and AWS_PROFILE
- `typing` (external library) - type annotations including Optional, Dict, Any, Union for comprehensive type safety
- `dataclasses` (external library) - dataclass decorator and field function for structured configuration management
- `enum` (external library) - Enum base class for constrained option sets and string enumeration patterns
- `.exceptions:ModelConfigurationError` - custom exception class for configuration validation errors and model-specific error handling

**← Outbound:**
- Strands Agent Driver components - consuming configuration classes for Claude 4 Sonnet model initialization and parameter management
- Amazon Bedrock integration modules - using configuration conversion methods for API parameter formatting
- Conversation management systems - using ConversationContext for session tracking and memory management decisions
- Caching subsystems - using configuration parameters for cache behavior and TTL settings
- Retry logic implementations - using retry configuration parameters for exponential backoff and failure handling

**⚡ System role and ecosystem integration:**
- **System Role**: Core configuration infrastructure for Claude 4 Sonnet integration within Jesse Framework MCP Server, providing type-safe configuration management with validation, optimization presets, and AWS integration for all driver components
- **Ecosystem Position**: Central configuration component serving all Claude 4 Sonnet driver functionality with comprehensive parameter management, enabling consistent configuration across conversation management, caching, streaming, and AWS integration subsystems
- **Integration Pattern**: Used by driver components through direct class instantiation and factory methods, consumed by AWS Bedrock integration through parameter conversion methods, and integrated with conversation management through context tracking and memory strategy implementation

######### Edge Cases & Error Handling

The system handles invalid configuration parameters through comprehensive validation in `_validate_config()` method with specific error messages for temperature, top_p, max_tokens, max_context_tokens, and conversation_summary_threshold constraints. Configuration validation raises `ModelConfigurationError` exceptions with model_id context for debugging and error tracking. Environment variable handling manages missing AWS configuration through default value assignment and optional parameter patterns. Token limit validation enforces Claude 4 Sonnet's 200K token context window with conservative defaults and threshold checking. Parameter consistency validation ensures logical relationships between related settings like summary threshold and max context tokens. Factory method error handling manages invalid override parameters through dictionary merging with validation after instantiation. The system provides graceful handling of missing environment variables with sensible defaults and optional AWS profile configuration.

########## Internal Implementation Details

The configuration dataclass uses field defaults with specific values including temperature (0.7), max_tokens (200000), top_p (0.9), top_k (250), streaming (True), memory_strategy (SUMMARIZING), max_context_tokens (180000), conversation_summary_threshold (150000), enable_prompt_caching (True), cache_ttl_seconds (3600), max_cache_entries (100), max_retries (3), retry_delay_seconds (1.0), exponential_backoff (True), enable_extended_thinking (True), thinking_timeout_seconds (480), enable_tool_use (False), and suppress_reasoning_output (True). Post-initialization validation uses range checking with specific error messages and model_id context for debugging. Environment variable integration uses `os.getenv()` with default fallbacks for AWS_REGION (us-east-1) and AWS_PROFILE (None). Conversion methods implement parameter mapping with conditional inclusion based on configuration state and SDK-specific parameter naming conventions. Factory methods use dictionary merging with `defaults.update(overrides)` pattern for flexible parameter customization while maintaining preset optimization characteristics.

########### Code Usage Examples

Basic configuration instantiation demonstrates the standard pattern for Claude 4 Sonnet setup with default parameters and validation. This approach provides essential configuration management with automatic validation and AWS environment integration.

```python
# Create Claude 4 Sonnet configuration with default parameters and validation
from strands_agent_driver.models import Claude4SonnetConfig, ConversationMemoryStrategy

config = Claude4SonnetConfig(
    temperature=0.8,
    max_tokens=4096,
    memory_strategy=ConversationMemoryStrategy.SUMMARIZING,
    enable_prompt_caching=True,
    aws_region="us-west-2"
)

# Convert to Bedrock parameters for API integration
bedrock_params = config.to_bedrock_params()
strands_kwargs = config.to_strands_model_kwargs()
```

Factory method usage showcases the optimization preset pattern for different use cases with parameter override capabilities. This pattern demonstrates how to leverage pre-configured optimizations while customizing specific parameters for specialized requirements.

```python
# Use factory methods for optimized configurations with custom overrides
# Conversation-optimized configuration with custom temperature
conversation_config = Claude4SonnetConfig.create_optimized_for_conversations(
    temperature=0.9,
    cache_ttl_seconds=7200
)

# Analysis-optimized configuration with extended thinking timeout
analysis_config = Claude4SonnetConfig.create_optimized_for_analysis(
    thinking_timeout_seconds=900,
    suppress_reasoning_output=False
)

# Performance-optimized configuration with minimal overhead
performance_config = Claude4SonnetConfig.create_optimized_for_performance(
    max_tokens=1024,
    enable_prompt_caching=False
)
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver/README.md

*Last Updated: 2025-07-05T12:26:07Z*

#### Functional Intent & Features

This documentation provides comprehensive guidance for the Strands Agent Driver implementation for Claude 4 Sonnet, serving as the primary reference for AWS Bedrock integration using the Strands Agent SDK within the Jesse Framework MCP Server ecosystem. The content enables developers to understand and implement advanced AI conversation features through pure asyncio interfaces with streaming capabilities, prompt caching optimization, and memory management strategies. Key semantic entities include `StrandsClaude4Driver` main driver class, `Claude4SonnetConfig` configuration class with factory methods `create_optimized_for_conversations()`, `create_optimized_for_analysis()`, and `create_optimized_for_performance()`, core methods `start_conversation()`, `send_message()`, `stream_conversation()`, and `get_conversation_stats()`, `ConversationMemoryStrategy` enum with `SUMMARIZING`, `SLIDING_WINDOW`, and `NULL` options, configuration parameters `model_id`, `temperature`, `max_tokens`, `aws_region`, `aws_profile`, `enable_prompt_caching`, `cache_ttl_seconds`, `enable_extended_thinking`, `suppress_reasoning_output`, and `max_retries`, response attributes `content`, `from_cache`, `tokens_used`, and `is_complete`, exception classes `StrandsDriverError`, `BedrockConnectionError`, and `ConversationError`, AWS environment variables `AWS_REGION`, `AWS_PROFILE`, `AWS_ACCESS_KEY_ID`, and `AWS_SECRET_ACCESS_KEY`, official model ID `us.anthropic.claude-sonnet-4-20250514-v1:0`, streaming event types including `data`, `reasoning`, `tool_use`, and `complete`, and comprehensive integration patterns for Jesse MCP Server applications. The system implements async-first architecture with context manager patterns, real-time streaming capabilities, and intelligent caching for performance optimization.

##### Main Components

The documentation contains twelve primary content sections providing comprehensive coverage of the Strands Agent Driver capabilities and implementation guidance. The Features section outlines core capabilities including pure asyncio interface, streaming conversations, prompt caching, memory management, Claude 4 Sonnet optimization, retry logic, and complete independence from Jesse MCP Server components. The Installation section provides dependency requirements including `strands-agents` and `boto3` packages. The Quick Start section demonstrates basic usage patterns and streaming conversation examples. The Configuration Options section details pre-configured setups and custom configuration parameters. The Memory Management Strategies section explains summarizing, sliding window, and null strategies with specific use cases. The Advanced Features section covers conversation management, cache management, and error handling patterns. The AWS Configuration section addresses environment variables and programmatic configuration. The Examples section references working demonstration scripts in the `examples/` directory. The Testing section describes the included test suite functionality. The Architecture Notes section explains real streaming implementation, model configuration, event types, and reasoning output control. The Performance Optimization section provides configuration recommendations for different use cases. The Integration section demonstrates Jesse MCP Server integration patterns, and the Troubleshooting section addresses common issues and debug logging.

###### Architecture & Design

The architecture implements a documentation-first design pattern with clear separation between conceptual explanations, practical examples, and technical specifications, following progressive complexity from basic usage to advanced integration patterns. The design emphasizes hands-on learning through executable code examples with comprehensive configuration options and detailed explanations of each feature. Key design patterns include the progressive disclosure pattern moving from quick start to advanced features, factory method pattern documentation for optimized configurations, context manager pattern for resource lifecycle management, streaming response pattern for real-time user experience, memory management pattern with multiple strategies, caching optimization pattern for performance improvement, and error handling pattern with specific exception types. The system uses structured markdown formatting with consistent code block highlighting, comprehensive cross-references between sections, and detailed integration guidance for production deployment scenarios.

####### Implementation Approach

The implementation uses comprehensive code examples as primary teaching tools with detailed explanations of configuration options, usage patterns, and integration strategies. Configuration management employs factory method patterns with explicit parameter examples showing temperature settings, memory strategies, caching options, streaming configurations, and AWS integration patterns. Code examples demonstrate async context manager usage, streaming response processing, error handling with specific exception types, and performance optimization techniques. The approach implements structured documentation organization with clear section hierarchies, consistent code formatting with language identifiers, and comprehensive cross-references between related concepts. Integration examples show practical usage patterns within larger application contexts including Jesse MCP Server integration, conversation management, cache optimization, and troubleshooting guidance with specific error scenarios and resolution steps.

######## External Dependencies & Integration Points

**→ References:**
- `strands-agents` package - Strands Agent SDK providing core Claude 4 Sonnet integration capabilities and streaming functionality
- `boto3` package - AWS SDK for Python enabling Amazon Bedrock service access and authentication
- `Amazon Bedrock` service - AWS managed AI service providing Claude 4 Sonnet model access with official inference profile ID
- `examples/basic_conversation.py` - basic conversation demonstration script with sequential question-answer interactions
- `examples/streaming_conversation.py` - streaming response example showcasing real-time chunk processing
- `examples/caching_example.py` - prompt caching demonstration with performance optimization analysis
- `examples/reasoning_suppression_demo.py` - reasoning output control demonstration with configuration examples
- `test_strands_driver.py` - comprehensive test suite for driver functionality validation
- AWS environment variables `AWS_REGION`, `AWS_PROFILE`, `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY` - authentication and configuration
- Python 3.10+ runtime requirement with asyncio support for modern async/await patterns

**← Referenced By:**
- Jesse Framework MCP Server integration projects - using driver documentation for production deployment and configuration guidance
- Developer onboarding workflows - consuming setup instructions and usage examples for learning driver integration patterns
- AWS Bedrock integration projects - referencing configuration examples and authentication patterns for Claude 4 Sonnet access
- Performance optimization initiatives - using memory management strategies and caching configuration for efficient AI conversation systems
- Educational and training materials - referencing code examples and architectural explanations for AI integration learning
- Troubleshooting and support workflows - using error handling patterns and debug logging guidance for issue resolution

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive documentation hub for Strands Agent Driver within Jesse Framework ecosystem, providing complete reference for AWS Bedrock Claude 4 Sonnet integration with streaming, caching, and memory management capabilities
- **Ecosystem Position**: Central documentation component supporting developer adoption and production deployment of Claude 4 Sonnet integration, bridging Strands Agent SDK capabilities with Jesse MCP Server requirements
- **Integration Pattern**: Used by developers through direct documentation reference for implementation guidance, consumed by integration projects for configuration and deployment patterns, referenced by educational workflows for hands-on learning experiences, and integrated with AWS Bedrock services through comprehensive authentication and configuration examples

######### Edge Cases & Error Handling

The system addresses missing AWS credentials through detailed environment variable configuration with multiple authentication methods including direct key specification and AWS profile usage. Amazon Bedrock access issues are handled with specific guidance for model access requests, region configuration, and IAM permission setup. Model availability problems are addressed through official inference profile ID usage and region-specific deployment considerations. SDK installation issues are resolved through explicit dependency specifications and version requirements. Import errors are managed through proper package installation verification and troubleshooting steps. Token limit scenarios are handled through memory management strategies and context window optimization techniques. Connection failures include specific error handling patterns with retry logic and exponential backoff configuration. The documentation provides comprehensive troubleshooting guidance for common deployment issues including credential validation, model access verification, and debug logging activation.

########## Internal Implementation Details

The documentation uses structured markdown formatting with consistent code block syntax highlighting for Python, bash, and configuration examples. Configuration examples employ explicit parameter values including temperature settings (0.3, 0.8), token limits (2048, 4096, 180000), cache TTL values (1800, 3600 seconds), retry counts (3), and timeout specifications (480, 600 seconds). Code examples demonstrate specific method signatures including `start_conversation()`, `send_message()`, `stream_conversation()`, `get_conversation_stats()`, and `clear_conversation()` with parameter specifications and return value handling. Error handling patterns show specific exception types including `StrandsDriverError`, `BedrockConnectionError`, and `ConversationError` with contextual error information access. Integration patterns demonstrate async context manager usage, conversation lifecycle management, and resource cleanup procedures. The system maintains consistent cross-referencing between sections with specific file paths for examples and test suites, comprehensive parameter documentation with default values, and detailed architectural explanations including streaming event types and reasoning output control mechanisms.

########### Code Usage Examples

Basic driver initialization demonstrates the foundational pattern for Claude 4 Sonnet integration with factory method configuration. This approach provides the essential setup pattern for async context management and conversation lifecycle handling.

```python
# Initialize Claude 4 Sonnet driver with optimized configuration for conversation management
import asyncio
from strands_agent_driver import StrandsClaude4Driver, Claude4SonnetConfig

async def basic_conversation():
    config = Claude4SonnetConfig.create_optimized_for_conversations()
    
    async with StrandsClaude4Driver(config) as driver:
        conversation_id = "my_conversation"
        await driver.start_conversation(conversation_id)
        
        response = await driver.send_message(
            "Hello! Can you explain quantum computing?",
            conversation_id
        )
        
        print(f"Claude: {response.content}")
        print(f"From cache: {response.from_cache}")
        print(f"Tokens used: {response.tokens_used}")

asyncio.run(basic_conversation())
```

Advanced streaming and caching integration showcases the comprehensive pattern for real-time response processing with performance optimization. This pattern demonstrates how to leverage streaming capabilities with intelligent caching for optimal user experience and cost efficiency.

```python
# Comprehensive streaming conversation with caching and performance optimization
async def streaming_with_caching():
    config = Claude4SonnetConfig(
        streaming=True,
        enable_prompt_caching=True,
        cache_ttl_seconds=1800,
        max_cache_entries=50,
        memory_strategy=ConversationMemoryStrategy.SUMMARIZING
    )
    
    async with StrandsClaude4Driver(config) as driver:
        conversation_id = "streaming_chat"
        await driver.start_conversation(conversation_id)
        
        async for chunk in driver.stream_conversation(
            "Write a story about space exploration",
            conversation_id
        ):
            print(chunk.content, end="", flush=True)
            
            if chunk.is_complete:
                print("\n--- Response complete ---")
                break
        
        # Get conversation statistics
        stats = await driver.get_conversation_stats(conversation_id)
        print(f"Messages: {stats['message_count']}")
        print(f"Total tokens: {stats['total_tokens']}")

asyncio.run(streaming_with_caching())
```

---
*Generated: 2025-07-05T12:26:07Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/llm/strands_agent_driver*
*Total Files: 6*
*Total Subdirectories: 1*

# End of strands_agent_driver_kb.md