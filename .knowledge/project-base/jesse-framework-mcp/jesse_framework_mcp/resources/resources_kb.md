<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/

## Global Summary

#### Functional Intent & Features

This directory implements the comprehensive resources layer for the Jesse Framework MCP Server, providing HTTP-formatted resource handlers that deliver all essential development contexts through modern resource-first architecture with individual access patterns and intelligent session initialization capabilities. The directory enables MCP clients to access framework rules, project knowledge, WIP tasks, workflows, knowledge bases, and gitignore compliance through dedicated resource URIs supporting both granular individual access and consolidated meta-resource delivery for efficient AI-assisted development workflows. Key semantic entities include primary resource handler functions `get_wip_tasks_inventory()`, `get_jesse_workflow()`, `get_session_init_context()`, `get_knowledge_management_rule()`, `get_project_knowledge()`, `get_git_clones_readme()`, and `get_gitignore_compliance_status()` decorated with `@server.resource()` patterns, centralized registration function `register_all_resources()` coordinating all resource handler registrations, HTTP formatting functions `format_http_section()` and `format_multi_section_response()` with criticality classifications `XAsyncContentCriticality.CRITICAL`, `XAsyncContentCriticality.INFORMATIONAL`, utility classes `FeatureDetector`, `GitignoreValidator`, `ComplianceIssue`, and `GitignoreComplianceResult` for intelligent compliance management, resource URIs including `jesse://wip-tasks`, `jesse://framework/rule/{rule_name}`, `jesse://session/init-context`, `jesse://project/knowledge`, `jesse://knowledge/{kb_name}`, `file://workflows/{workflow_name}`, and `jesse://project/gitignore-compliance`, workflow integration with Cline slash commands through `Cline-Slash-Command` headers, knowledge base types supporting git clones and PDF documents with lazy loading, and comprehensive error handling with individual section failure isolation enabling resilient resource delivery across all components. The system implements FastMCP auto-registration through decorators with HTTP-formatted resource delivery ensuring consistent AI assistant processing and context-optimized session initialization through smart compliance checking and conditional output strategies.

##### Main Components

The directory contains eight primary Python files providing comprehensive resource management capabilities across all Jesse Framework development contexts. The `wip_tasks.py` module implements WIP task resource handlers with inventory and individual task access through JSON and markdown formatting. The `workflows.py` module provides embedded workflow resources for Cline slash command integration with CRITICAL criticality classification. The `session_init.py` module implements meta-resource aggregation combining all essential contexts into consolidated HTTP responses for efficient session initialization. The `framework_rules.py` module delivers individual JESSE Framework rules with CRITICAL criticality for AI assistant enforcement. The `project_resources.py` module handles project-specific resources including knowledge bases and context summaries with INFORMATIONAL classification. The `knowledge.py` module provides lazy loading access to git clone and PDF knowledge bases with metadata extraction. The `gitignore.py` module implements intelligent compliance checking with smart feature detection and conditional output strategies. The `__init__.py` module coordinates centralized resource registration through `register_all_resources()` function with modular organization and FastMCP auto-registration patterns.

###### Architecture & Design

The architecture implements a modern resource-first design with clear separation between individual resource handlers and meta-resource aggregation, following FastMCP server integration patterns with decorator-based registration and HTTP-formatted content delivery for consistent AI assistant processing. The design emphasizes modular organization with dedicated modules for different resource types, intelligent session initialization through meta-resource patterns combining multiple contexts, and smart compliance checking with conditional output strategies optimizing context delivery based on validation results. Key design patterns include the resource handler pattern with FastMCP decorators for endpoint registration, meta-resource aggregation pattern combining multiple resource types into unified responses, smart compliance pattern with feature detection and conditional output, lazy loading pattern for on-demand knowledge base access, embedded content access pattern for package-bundled workflows, graceful degradation pattern with placeholder content for missing resources, and centralized registration pattern coordinating all resource handlers through single initialization point. The system uses composition over inheritance with specialized classes for different resource aspects, HTTP formatting integration for standardized MCP response delivery, and comprehensive error handling with individual section failure isolation preventing complete resource delivery failures.

####### Implementation Approach

The implementation uses async function patterns with FastMCP Context integration for progress reporting and structured logging throughout all resource processing operations. Resource discovery employs directory scanning, embedded content access, and feature detection algorithms for intelligent resource enumeration and validation. Content delivery combines JSON serialization for structured data, markdown formatting for documentation content, and HTTP section wrapping with appropriate criticality classifications and metadata headers. The approach implements working directory management with project root detection for consistent file access, sequential loading with progress reporting for meta-resource aggregation, and conditional output strategies returning empty responses when compliant for massive context reduction. Pattern validation uses exact string matching with diagnostic generation, while knowledge base access employs metadata extraction from content headers and file system timestamps. Error handling employs try-catch blocks with specific exception types, graceful degradation with placeholder content, and individual section failure isolation maintaining overall resource functionality. Resource registration uses import-time execution with centralized coordination and FastMCP decorator auto-registration for modern transport integration.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:Context` - async progress reporting and structured logging for all resource processing operations across modules
- `..main:server` - FastMCP server instance for resource registration with decorator patterns and auto-registration functionality
- `..helpers.async_http_formatter:format_http_section` - HTTP section formatting with criticality classification and portable path resolution
- `..helpers.async_http_formatter:format_multi_section_response` - multi-section HTTP response formatting for meta-resource aggregation
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for CRITICAL and INFORMATIONAL classifications
- `..helpers.async_http_formatter:XAsyncHttpPath` - HTTP path handling for portable resource location specification with writable capabilities
- `..helpers.path_utils:get_project_root` - project root detection for consistent file system operations across deployment contexts
- `..helpers.content_loaders:load_embedded_content` - embedded content access for build-time copied framework rules and workflows
- `..helpers.session_management:get_current_wip_task_name_async` - WIP task status retrieval for project context building
- `..helpers.knowledge_scanners:scan_git_clone_knowledge_bases_async` - external knowledge base enumeration for context aggregation
- `importlib.resources` (external library) - embedded content access for package-bundled workflow files with Python version compatibility
- `pathlib.Path` (external library) - cross-platform file system operations for directory scanning and file access
- `json` (external library) - structured data serialization for task inventories and workflow catalogs
- `datetime` (external library) - timestamp generation and ISO format conversion for resource metadata
- `dataclasses` (external library) - structured data representation for compliance issues and resource results

**← Outbound:**
- Cline AI assistant - consuming comprehensive session context through `jesse://session/init-context` and individual workflows as slash commands
- MCP clients - accessing all resource types through standardized URIs including framework rules, project resources, knowledge bases, and compliance status
- Development environments - using HTTP-formatted resources with appropriate criticality levels for AI-assisted development workflows
- Session initialization systems - leveraging meta-resource aggregation for efficient context delivery with individual section failure isolation
- AI coding assistants - consuming framework rules with CRITICAL criticality for strict adherence and workflow resources for development guidance
- Project management tools - using WIP task inventories and project context summaries for development oversight and tracking
- Knowledge management workflows - accessing git clone and PDF knowledge bases with lazy loading and metadata extraction

**⚡ System role and ecosystem integration:**
- **System Role**: Comprehensive resource delivery layer within Jesse Framework MCP Server ecosystem, providing all essential development contexts through HTTP-formatted resources with modern resource-first architecture and intelligent session initialization capabilities
- **Ecosystem Position**: Core resource infrastructure serving as primary interface between MCP clients and all framework functionality, integrating individual resource access with meta-resource aggregation for efficient context delivery
- **Integration Pattern**: Used by MCP clients through standardized resource URI requests with HTTP-formatted responses, consumed by AI assistants through session initialization and individual resource access, integrated with FastMCP server through decorator-based auto-registration, and coordinated with all framework components through centralized resource management and intelligent compliance checking

######### Edge Cases & Error Handling

The system handles missing project root through comprehensive validation with fallback to setup guidance when project structure unavailable for resource operations. Individual resource failures are isolated through try-catch blocks preventing complete resource delivery failures while maintaining overall system functionality. Working directory management includes restoration mechanisms preventing directory state corruption across resource requests. File system access errors are managed through graceful degradation with placeholder content for missing resources and detailed error context for debugging. Feature detection handles directory access permissions and missing directories through conditional scanning with fallback behaviors. Content parsing implements encoding compatibility with UTF-8 primary and latin-1 fallback for different file character sets. Resource registration manages import failures and missing registration functions through Python's standard exception handling with error isolation. Smart compliance checking returns empty responses for compliant systems enabling massive context reduction while providing detailed guidance when issues require attention. Meta-resource aggregation handles individual section failures through error section generation maintaining session initialization functionality despite partial failures.

########## Internal Implementation Details

The directory uses modular organization with eight specialized Python files each handling specific resource types through dedicated classes and functions. Resource registration employs import-time execution with `register_all_resources()` function coordinating sequential registration of all resource handlers through relative imports and direct function calls. HTTP formatting uses consistent patterns with `format_http_section()` calls including specific content types, criticality classifications, portable location paths with placeholder variables, and additional headers for enhanced metadata delivery. File system operations use absolute path construction through project root detection with cross-platform compatibility via `pathlib.Path` and `os.path.join()` patterns. Content loading implements UTF-8 encoding with whitespace validation, empty content detection, and placeholder generation for missing or inaccessible resources. Progress reporting uses percentage-based updates with descriptive status messages for transparent loading feedback during meta-resource aggregation. Pattern validation employs exact string matching with line-by-line comparison preserving original formatting including comments and whitespace for compliance checking. Resource URIs follow consistent patterns with `jesse://` scheme for framework resources, `file://workflows/` for Cline integration, and parameterized paths for individual resource access. Error handling implements specific exception types with detailed error messages including resource names, file paths, and operation context for comprehensive debugging support.

########### Usage Examples

Comprehensive session initialization demonstrates the meta-resource pattern for efficient context delivery combining all essential development contexts. This approach provides complete framework setup through single resource request optimized for AI assistant session startup.

```python
# Access comprehensive session initialization context for complete development environment setup
# Returns multi-section HTTP response with framework rules, project context, WIP tasks, workflows, and compliance
session_context = await mcp_client.read_resource("jesse://session/init-context")
# Content includes all essential contexts with individual section failure isolation and progress reporting
```

Individual resource access showcases the granular resource pattern for specific development contexts with appropriate criticality levels. This pattern enables targeted resource consumption for focused development workflows and AI assistant processing.

```python
# Access individual framework resources with appropriate criticality for AI assistant enforcement
# Framework rules delivered with CRITICAL criticality for strict adherence
framework_rule = await mcp_client.read_resource("jesse://framework/rule/knowledge_management")

# Project resources delivered with INFORMATIONAL criticality for context awareness
project_knowledge = await mcp_client.read_resource("jesse://project/knowledge")
wip_tasks = await mcp_client.read_resource("jesse://wip-tasks")

# Workflow resources for Cline slash command integration with CRITICAL criticality
workflow = await mcp_client.read_resource("file://workflows/jesse_wip_task_create")

# Smart compliance checking with conditional output for context optimization
compliance = await mcp_client.read_resource("jesse://project/gitignore-compliance")
if not compliance.strip():
    print("Fully compliant - no action needed")
```

## Subdirectory Knowledge Integration

*No subdirectories processed*

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/__init__.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file serves as the resources package initialization module for the Jesse Framework MCP Server, providing centralized registration and coordination of all FastMCP resource handlers through a modern resource-first architecture with individual resource access patterns. The module enables comprehensive resource management by orchestrating the registration of framework rules, project resources, workflows, knowledge bases, WIP tasks, and session initialization meta-resources through a single initialization point. Key semantic entities include the primary registration function `register_all_resources()` for coordinating all resource handler registrations, imported registration functions `register_framework_rules_resources()`, `register_project_resources()`, `register_workflows_resources()`, `register_knowledge_resources()`, `register_wip_tasks_resources()`, and `register_session_init_resources()` from respective resource modules, module imports from `.framework_rules`, `.project_resources`, `.workflows`, `.knowledge`, `.wip_tasks`, and `.session_init` submodules, `__all__` export list defining the public package interface with six resource module names, and comprehensive docstring documentation describing the package organization including workflows for Cline slash command integration, knowledge bases with lazy loading, WIP tasks inventory, individual JESSE rule resources, project-specific handlers, and session initialization meta-resource functionality. The system implements FastMCP auto-registration through decorators for modern transport with HTTP-formatted resource delivery ensuring consistent AI assistant processing across all resource types.

##### Main Components

The file contains one primary registration function and six module imports providing comprehensive resource management coordination capabilities. The `register_all_resources()` function serves as the central orchestrator importing and calling registration functions from all resource modules including framework rules, project resources, workflows, knowledge bases, WIP tasks, and session initialization. The module imports include `.framework_rules` for individual JESSE rule resources, `.project_resources` for project context resources, `.workflows` for HTTP-formatted workflow resources with Cline integration, `.knowledge` for external knowledge base resources with lazy loading, `.wip_tasks` for WIP task inventory and individual task resources, and `.session_init` for session initialization meta-resource combining all essential contexts. The `__all__` export list defines the public package interface exposing all six resource modules for external consumption and import management.

###### Architecture & Design

The architecture implements a centralized registration pattern with modular resource organization, following resource-first architecture principles with individual resource handlers and FastMCP auto-registration through decorators for modern transport. The design emphasizes HTTP-formatted resource delivery for consistent AI assistant processing, modular organization for maintainability and extensibility, and comprehensive resource coverage including framework rules, project context, workflows, knowledge bases, WIP tasks, and session initialization. Key design patterns include the centralized registration pattern coordinating all resource handler registrations through a single function, modular organization pattern separating resource types into dedicated modules, auto-registration pattern leveraging FastMCP decorators for modern transport, and package initialization pattern executing registration on module import. The system uses composition over inheritance with individual resource modules handling specific functionality, centralized coordination through the main registration function, and comprehensive export management through `__all__` list definition.

####### Implementation Approach

The implementation uses import-time registration execution through direct function call at module level ensuring all resources are registered when the package is imported. Resource coordination employs sequential registration function calls importing each resource module's registration function and executing it to register all handlers within that module. The approach implements modular import patterns with relative imports from resource submodules using dot notation for clean namespace organization. Package interface definition uses `__all__` list with six module names providing explicit control over public exports and import behavior. Error handling relies on individual resource modules for specific error management while maintaining centralized coordination. The registration sequence follows logical ordering with framework rules first, followed by project resources, workflows, knowledge bases, WIP tasks, and session initialization meta-resource last for comprehensive context delivery.

######## External Dependencies & Integration Points

**→ Inbound:**
- `.framework_rules:register_framework_rules_resources` - individual JESSE rule resource registration for framework compliance and AI assistant enforcement
- `.project_resources:register_project_resources` - project context resource registration for development workflow integration
- `.workflows:register_workflows_resources` - workflow resource registration for Cline slash command integration and AI assistant workflows
- `.knowledge:register_knowledge_resources` - external knowledge base resource registration for lazy loading and context delivery
- `.wip_tasks:register_wip_tasks_resources` - WIP task resource registration for project management and development tracking
- `.session_init:register_session_init_resources` - session initialization meta-resource registration for comprehensive context loading

**← Outbound:**
- Jesse Framework MCP Server main module - consuming resource package initialization for complete resource handler registration
- FastMCP server instance - receiving all registered resource handlers through auto-registration decorator patterns
- MCP clients - accessing all registered resources through standardized resource URIs and HTTP-formatted responses
- Development environments - using comprehensive resource access for AI-assisted development workflows and context delivery
- Session initialization systems - leveraging complete resource registration for comprehensive development context aggregation

**⚡ System role and ecosystem integration:**
- **System Role**: Central resource coordination hub within Jesse Framework MCP Server ecosystem, providing comprehensive resource handler registration and package initialization for all resource types including framework rules, project context, workflows, knowledge bases, WIP tasks, and session initialization
- **Ecosystem Position**: Core infrastructure component serving as the primary resource management interface, coordinating all resource handler registrations and providing unified package access for the complete MCP server resource ecosystem
- **Integration Pattern**: Used by MCP server main module through package import for complete resource registration, consumed by FastMCP server through auto-registration patterns, and integrated with all resource modules through centralized coordination and sequential registration execution

######### Edge Cases & Error Handling

The system handles import failures through Python's standard import mechanism with potential ImportError exceptions if resource modules are missing or corrupted during package initialization. Registration function failures are managed through individual resource module error handling with potential propagation to the main registration function. Module import order dependencies are handled through sequential registration calls ensuring proper initialization sequence across all resource types. Missing registration functions trigger AttributeError exceptions during import and function call operations. The centralized registration approach provides error isolation where individual resource module failures do not prevent other resources from registering successfully. Package initialization errors during import-time registration execution can prevent the entire resources package from loading properly. The `__all__` list ensures controlled exports preventing accidental access to internal implementation details while maintaining comprehensive resource module access.

########## Internal Implementation Details

The module uses import-time execution with `register_all_resources()` function call at module level ensuring all resource handlers are registered immediately when the package is imported. Registration sequence implements specific ordering with framework rules first, followed by project resources, workflows, knowledge bases, WIP tasks, and session initialization meta-resource for logical dependency management. Relative imports use dot notation with `.module_name` pattern for clean namespace organization and consistent import behavior across the package structure. Function registration employs direct function calls to imported registration functions with no parameter passing or return value handling. Package interface definition uses `__all__` list with explicit module names including `framework_rules`, `project_resources`, `session_init`, `workflows`, `knowledge`, and `wip_tasks` for controlled public exports. Error propagation relies on Python's standard exception handling with potential failures during import or registration function execution. The module maintains minimal implementation focusing on coordination and registration with all functional logic delegated to individual resource modules.

########### Code Usage Examples

Package import demonstrates the automatic resource registration pattern triggered by importing the resources package. This approach provides complete resource handler registration through a single import operation for MCP server initialization.

```python
# Import resources package to automatically register all resource handlers
# Triggers registration of framework rules, project resources, workflows, knowledge bases, WIP tasks, and session initialization
from jesse_framework_mcp import resources
# All resource handlers are now registered with the FastMCP server instance
```

Individual resource module access showcases the modular organization pattern for specific resource type operations. This pattern enables targeted resource module usage while maintaining the centralized registration coordination.

```python
# Access individual resource modules for specific functionality
# Provides direct access to resource module components while maintaining registration coordination
from jesse_framework_mcp.resources import framework_rules, project_resources, workflows
from jesse_framework_mcp.resources import knowledge, wip_tasks, session_init

# Individual modules provide specific resource handler functionality
# All modules are automatically registered through package initialization
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/framework_rules.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file implements individual JESSE Framework rule resource handlers for the MCP server, providing granular access to each framework rule through HTTP-formatted resources with CRITICAL criticality classification to ensure strict AI assistant compliance. The module enables MCP clients to access specific JESSE rules through dedicated resource URIs following the `jesse://framework/rule/{rule_name}` pattern, supporting comprehensive framework enforcement and development standards adherence. Key semantic entities include six individual resource handler functions `get_knowledge_management_rule()`, `get_hints_rule()`, `get_code_comments_rule()`, `get_code_generation_rule()`, `get_markdown_rule()`, and `get_scratchpad_rule()` decorated with `@server.resource()`, utility functions `get_available_rule_names()`, `get_rule_description()`, and `get_rule_by_name()` for rule discovery and routing, `load_embedded_content()` from content loaders for accessing build-time embedded rule files, `format_http_section()` from `async_http_formatter` with `XAsyncContentCriticality.CRITICAL` classification, `Context` from `fastmcp` for async progress reporting, `get_jesse_rule_files()` and `get_jesse_rule_mapping()` from constants module, `unwrap_fastmcp_function()` utility for decorated function handling, and `writable=False` parameters ensuring read-only access to framework rules. The system implements resource-first architecture with FastMCP Context integration for progress reporting and maintains HTTP formatting preservation exactly matching existing implementation patterns for consistent AI assistant processing.

##### Main Components

The file contains six primary resource handler functions and three utility functions providing comprehensive JESSE Framework rule access capabilities. The individual resource handlers include `get_knowledge_management_rule()` for knowledge system directives, `get_hints_rule()` for AI assistant enforcement rules, `get_code_comments_rule()` for documentation standards, `get_code_generation_rule()` for development best practices, `get_markdown_rule()` for file management standards, and `get_scratchpad_rule()` for directory management requirements. Supporting utility functions include `get_available_rule_names()` for dynamic rule discovery converting file names to resource-friendly identifiers, `get_rule_description()` for human-readable rule descriptions with centralized mapping, and `get_rule_by_name()` for centralized routing to appropriate resource handlers with FastMCP function unwrapping. The `register_framework_rules_resources()` function provides explicit registration compatibility while leveraging FastMCP decorator auto-registration patterns.

###### Architecture & Design

The architecture implements a resource-oriented design pattern with individual resource handlers for each JESSE Framework rule, following FastMCP server integration patterns with decorator-based resource registration and CRITICAL criticality classification for mandatory AI assistant compliance. The design emphasizes granular access through dedicated resource URIs, HTTP formatting preservation matching existing implementation patterns, and embedded content access from build-time copying for consistent rule delivery. Key design patterns include the individual resource pattern providing dedicated handlers for each framework rule, HTTP formatting preservation pattern maintaining existing format_http_section patterns, CRITICAL criticality pattern ensuring AI assistant enforcement, embedded content access pattern using build-time copied rule files, and function unwrapping pattern for FastMCP compatibility with decorated resource handlers. The system uses composition over inheritance with utility functions for rule discovery and routing, centralized error handling with descriptive error messages, and read-only access control through writable=False parameters for framework rule integrity.

####### Implementation Approach

The implementation uses async function patterns with FastMCP Context integration for progress reporting and structured logging throughout rule loading operations. Embedded content access employs `load_embedded_content()` function for accessing build-time copied JESSE rule files with consistent file naming patterns. HTTP formatting applies `format_http_section()` with CRITICAL criticality classification, portable path resolution using `{CLINE_RULES}` placeholders, and read-only access control through `writable=False` parameters. The approach implements rule name conversion from file names to resource identifiers by removing `JESSE_` prefix and `.md` suffix with lowercase transformation. Centralized routing uses dictionary mapping of rule names to handler functions with FastMCP function unwrapping for decorated resource compatibility. Error handling employs try-catch blocks with specific ValueError exceptions and detailed error context for debugging support. Rule discovery implements dynamic enumeration from constants module with consistent naming pattern recognition for resource URI generation.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:Context` - async progress reporting and structured logging for rule loading operations
- `..main:server` - FastMCP server instance for resource registration with decorator patterns
- `..helpers.content_loaders:load_embedded_content` - embedded content access for build-time copied JESSE rule files
- `..helpers.async_http_formatter:format_http_section` - HTTP section formatting with criticality classification and portable paths
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for CRITICAL classification
- `..helpers.async_http_formatter:XAsyncHttpPath` - HTTP path handling for portable resource location specification
- `..constants:get_jesse_rule_files` - JESSE rule file enumeration for dynamic discovery
- `..constants:get_jesse_rule_mapping` - rule file mapping for consistent access patterns
- `utils:unwrap_fastmcp_function` - FastMCP function compatibility utility for decorated resource handler unwrapping

**← Outbound:**
- AI assistants - consuming individual JESSE framework rules through `jesse://framework/rule/{rule_name}` URIs with CRITICAL criticality
- MCP clients - accessing granular framework rule content through dedicated resource endpoints
- Development environments - using framework rules for development standards enforcement and compliance checking
- Session initialization systems - consuming framework rules through `get_rule_by_name()` for comprehensive context delivery
- Rule discovery systems - using `get_available_rule_names()` for dynamic rule enumeration and resource listing

**⚡ System role and ecosystem integration:**
- **System Role**: Individual JESSE Framework rule provider within Jesse Framework MCP Server ecosystem, delivering granular access to framework rules with CRITICAL criticality for AI assistant enforcement and development standards compliance
- **Ecosystem Position**: Core framework component serving as authoritative source for JESSE development rules, integrating with session initialization and providing foundation for AI assistant behavior enforcement
- **Integration Pattern**: Used by AI assistants through individual resource URI requests with CRITICAL criticality enforcement, consumed by session initialization for comprehensive rule delivery, and integrated with embedded content system for build-time rule access with read-only integrity protection

######### Edge Cases & Error Handling

The system handles missing embedded rule content through try-catch blocks with specific ValueError exceptions and detailed error context when rule files cannot be loaded from build-time embedded content. Unknown rule names in `get_rule_by_name()` trigger ValueError exceptions with descriptive error messages for invalid rule requests. FastMCP function unwrapping handles decorated resource handler compatibility through `unwrap_fastmcp_function()` utility managing parameter extraction for proper function invocation. Content loading failures are managed through exception propagation with Context logging for debugging support and error tracking. Rule name conversion handles edge cases in file name processing with consistent pattern matching for `JESSE_` prefix and `.md` suffix removal. Progress reporting uses FastMCP Context with structured logging for rule loading operations and error conditions. HTTP formatting failures are handled through exception propagation maintaining error context for debugging and troubleshooting support.

########## Internal Implementation Details

The module uses embedded content access through `load_embedded_content()` function for accessing build-time copied JESSE rule files including `JESSE_KNOWLEDGE_MANAGEMENT.md`, `JESSE_HINTS.md`, `JESSE_CODE_COMMENTS.md`, `JESSE_CODE_GENERATION.md`, `JESSE_MARKDOWN.md`, and `JESSE_SCRATCHPAD.md`. HTTP formatting employs `format_http_section()` with specific parameters including `content_type="text/markdown"`, `criticality=XAsyncContentCriticality.CRITICAL`, portable location paths using `{CLINE_RULES}` placeholders, and `writable=False` for read-only access control. Rule name conversion implements string processing with `rule_file[6:-3].lower()` for removing `JESSE_` prefix and `.md` suffix with lowercase transformation. Centralized routing uses dictionary mapping with handler function references and FastMCP function unwrapping through `unwrap_fastmcp_function()` for decorated resource compatibility. Error handling implements specific exception types with detailed error messages including rule names and operation context. Resource registration uses FastMCP decorator auto-registration with `@server.resource()` patterns and explicit registration compatibility through `register_framework_rules_resources()` function.

########### Code Usage Examples

Individual rule access demonstrates the primary consumption pattern for specific JESSE Framework rules with CRITICAL criticality enforcement. This approach provides granular access to framework rules for AI assistant processing and development standards compliance.

```python
# Access specific JESSE Framework rule through dedicated resource URI
# Returns HTTP-formatted rule content with CRITICAL criticality for AI assistant enforcement
rule_content = await mcp_client.read_resource("jesse://framework/rule/knowledge_management")
# Content includes comprehensive knowledge management directives with mandatory compliance
```

Rule discovery and routing showcases the utility function pattern for dynamic rule access and enumeration. This pattern enables systematic rule loading and centralized routing for session initialization and comprehensive rule delivery.

```python
# Discover available JESSE rules and access through centralized routing
# Provides dynamic rule enumeration and consistent access patterns
available_rules = await get_available_rule_names()
# Returns list of rule names: ['knowledge_management', 'hints', 'code_comments', ...]

# Access rule through centralized routing with FastMCP compatibility
rule_content = await get_rule_by_name('code_generation', ctx)
# Returns HTTP-formatted rule content with proper function unwrapping and error handling
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/gitignore.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file implements dedicated gitignore compliance management for the Jesse Framework MCP Server, providing intelligent compliance checking and context-optimized session initialization through smart feature detection and conditional output strategies. The module enables comprehensive gitignore validation by detecting active framework features and providing precise remediation guidance only when compliance issues are found, supporting both smart compliance checking and legacy file access patterns. Key semantic entities include compliance data classes `ComplianceIssue`, `GitignoreComplianceResult`, and `ComplianceIssueType` enum for structured issue representation, feature detection class `FeatureDetector` with methods `detect_active_features()`, `is_git_clones_active()`, and `is_pdf_knowledge_active()` for intelligent feature scanning, validation class `GitignoreValidator` with methods `validate_compliance()`, `check_file_patterns()`, `parse_gitignore_file()`, and `generate_remediation_guidance()` for comprehensive compliance assessment, MCP resource handlers `get_gitignore_compliance_status()` decorated with `@server.resource("jesse://project/gitignore-compliance")` and `get_project_gitignore_files()` with `@server.resource("jesse://project/gitignore-files")`, pattern constants `GIT_CLONES_PATTERNS`, `PDF_KNOWLEDGE_PATTERNS`, and `MANDATORY_FILES` for compliance requirements, HTTP formatting functions `format_http_section()` and `format_multi_section_response()` with `XAsyncContentCriticality.CRITICAL` and `XAsyncContentCriticality.INFORMATIONAL` classifications, and path utilities `get_project_root()`, `ensure_project_root()`, and `get_project_relative_path()` for consistent file system operations. The system implements smart feature detection validating patterns only for active features with conditional output returning empty strings when compliant for massive context reduction and detailed guidance when issues require attention.

##### Main Components

The file contains four primary classes, two MCP resource handlers, and three pattern constant definitions providing comprehensive gitignore compliance management capabilities. The `ComplianceIssueType` enum defines issue categories including `MISSING_FILE`, `MISSING_PATTERNS`, `CONFLICTING_PATTERNS`, and `INVALID_CONTENT` for structured issue classification. The `ComplianceIssue` dataclass represents specific compliance problems with file paths, issue types, descriptions, required patterns, current patterns, and remediation actions. The `GitignoreComplianceResult` dataclass aggregates compliance assessment results including compliance status, active features set, issues list, and remediation guidance. The `FeatureDetector` class provides static methods for detecting active framework features requiring gitignore patterns through directory and file scanning. The `GitignoreValidator` class implements comprehensive compliance validation with pattern matching, file parsing, diagnostic generation, and remediation guidance creation. The `get_gitignore_compliance_status()` resource handler provides smart compliance checking with conditional output, while `get_project_gitignore_files()` maintains backward compatibility for direct file access with mandatory and optional file handling.

###### Architecture & Design

The architecture implements a smart compliance system with feature-driven validation, following separation of concerns principles with dedicated classes for detection, validation, and issue representation. The design emphasizes conditional output strategies returning empty responses when compliant for context optimization and detailed guidance when issues require attention, smart feature detection validating only active framework components, and precise remediation with exact copy-paste solutions for non-compliance scenarios. Key design patterns include the strategy pattern for feature detection with pluggable validation logic, data class pattern for structured issue representation and compliance results, validator pattern for comprehensive compliance assessment with diagnostic capabilities, conditional output pattern optimizing context delivery based on compliance status, and resource handler pattern providing both smart compliance checking and legacy file access. The system uses composition over inheritance with specialized classes for different compliance aspects, centralized pattern definitions for consistency, and HTTP formatting integration for standardized MCP response delivery.

####### Implementation Approach

The implementation uses feature detection algorithms scanning specific directories for active framework components including `.knowledge/git-clones/` for repository subdirectories and `.knowledge/pdf-knowledge/` for PDF files. Compliance validation employs pattern matching with exact string comparison, file parsing with UTF-8 encoding and fallback handling, and diagnostic generation providing detailed mismatch analysis. The approach implements conditional resource delivery with empty string returns for compliant systems achieving massive context reduction and comprehensive guidance generation for non-compliant scenarios. Pattern validation uses line-by-line comparison with preserved whitespace and comments for exact matching requirements. Error handling employs try-catch blocks with graceful degradation and detailed error context for debugging support. File system operations use project root detection with absolute path construction for consistent access across deployment contexts. HTTP formatting applies appropriate criticality levels with CRITICAL for compliance issues and INFORMATIONAL for status information.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:Context` - async progress reporting and structured logging for compliance validation operations
- `..main:server` - FastMCP server instance for resource registration with decorator patterns
- `..helpers.async_http_formatter:format_http_section` - HTTP section formatting with criticality classification and status codes
- `..helpers.async_http_formatter:format_multi_section_response` - multi-section HTTP response formatting for complex compliance reports
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for CRITICAL and INFORMATIONAL classifications
- `..helpers.async_http_formatter:XAsyncHttpPath` - HTTP path handling for portable resource location specification with writable capabilities
- `..helpers.path_utils:get_project_root` - project root detection for consistent file system operations
- `..helpers.path_utils:ensure_project_root` - project root validation and setup for compliance checking
- `..helpers.path_utils:get_project_relative_path` - relative path resolution for portable file references
- `dataclasses` (external library) - structured data representation for compliance issues and results
- `pathlib.Path` (external library) - cross-platform file system operations for directory scanning and file access
- `typing` (external library) - type annotations including List, Optional, Dict, Set for comprehensive type safety
- `enum.Enum` (external library) - enumeration support for compliance issue type classification

**← Outbound:**
- Session initialization systems - consuming smart compliance checking for context-optimized session startup with conditional guidance
- MCP clients - accessing gitignore compliance status through `jesse://project/gitignore-compliance` for development workflow integration
- MCP clients - accessing legacy gitignore files through `jesse://project/gitignore-files` for backward compatibility and direct file access
- Development environments - using compliance validation for project setup verification and gitignore pattern enforcement
- AI assistants - consuming compliance guidance with CRITICAL criticality for mandatory remediation actions

**⚡ System role and ecosystem integration:**
- **System Role**: Dedicated gitignore compliance management system within Jesse Framework MCP Server ecosystem, providing intelligent feature detection, smart compliance validation, and context-optimized session initialization through conditional output strategies
- **Ecosystem Position**: Core compliance component serving as specialized gitignore validation interface, integrating with session initialization for context optimization and providing both smart compliance checking and legacy file access patterns
- **Integration Pattern**: Used by session initialization through smart compliance resource for context reduction when compliant, consumed by MCP clients through dedicated compliance and file access endpoints, and integrated with project management workflows through precise remediation guidance and mandatory file validation

######### Edge Cases & Error Handling

The system handles missing project root through `get_project_root()` validation with specific compliance issues generated when project structure unavailable for validation operations. Feature detection manages directory access errors through try-catch blocks with graceful degradation when file system permissions prevent scanning operations. File parsing implements UTF-8 encoding with fallback to latin-1 encoding for compatibility with different file encodings and character sets. Pattern matching handles whitespace variations and comment preservation for exact compliance validation while providing diagnostic information for near-miss scenarios. Compliance validation manages individual file access failures through exception handling with detailed error context and remediation guidance. Resource handler error handling provides fallback responses with appropriate HTTP status codes and error information when compliance checking fails. Missing mandatory files trigger CRITICAL compliance issues with specific remediation actions, while optional files are handled gracefully with conditional inclusion based on existence. The smart compliance resource returns empty strings for compliant systems enabling massive context reduction in session initialization scenarios.

########## Internal Implementation Details

The module uses feature detection through directory scanning with `iterdir()` operations checking for subdirectories in `.knowledge/git-clones/` and PDF files in `.knowledge/pdf-knowledge/` with file extension filtering. Pattern validation employs exact string matching with line-by-line comparison preserving original formatting including comments and whitespace for byte-perfect compliance checking. Compliance issue generation uses dataclass instantiation with structured fields including file paths, issue types, descriptions, required patterns, current patterns, and remediation actions. Diagnostic generation implements detailed pattern analysis with missing pattern identification, similar pattern detection, and current file content display for debugging support. HTTP formatting uses specific status codes including 241 for compliance issues and 500 for validation errors with appropriate criticality levels and section types. File system operations use absolute path construction through `project_root / relative_path` patterns for consistent access across deployment contexts. Pattern constants define exact gitignore requirements with comment headers and specific ignore patterns for git clones and PDF knowledge features. Resource registration employs FastMCP decorator patterns with specific URI endpoints for compliance checking and file access functionality.

########### Code Usage Examples

Smart compliance checking demonstrates the conditional output pattern for context-optimized session initialization. This approach provides massive context reduction when compliant and detailed guidance when issues require attention.

```python
# Access smart gitignore compliance checking for context-optimized session initialization
# Returns empty string when compliant (major context reduction) or detailed guidance when issues found
compliance_status = await mcp_client.read_resource("jesse://project/gitignore-compliance")
if not compliance_status.strip():
    # Fully compliant - no action needed, massive context savings
    print("Gitignore compliance verified - no issues")
else:
    # Non-compliant - detailed remediation guidance provided
    print("Compliance issues found - review guidance")
```

Feature detection and validation showcases the intelligent compliance assessment pattern with active feature scanning. This pattern enables precise validation targeting only active framework components for efficient compliance checking.

```python
# Demonstrate feature detection and compliance validation workflow
# Provides intelligent scanning and precise remediation guidance
from jesse_framework_mcp.resources.gitignore import FeatureDetector, GitignoreValidator

# Detect active features requiring gitignore compliance
active_features = FeatureDetector.detect_active_features()
print(f"Active features: {active_features}")

# Validate compliance for detected features
validator = GitignoreValidator()
result = validator.validate_compliance()
print(f"Compliant: {result.is_compliant}")
print(f"Issues: {len(result.issues)}")

# Access detailed remediation guidance when needed
if result.remediation_guidance:
    print("Remediation guidance available")
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/knowledge.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file implements JESSE Framework knowledge base resource handlers for the MCP server, providing project knowledge bases as HTTP-formatted MCP resources with lazy loading functionality and direct access to specific knowledge bases without tool overhead. The module enables MCP clients to access various knowledge base types including git clone repositories, PDF documents, and project-specific knowledge through dedicated resource URIs supporting both index access and individual knowledge base retrieval. Key semantic entities include primary resource handler functions `get_git_clones_readme()`, `get_pdf_knowledge_readme()`, and `get_knowledge_base()` for knowledge access, metadata extraction functions `determine_knowledge_base_info()`, `extract_git_clone_kb_info()`, and `extract_pdf_kb_info()` for knowledge base analysis, utility functions `register_knowledge_resources()` and `get_file_modification_time()` for registration and file operations, `format_http_section()` from `async_http_formatter` with `XAsyncContentCriticality.INFORMATIONAL` classification, `Context` from `fastmcp` for async progress reporting, `get_project_root()` from path utilities for project location detection, knowledge base directory paths including `.knowledge/git-clones/`, `.knowledge/pdf-knowledge/`, and `.knowledge/persistent-knowledge/`, resource URIs `jesse://knowledge/git-clones-readme`, `jesse://knowledge/pdf-knowledge-readme`, and `jesse://knowledge/{kb_name}`, and `writable=True` parameters enabling content editing capabilities for knowledge base management. The system implements resource-based knowledge delivery with HTTP-formatted content for consistent parsing and metadata extraction across different knowledge base types.

##### Main Components

The file contains three primary resource handler functions, three metadata extraction functions, and two utility functions providing comprehensive knowledge base resource management capabilities. The `get_git_clones_readme()` function serves git clone knowledge base index from `.knowledge/git-clones/README.md` with HTTP formatting and writable capability. The `get_pdf_knowledge_readme()` function handles PDF knowledge base index from `.knowledge/pdf-knowledge/README.md` with graceful handling for missing directories and placeholder content generation. The `get_knowledge_base()` function provides individual knowledge base access supporting both git clone and PDF knowledge base types with metadata determination and content loading. Supporting metadata functions include `determine_knowledge_base_info()` for knowledge base type and location analysis, `extract_git_clone_kb_info()` for git repository metadata extraction, and `extract_pdf_kb_info()` for PDF document metadata extraction. Utility functions include `register_knowledge_resources()` for MCP resource registration and `get_file_modification_time()` for timestamp formatting.

###### Architecture & Design

The architecture implements a resource-oriented design pattern with individual resource handlers for different knowledge base types, following HTTP-formatted content delivery for consistent AI assistant processing and lazy loading functionality for on-demand knowledge base access. The design emphasizes graceful handling of missing knowledge bases through existence checking and placeholder content generation, portable path resolution using project root detection, and metadata extraction from knowledge base content headers. Key design patterns include the resource handler pattern with dedicated functions for each knowledge base type, lazy loading pattern for on-demand knowledge base retrieval, metadata extraction pattern parsing knowledge base headers for repository and document information, graceful degradation pattern with placeholder content for missing files, and HTTP formatting pattern maintaining consistent content delivery with appropriate criticality classification. The system uses composition over inheritance with utility functions for metadata operations, centralized error handling with descriptive error messages, and writable access control enabling knowledge base content editing.

####### Implementation Approach

The implementation uses async function patterns with FastMCP Context integration for progress reporting and structured logging throughout knowledge base loading operations. File system access employs absolute path construction using `os.path.join()` with project root detection for consistent file access across different deployment contexts. Content loading implements UTF-8 encoding with existence checking and graceful handling of missing files through placeholder content generation. The approach implements metadata extraction through content parsing of knowledge base headers searching for specific patterns like repository URLs, source documents, and modification timestamps. Knowledge base type determination uses file path pattern matching checking for git clone and PDF knowledge base locations with extensible design for additional types. Error handling employs try-catch blocks with specific ValueError exceptions and detailed error context for debugging support. HTTP formatting applies `format_http_section()` with INFORMATIONAL criticality, portable path placeholders, and additional headers for knowledge base metadata.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:Context` - async progress reporting and structured logging for knowledge base loading operations
- `..helpers.async_http_formatter:format_http_section` - HTTP section formatting with criticality classification and portable paths
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for INFORMATIONAL classification
- `..helpers.async_http_formatter:XAsyncHttpPath` - HTTP path handling for portable resource location specification
- `..helpers.path_utils:get_project_root` - project root detection for consistent file access across deployment contexts
- `..main:server` - FastMCP server instance for resource registration with decorator patterns
- `..helpers.knowledge_scanners:load_specific_knowledge_base_async` - knowledge base content loading for individual knowledge bases
- `os` (external library) - file system operations for path construction and file existence checking
- `json` (external library) - structured data serialization for knowledge base metadata
- `datetime` (external library) - timestamp generation and ISO format conversion for file modification times
- `pathlib.Path` (external library) - cross-platform path operations for file system compatibility

**← Outbound:**
- MCP clients - consuming knowledge base resources through `jesse://knowledge/{resource_type}` URIs for AI assistant context
- Session initialization systems - consuming knowledge base indexes for comprehensive development context delivery
- AI assistants - accessing individual knowledge bases for project-specific context and repository information
- Development environments - using knowledge base content for context-aware development workflows and documentation access
- Knowledge management workflows - consuming knowledge base indexes for repository and document management

**⚡ System role and ecosystem integration:**
- **System Role**: Knowledge base resource provider within Jesse Framework MCP Server ecosystem, delivering HTTP-formatted access to git clone repositories, PDF documents, and project knowledge with lazy loading functionality for AI assistant context delivery
- **Ecosystem Position**: Core knowledge component serving as primary interface for external knowledge sources, integrating with session initialization and providing foundation for project-aware AI assistance through structured knowledge base access
- **Integration Pattern**: Used by MCP clients through individual resource URI requests for knowledge base access, consumed by session initialization for knowledge base enumeration, and integrated with knowledge management workflows for repository and document indexing with writable content editing capabilities

######### Edge Cases & Error Handling

The system handles missing project root through `get_project_root()` validation with ValueError exceptions when project structure unavailable for knowledge base access. Missing knowledge base directories are managed through existence checking with placeholder content generation for PDF knowledge directory when `.knowledge/pdf-knowledge/` unavailable. Missing README files trigger ValueError exceptions with descriptive error messages including file paths and operation context. Knowledge base type determination handles unknown knowledge base names through systematic checking of git clone, PDF, and essential knowledge base locations with fallback error handling. Metadata extraction manages missing or malformed knowledge base headers through graceful parsing with fallback to file modification timestamps. File system permission errors are handled through try-catch blocks with appropriate error logging and exception propagation. Content loading failures implement UTF-8 encoding error handling with detailed error context for debugging support.

########## Internal Implementation Details

The module uses absolute path construction through `os.path.join(project_root, relative_path)` for consistent file access across different deployment contexts and working directories. Knowledge base type determination implements systematic checking with file path patterns including `.knowledge/git-clones/{kb_name}_kb.md` for git repositories, `.knowledge/pdf-knowledge/{kb_name}/{kb_name}_kb.md` for PDF documents, and `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` for essential project knowledge. Metadata extraction employs content parsing of first 20 lines searching for specific header patterns including `**Clone URL**:`, `**Repository**:`, `**Source PDF**:`, and `*Last Updated:` with fallback to file modification timestamps. HTTP formatting uses `format_http_section()` with specific parameters including `content_type="text/markdown"`, `criticality=XAsyncContentCriticality.INFORMATIONAL`, portable location paths using `{PROJECT_ROOT}` placeholders, and additional headers for knowledge type, source URLs, and modification timestamps. File modification time extraction uses `os.stat()` with ISO format conversion through `datetime.fromtimestamp().isoformat() + 'Z'` for consistent timestamp formatting. Resource registration employs direct server decoration with `server.resource()` calls for each knowledge base resource handler.

########### Code Usage Examples

Knowledge base index access demonstrates the primary consumption pattern for git clone and PDF knowledge base indexes with HTTP formatting. This approach provides knowledge base overview and management capabilities through dedicated resource endpoints.

```python
# Access knowledge base indexes through dedicated resource URIs
# Returns HTTP-formatted index content with metadata and writable capability
git_clones_index = await mcp_client.read_resource("jesse://knowledge/git-clones-readme")
pdf_knowledge_index = await mcp_client.read_resource("jesse://knowledge/pdf-knowledge-readme")
# Content includes knowledge base listings, directory structure, and management guidance
```

Individual knowledge base access showcases the lazy loading pattern for specific knowledge base retrieval with metadata extraction. This pattern enables on-demand knowledge base loading with comprehensive metadata and content delivery for AI assistant context.

```python
# Access individual knowledge base through parameterized resource URI
# Returns HTTP-formatted knowledge base content with metadata headers
knowledge_base = await mcp_client.read_resource("jesse://knowledge/cline_kb")
# Content includes full knowledge base with repository information and modification timestamps

# Knowledge base metadata available through HTTP headers
metadata = knowledge_base.headers
kb_type = metadata.get("Knowledge-Type")  # 'git-clone', 'pdf', or 'essential'
source_url = metadata.get("Source-URL")   # Repository or document source
last_updated = metadata.get("Last-Updated")  # ISO timestamp
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/project_resources.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file implements project-specific resource handlers for the Jesse Framework MCP Server, providing individual access to project knowledge, WIP tasks, and context summaries through HTTP-formatted resources with INFORMATIONAL criticality classification for development context delivery. The module enables MCP clients to access project-specific information through dedicated resource URIs including `jesse://project/knowledge`, `jesse://project/context`, and `jesse://project/wip-tasks`, supporting comprehensive project development workflow management and context awareness. Key semantic entities include three primary resource handler functions `get_project_knowledge()`, `get_project_context_summary()`, and `get_wip_tasks_inventory()` decorated with `@server.resource()`, utility functions `get_project_resource_by_type()` and `register_project_resources()` for routing and registration, `format_http_section()` from `async_http_formatter` with `XAsyncContentCriticality.INFORMATIONAL` classification, `Context` from `fastmcp` for async progress reporting, `get_current_wip_task_name_async()` from session management for WIP task status, knowledge scanner functions `scan_git_clone_knowledge_bases_async()` and `scan_pdf_knowledge_bases_async()` for external knowledge enumeration, `pathlib.Path` for file system operations, `json` module for structured data serialization, and `writable=True` parameters enabling content editing capabilities for project files. The system implements graceful handling of missing project files with appropriate placeholder content and maintains HTTP formatting consistency across all project resource types.

##### Main Components

The file contains three primary resource handler functions and two utility functions providing comprehensive project-specific resource access capabilities. The `get_project_knowledge()` function serves project knowledge base content from `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` with graceful handling for missing files. The `get_project_context_summary()` function builds comprehensive project overview combining WIP task status, knowledge base availability, external knowledge sources count, and framework architecture information. The `get_wip_tasks_inventory()` function scans `.knowledge/work-in-progress/` directory and builds structured JSON inventory with task metadata, status information, and access URIs. Supporting utility functions include `get_project_resource_by_type()` for centralized routing to appropriate resource handlers and `register_project_resources()` for explicit registration compatibility while leveraging FastMCP decorator auto-registration patterns.

###### Architecture & Design

The architecture implements a resource-oriented design pattern with individual resource handlers for different project aspects, following FastMCP server integration patterns with decorator-based resource registration and INFORMATIONAL criticality classification for project context delivery. The design emphasizes graceful handling of missing project files through existence checking and placeholder content generation, HTTP formatting preservation matching existing implementation patterns, and structured data organization for programmatic access. Key design patterns include the individual resource pattern providing dedicated handlers for each project aspect, graceful degradation pattern with placeholder content for missing files, structured data pattern using JSON formatting for WIP task inventory, context aggregation pattern combining multiple project information sources, and HTTP formatting preservation pattern maintaining existing format_http_section patterns. The system uses composition over inheritance with utility functions for resource routing, centralized error handling with descriptive error messages, and writable access control enabling content editing for project files.

####### Implementation Approach

The implementation uses async function patterns with FastMCP Context integration for progress reporting and structured logging throughout project resource loading operations. File system access employs `pathlib.Path` for cross-platform compatibility with existence checking and graceful handling of missing project files. Content loading implements UTF-8 encoding with empty content detection and placeholder generation for missing or empty files. The approach implements structured data organization using JSON serialization for WIP task inventory with metadata extraction including modification times and file availability status. Context aggregation combines multiple information sources including current WIP task status, knowledge base availability, external knowledge source counts, and project architecture overview. Error handling employs try-catch blocks with specific ValueError exceptions and detailed error context for debugging support. Resource routing uses dictionary mapping of resource types to handler functions for centralized access patterns.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:Context` - async progress reporting and structured logging for project resource loading operations
- `..main:server` - FastMCP server instance for resource registration with decorator patterns
- `..helpers.async_http_formatter:format_http_section` - HTTP section formatting with criticality classification and portable paths
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for INFORMATIONAL classification
- `..helpers.async_http_formatter:XAsyncHttpPath` - HTTP path handling for portable resource location specification
- `..helpers.async_http_formatter:format_multi_section_response` - multi-section HTTP response formatting for complex resources
- `..helpers.session_management:get_current_wip_task_name_async` - current WIP task status retrieval for context building
- `..helpers.knowledge_scanners:scan_git_clone_knowledge_bases_async` - git clone knowledge base enumeration for external source counting
- `..helpers.knowledge_scanners:scan_pdf_knowledge_bases_async` - PDF knowledge base enumeration for external source counting
- `json` (external library) - structured data serialization for WIP task inventory JSON formatting
- `datetime` (external library) - timestamp generation for content metadata and modification tracking
- `pathlib.Path` (external library) - cross-platform file system operations for project file access

**← Outbound:**
- MCP clients - consuming project-specific resources through `jesse://project/{resource_type}` URIs for development context
- Development environments - using project knowledge and WIP task information for context-aware development workflows
- Session initialization systems - consuming project resources for comprehensive development context delivery
- AI assistants - accessing project context summaries and knowledge bases for project-aware assistance
- Project management tools - using WIP task inventory and project status information for development oversight

**⚡ System role and ecosystem integration:**
- **System Role**: Project-specific resource provider within Jesse Framework MCP Server ecosystem, delivering individual access to project knowledge, WIP tasks, and context summaries with INFORMATIONAL criticality for development context awareness
- **Ecosystem Position**: Core project component serving as primary interface for project-specific information, integrating with session initialization and providing foundation for project-aware development workflows
- **Integration Pattern**: Used by MCP clients through individual resource URI requests for project context, consumed by session initialization for comprehensive project information delivery, and integrated with knowledge management system for external source enumeration and project overview generation

######### Edge Cases & Error Handling

The system handles missing project knowledge base files through existence checking with placeholder content generation when `.knowledge/persistent-knowledge/KNOWLEDGE_BASE.md` unavailable. Empty project knowledge files are detected through content stripping with appropriate placeholder messages for empty but existing files. Missing WIP tasks directory is managed through existence checking with structured JSON response indicating directory status and setup guidance. WIP task scanning handles directory iteration errors with graceful degradation and empty task list fallbacks. External knowledge source counting implements try-catch blocks around scanner functions with fallback to zero counts when scanning fails. File modification time extraction handles permission errors and missing files with graceful omission from task metadata. Context aggregation manages individual component failures with partial context delivery and error isolation. Progress reporting uses FastMCP Context with structured logging for resource loading operations and error conditions.

########## Internal Implementation Details

The module uses file system access through `pathlib.Path` operations with existence checking using `.exists()` and size validation using `.stat().st_size` for content availability determination. Project knowledge loading implements UTF-8 encoding with `open(kb_path, 'r', encoding='utf-8')` and content validation through `.strip()` for empty file detection. WIP task inventory builds structured data using dictionary comprehensions with metadata extraction including task names, current task status, file availability flags, and modification timestamps. Context summary generation combines multiple information sources with formatted markdown content including project status, framework architecture, and resource access patterns. HTTP formatting employs `format_http_section()` with specific parameters including `content_type="text/markdown"` or `"application/json"`, `criticality=XAsyncContentCriticality.INFORMATIONAL`, portable location paths using `{PROJECT_ROOT}` placeholders, and `writable=True` for editable project content. Error handling implements specific exception types with detailed error messages including resource types and operation context. Resource routing uses dictionary mapping with handler function references for centralized access patterns and consistent error handling.

########### Code Usage Examples

Project knowledge access demonstrates the primary consumption pattern for project-specific knowledge base content with graceful handling of missing files. This approach provides project knowledge with INFORMATIONAL criticality for development context awareness.

```python
# Access project knowledge base through dedicated resource URI
# Returns HTTP-formatted knowledge content with graceful handling of missing files
knowledge_content = await mcp_client.read_resource("jesse://project/knowledge")
# Content includes project-specific knowledge or placeholder guidance for missing files
```

Project context and WIP task inventory showcases the structured data access pattern for comprehensive project information. This pattern enables project overview and task management through JSON-formatted responses with metadata and access information.

```python
# Access project context summary and WIP task inventory for comprehensive project overview
# Returns structured project information with current status and resource access patterns
context_summary = await mcp_client.read_resource("jesse://project/context")
wip_inventory = await mcp_client.read_resource("jesse://project/wip-tasks")

# Parse JSON inventory for programmatic task access
import json
task_data = json.loads(wip_inventory_content)
current_task = task_data.get("current_task")
active_tasks = task_data.get("active_tasks", [])
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/session_init.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file implements a comprehensive session initialization meta-resource for the Jesse Framework MCP Server, providing a single consolidated HTTP response containing all essential development contexts needed for productive Cline session startup and AI-assisted development workflows. The module enables MCP clients to receive complete project context through the `jesse://session/init-context` resource, combining framework rules, project knowledge, WIP tasks, workflows, and compliance information in a multi-section HTTP response optimized for development efficiency. Key semantic entities include `get_session_init_context()` function decorated with `@server.resource("jesse://session/init-context")`, supporting functions `load_framework_rules_sections()`, `create_workflows_index_section()`, `load_knowledge_indexes_sections()`, and `create_error_section()`, `format_multi_section_response()` and `format_http_section()` from `async_http_formatter` module, `XAsyncContentCriticality.CRITICAL` and `XAsyncContentCriticality.INFORMATIONAL` classifications, `Context` from `fastmcp` for async progress reporting, `unwrap_fastmcp_function()` utility for function compatibility, resource integration functions including `get_rule_by_name()`, `get_project_context_summary()`, `get_project_knowledge()`, `get_wip_tasks_inventory()`, `get_embedded_workflow_files()`, `get_git_clones_readme()`, `get_pdf_knowledge_readme()`, and `get_gitignore_compliance_status()`, workflow metadata functions `get_workflow_description()` and `get_workflow_category()`, and comprehensive error handling with individual section failure isolation. The system implements sequential loading with transparent progress reporting across 7 distinct resource sections while maintaining existing criticality levels and HTTP formatting patterns for optimal Cline integration.

##### Main Components

The file contains six primary functions providing comprehensive session initialization capabilities through multi-section resource aggregation. The `get_session_init_context()` function serves as the main resource handler orchestrating sequential loading of all essential contexts with progress reporting and error isolation. The `load_framework_rules_sections()` function loads all 6 JESSE Framework Rules as individual HTTP sections with CRITICAL criticality classification. The `create_workflows_index_section()` function builds a structured catalog of available workflows with categorization and Cline slash command integration metadata. The `load_knowledge_indexes_sections()` function loads git-clones and PDF knowledge README indexes for external resource access. The `create_error_section()` function generates standardized error sections for failed resource loading with appropriate criticality levels and debugging information. The `register_session_init_resources()` function provides explicit registration compatibility while leveraging FastMCP decorator auto-registration patterns.

###### Architecture & Design

The architecture implements a meta-resource aggregation pattern with sequential loading and individual section failure isolation, following multi-section HTTP response design for comprehensive context delivery in single resource requests. The design emphasizes transparent progress reporting through percentage-based updates, graceful error handling with section-specific failure isolation, and working directory management for consistent file access across different MCP server launch contexts. Key design patterns include the meta-resource pattern aggregating multiple resource types into unified responses, sequential loading pattern with progress reporting and error isolation, multi-section HTTP response pattern maintaining existing formatting and criticality levels, error isolation pattern preventing complete session failure from individual section issues, and function unwrapping pattern for FastMCP compatibility with existing resource handlers. The system uses composition over inheritance with utility functions for specific section operations, centralized error handling with descriptive error sections, and project root detection ensuring resources work regardless of server launch method.

####### Implementation Approach

The implementation uses async function patterns with comprehensive progress reporting through `ctx.report_progress()` calls at each section loading stage. Sequential loading employs try-catch blocks around each section with individual error isolation preventing complete session initialization failure. Function compatibility uses `unwrap_fastmcp_function()` utility to handle FastMCP-decorated functions requiring parameter unwrapping before invocation. Working directory management implements `os.chdir()` to project root with try-finally restoration for consistent file access. The approach implements preferred logical ordering for framework rules using predefined sequence arrays, conditional section inclusion for gitignore compliance with smart compliance checking outputting only when issues require attention, and multi-section response assembly using `format_multi_section_response()` for consolidated HTTP delivery. Data structures use lists for section collection with dynamic extension based on successful loads, while error handling employs specific exception types with detailed context and fallback mechanisms for critical operations.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:Context` - async progress reporting and structured logging throughout multi-section loading process
- `..main:server` - FastMCP server instance for resource registration with decorator patterns
- `..helpers.async_http_formatter:format_multi_section_response` - multi-section HTTP response formatting for consolidated delivery
- `..helpers.async_http_formatter:format_http_section` - individual section HTTP formatting with criticality classification
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for CRITICAL and INFORMATIONAL levels
- `..helpers.async_http_formatter:extract_http_sections_from_multi_response` - HTTP section extraction for response processing
- `..helpers.path_utils:get_project_root` - project root detection for consistent file access
- `..helpers.project_setup:get_project_setup_guidance` - fallback guidance when project root unavailable
- `.framework_rules:get_rule_by_name` - individual JESSE framework rule loading with CRITICAL criticality
- `.framework_rules:get_available_rule_names` - framework rule enumeration for systematic loading
- `.project_resources:get_project_context_summary` - project context aggregation for development overview
- `.project_resources:get_project_knowledge` - project knowledge base access for comprehensive context
- `.wip_tasks:get_wip_tasks_inventory` - WIP task inventory for active development tracking
- `.workflows:get_embedded_workflow_files` - workflow file enumeration for catalog generation
- `.workflows:get_workflow_description` - workflow metadata extraction for catalog organization
- `.workflows:get_workflow_category` - workflow categorization for enhanced discovery
- `.knowledge:get_git_clones_readme` - git clones knowledge index for external resource access
- `.knowledge:get_pdf_knowledge_readme` - PDF knowledge index for document resource access
- `.gitignore:get_gitignore_compliance_status` - smart gitignore compliance checking with conditional output
- `.gitignore:get_project_gitignore_files` - fallback gitignore files display for compliance check failures
- `utils:unwrap_fastmcp_function` - FastMCP function compatibility utility for parameter unwrapping
- `json` (external library) - structured data serialization for workflow catalog generation
- `datetime` (external library) - timestamp generation for section metadata and error reporting
- `os` (external library) - working directory management for consistent file access

**← Outbound:**
- Cline AI assistant - consuming comprehensive session context through `jesse://session/init-context` resource for development startup
- MCP clients - accessing consolidated development context through single resource request for efficiency
- Development environments - using multi-section HTTP response with all essential contexts for productive session initialization
- AI coding assistants - consuming framework rules with CRITICAL criticality for strict adherence to development standards
- Project management tools - using WIP tasks inventory and project context for development oversight and tracking

**⚡ System role and ecosystem integration:**
- **System Role**: Session initialization meta-resource within Jesse Framework MCP Server ecosystem, providing comprehensive development context aggregation through multi-section HTTP responses for efficient Cline session startup and AI-assisted development workflows
- **Ecosystem Position**: Central meta-resource component serving as primary session initialization endpoint, aggregating all essential development contexts including framework rules, project knowledge, WIP tasks, workflows, and compliance information for complete development environment setup
- **Integration Pattern**: Used by Cline AI assistant through single resource URI request for complete session context, consumed by MCP clients for consolidated development environment initialization, and coordinated with all major resource handlers for comprehensive context delivery with individual section failure isolation

######### Edge Cases & Error Handling

The system handles missing project root through `get_project_root()` validation with fallback to `get_project_setup_guidance()` for setup instructions when project structure unavailable. Working directory management includes try-finally blocks with `os.chdir()` restoration to prevent directory state corruption across resource requests. Individual section failures are isolated through try-catch blocks around each section loading operation, generating error sections with appropriate criticality levels while allowing other sections to load successfully. Function compatibility issues are managed through `unwrap_fastmcp_function()` utility handling FastMCP-decorated functions requiring parameter unwrapping. Empty section collections trigger ValueError exceptions when no sections successfully load, preventing empty session initialization responses. Gitignore compliance checking implements smart conditional output only when issues require attention, with fallback to traditional gitignore files display on compliance check failures. Progress reporting handles percentage calculations with integer division and descriptive status messages for transparent loading feedback. Error sections maintain original criticality levels of failed sections with detailed error context and troubleshooting guidance for debugging support.

########## Internal Implementation Details

The module uses sequential section loading with progress reporting at 7 distinct stages corresponding to framework rules, project context, project knowledge, WIP tasks, workflows index, knowledge indexes, and gitignore compliance. Framework rules loading implements preferred logical ordering using predefined sequence arrays with `knowledge_management`, `hints`, `code_generation`, `code_comments`, `markdown`, and `scratchpad` priority. Working directory management employs `os.getcwd()` preservation and `os.chdir(project_root)` with try-finally restoration for consistent file access. Function unwrapping uses `unwrap_fastmcp_function()` utility for FastMCP compatibility with existing resource handlers requiring parameter extraction. Workflow catalog generation builds categorized structures with slash command metadata and resource URIs for Cline integration. Error section creation uses standardized formatting with error-specific headers including `Error-Section`, `Error-Type`, and `Error-Timestamp` for debugging support. Multi-section response assembly uses `format_multi_section_response(*sections)` for consolidated HTTP delivery with maintained individual section formatting and criticality levels. Progress reporting implements percentage-based updates with `(current_section - 1) * 100 // total_sections` calculations and descriptive status messages for transparent loading feedback.

########### Code Usage Examples

Basic session initialization demonstrates the primary resource consumption pattern for comprehensive development context delivery. This approach provides all essential contexts through single resource request for efficient Cline session startup.

```python
# Access comprehensive session initialization context through single MCP resource request
# Returns multi-section HTTP response with all essential development contexts
session_context = await mcp_client.read_resource("jesse://session/init-context")
# Content includes framework rules, project context, WIP tasks, workflows, and compliance information
```

Error handling showcases the individual section failure isolation pattern maintaining session functionality despite partial failures. This pattern demonstrates resilient session initialization with graceful degradation and error reporting.

```python
# Session initialization with individual section error isolation and progress reporting
# Each section loads independently with error sections generated for failures
try:
    session_context = await get_session_init_context(ctx)
    # Multi-section response includes successful sections and error sections for failures
    sections = extract_http_sections_from_multi_response(session_context)
    # Process individual sections with error handling for failed components
except ValueError as e:
    # Handle complete session initialization failure when no sections load successfully
    print(f"Session initialization failed: {e}")
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/wip_tasks.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file implements WIP (Work-In-Progress) task resource handlers for the Jesse Framework MCP Server, providing comprehensive task management capabilities through HTTP-formatted resources including task inventory access, individual task retrieval, and project management context integration. The module enables MCP clients to access structured WIP task information through `jesse://wip-tasks` inventory resource and `jesse://wip-task/{task_name}` individual task resources, supporting project development workflow management and task tracking within the broader Jesse Framework ecosystem. Key semantic entities include `get_wip_tasks_inventory()` function decorated with `@server.resource("jesse://wip-tasks")`, `get_specific_wip_task()` function with `@server.resource("jesse://wip-task/{task_name}")` decorator, `register_wip_tasks_resources()` registration function, task metadata extraction functions `get_current_wip_task_info()`, `get_active_wip_tasks_list()`, `get_recently_completed_tasks()`, and `get_wip_task_statistics()`, content loading functions `load_wip_task_content()` and `load_wip_progress_content()`, utility functions `get_task_status()`, `get_task_git_branch()`, and `get_task_last_updated()`, `format_http_section()` from `async_http_formatter` module with `XAsyncContentCriticality.INFORMATIONAL` classification, `Context` from `fastmcp` for async progress reporting, `pathlib.Path` for cross-platform file operations, and `json` module for structured data serialization. The system implements HTTP-formatted resource delivery with `writable=True` parameters enabling content editing capabilities while maintaining INFORMATIONAL criticality classification for helpful project context delivery.

##### Main Components

The file contains two primary resource handler functions and nine supporting utility functions providing comprehensive WIP task management capabilities. The `get_wip_tasks_inventory()` function serves the main inventory resource with JSON-formatted task data including current task information, active tasks list, completed tasks, and task statistics. The `get_specific_wip_task()` function handles individual task access by combining WIP_TASK.md and PROGRESS.md content with task metadata. Supporting functions include `get_current_wip_task_info()` for parsing project knowledge base, `get_active_wip_tasks_list()` for directory-based task discovery, `get_recently_completed_tasks()` for completion tracking, `get_wip_task_statistics()` for project metrics, `load_wip_task_content()` and `load_wip_progress_content()` for file content retrieval, and metadata extraction functions `get_task_status()`, `get_task_git_branch()`, and `get_task_last_updated()` for comprehensive task information gathering. The `register_wip_tasks_resources()` function provides centralized resource registration coordination.

###### Architecture & Design

The architecture implements a resource-oriented design pattern with clear separation between HTTP resource endpoints and underlying task management logic, following FastMCP server integration patterns with decorator-based resource registration. The design emphasizes HTTP-formatted content delivery through `format_http_section()` with consistent INFORMATIONAL criticality classification and writable content flags for editing capabilities. Key design patterns include the resource handler pattern with FastMCP decorators for endpoint registration, async context manager pattern for progress reporting and logging, directory scanning pattern for task discovery from `.knowledge/work-in-progress/` structure, content aggregation pattern combining multiple file sources into unified responses, and graceful degradation pattern with placeholder content for missing files. The system uses composition over inheritance with utility functions for specific task operations, centralized error handling with descriptive error messages, and project root detection with working directory management for consistent file access across different MCP server launch contexts.

####### Implementation Approach

The implementation uses async function patterns with FastMCP Context integration for progress reporting and structured logging throughout task processing operations. Task discovery employs directory scanning of `.knowledge/work-in-progress/` with metadata extraction from WIP_TASK.md and PROGRESS.md files using pathlib for cross-platform compatibility. Content aggregation combines JSON serialization for inventory data with markdown formatting for individual task content, utilizing `format_http_section()` with specific content types and additional headers for metadata delivery. The approach implements working directory management with `os.chdir()` to project root for consistent file access, graceful error handling with try-catch blocks and descriptive error messages, and file system timestamp tracking for task activity monitoring. Data structures use dictionaries for task information with optional field handling and None-safe operations, while content loading employs UTF-8 encoding with fallback placeholder content for missing or inaccessible files.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp:Context` - async progress reporting and structured logging for task processing operations
- `..main:server` - FastMCP server instance for resource registration with decorator patterns
- `..helpers.async_http_formatter:format_http_section` - HTTP section formatting with content type and criticality classification
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for INFORMATIONAL classification
- `..helpers.async_http_formatter:XAsyncHttpPath` - HTTP path handling for resource location specification
- `..helpers.path_utils:get_project_root` - project root detection for consistent file access across launch contexts
- `..helpers.project_setup:get_project_setup_guidance` - fallback guidance when project root unavailable
- `json` (external library) - structured data serialization for task inventory JSON formatting
- `pathlib.Path` (external library) - cross-platform file system operations for task directory scanning
- `datetime` (external library) - timestamp generation and ISO format conversion for task metadata
- `os` (external library) - working directory management for consistent file access

**← Outbound:**
- MCP clients - consuming `jesse://wip-tasks` inventory resource for project task overview and management context
- MCP clients - accessing `jesse://wip-task/{task_name}` individual task resources for focused development work
- Development tools - using HTTP-formatted task content with writable flags for task editing and progress tracking
- Project management workflows - consuming task statistics and completion tracking for development oversight
- Git integration workflows - using task branch information for development workflow coordination

**⚡ System role and ecosystem integration:**
- **System Role**: WIP task resource provider within Jesse Framework MCP Server ecosystem, delivering structured task management capabilities through HTTP-formatted resources with comprehensive metadata and content aggregation
- **Ecosystem Position**: Core resource component serving project development workflows with task inventory and individual task access, integrating with project knowledge base and file system structure for comprehensive task management
- **Integration Pattern**: Used by MCP clients through resource URI requests, integrated with Jesse Framework project structure through `.knowledge/work-in-progress/` directory scanning, and coordinated with HTTP formatter helpers for consistent content delivery with editing capabilities

######### Edge Cases & Error Handling

The system handles missing project root through `get_project_root()` validation with fallback to `get_project_setup_guidance()` for setup instructions when project structure unavailable. Working directory management includes try-finally blocks with `os.chdir()` restoration to prevent directory state corruption across resource requests. File access errors are managed through try-catch blocks with descriptive error messages and graceful degradation to placeholder content for missing WIP_TASK.md or PROGRESS.md files. Task directory scanning handles non-existent `.knowledge/work-in-progress/` directories with empty list returns rather than exceptions. Content parsing implements None-safe operations for task metadata extraction with fallback to "Unknown" values when information unavailable. JSON serialization includes `ensure_ascii=False` for Unicode content support and structured error handling for malformed task data. Progress reporting uses FastMCP Context with percentage-based updates and error logging for debugging task processing issues.

########## Internal Implementation Details

The module uses working directory management with `os.getcwd()` preservation and `os.chdir(project_root)` for consistent file access regardless of MCP server launch location. Task metadata extraction employs line-by-line parsing of markdown files searching for specific patterns like "**Status**:" and "**Branch**:" with colon-based value extraction. File timestamp tracking uses `pathlib.Path.stat().st_mtime` with `datetime.fromtimestamp().isoformat()` conversion for standardized timestamp formatting. Content loading implements UTF-8 encoding with `.strip()` for whitespace handling and conditional content validation with placeholder generation for empty files. Task statistics calculation uses list comprehensions with conditional filtering for metrics like completion rates and file availability tracking. HTTP formatting includes specific additional headers like "Tasks-Count", "Current-Task", and "Last-Updated" for enhanced metadata delivery. Progress reporting implements percentage-based updates at 25%, 50%, 75%, and 100% completion stages with descriptive status messages for user feedback during task processing operations.

########### Code Usage Examples

Basic WIP tasks inventory access demonstrates the primary resource consumption pattern for project task overview. This approach provides comprehensive task management context through structured JSON data with HTTP formatting.

```python
# Access WIP tasks inventory through MCP resource URI for project task overview
# Returns HTTP-formatted JSON with current task, active tasks, completed tasks, and statistics
inventory_content = await mcp_client.read_resource("jesse://wip-tasks")
# Content includes task counts, current task information, and completion metrics
```

Individual task access showcases focused task content retrieval combining definition and progress tracking. This pattern enables detailed task examination with comprehensive metadata and combined content from multiple sources.

```python
# Access specific WIP task content through parameterized resource URI
# Combines WIP_TASK.md and PROGRESS.md with task metadata in single HTTP response
task_content = await mcp_client.read_resource("jesse://wip-task/feature-implementation")
# Returns markdown content with task definition, progress tracking, and Git branch information
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources/workflows.py

*Last Updated: 2025-07-05T12:40:35Z*

#### Functional Intent & Features

This file implements JESSE Framework workflow resource handlers for the MCP server, providing individual JESSE workflow files as HTTP-formatted resources specifically designed for Cline slash command integration within AI-assisted development environments. The module enables MCP clients to access embedded workflow content through standardized resource URIs, transforming each workflow into an accessible Cline slash command for streamlined development operations. Key semantic entities include `get_jesse_workflow()` function decorated with `@server.resource("file://workflows/{workflow_name}")`, `get_embedded_workflow_files()` function for dynamic workflow discovery, `register_workflows_resources()` registration function, utility functions `get_workflow_description()` and `get_workflow_category()` for metadata extraction, `format_http_section()` from `async_http_formatter` module with `XAsyncContentCriticality.CRITICAL` classification, `Context` from `fastmcp` for async progress reporting, `importlib.resources` for embedded content access, workflow categories including `Task Management`, `Knowledge Management`, `Knowledge Capture`, `Amazon Integration`, and `Framework Management`, specific workflow files like `jesse_wip_task_create.md`, `jesse_wip_task_switch.md`, `jesse_capture_our_chat.md`, and `jesse_amazon_pr_faq_coach.md`, and HTTP headers including `Cline-Slash-Command`, `Workflow-Category`, and `Workflow-File` for enhanced Cline integration. The system implements HTTP-formatted resource delivery with `writable=False` parameters ensuring read-only workflow access while maintaining CRITICAL criticality classification for strict AI assistant adherence.

##### Main Components

The file contains four primary functions providing comprehensive workflow resource management and discovery capabilities. The `get_jesse_workflow()` function serves individual workflow resources through FastMCP decorator registration, handling workflow loading from embedded content with HTTP formatting and Cline-specific metadata. The `get_embedded_workflow_files()` function provides dynamic workflow discovery by scanning the embedded workflows directory and returning markdown file listings for resource enumeration. The `register_workflows_resources()` function coordinates resource registration with the FastMCP server instance. Supporting utility functions include `get_workflow_description()` for human-readable workflow descriptions using dictionary mapping with pattern matching fallbacks, and `get_workflow_category()` for workflow classification using prefix-based categorization aligned with JESSE framework functional areas.

###### Architecture & Design

The architecture implements a resource-oriented design pattern with clear separation between workflow discovery, content delivery, and metadata management, following FastMCP server integration patterns with decorator-based resource registration. The design emphasizes HTTP-formatted content delivery through `format_http_section()` with consistent CRITICAL criticality classification and read-only access flags for workflow integrity. Key design patterns include the resource handler pattern with FastMCP decorators for endpoint registration, embedded content access pattern using `importlib.resources` for package-bundled workflows, metadata mapping pattern with dictionary-based descriptions and prefix-based categorization, content formatting pattern with HTTP section wrapping for Cline integration, and graceful error handling pattern with descriptive error messages and proper exception propagation. The system uses composition over inheritance with utility functions for specific workflow operations, centralized metadata management through mapping dictionaries, and standardized HTTP formatting for consistent Cline slash command integration.

####### Implementation Approach

The implementation uses async function patterns with FastMCP Context integration for progress reporting and structured logging throughout workflow processing operations. Workflow discovery employs `importlib.resources` for embedded content access with directory iteration and file extension filtering for markdown workflow identification. Content delivery combines embedded file loading with HTTP formatting using `format_http_section()` with CRITICAL criticality and workflow-specific metadata headers. The approach implements filename normalization with extension handling for both `.md` and extensionless workflow names, metadata extraction through dictionary mapping with pattern-based fallbacks for unknown workflows, and error handling with try-catch blocks and descriptive error messages. Data structures use dictionaries for workflow descriptions and categories with prefix-based pattern matching, while content loading employs UTF-8 text reading with whitespace validation and empty content detection.

######## External Dependencies & Integration Points

**→ Inbound:**
- `importlib.resources` (external library) - embedded content access for workflow file loading from package-bundled content
- `importlib_resources` (external library) - Python < 3.9 compatibility fallback for resource access functionality
- `fastmcp:Context` - async progress reporting and structured logging for workflow processing operations
- `..helpers.async_http_formatter:format_http_section` - HTTP section formatting with content type and criticality classification
- `..helpers.async_http_formatter:XAsyncContentCriticality` - content criticality enumeration for CRITICAL classification
- `..helpers.async_http_formatter:XAsyncHttpPath` - HTTP path handling for resource location specification
- `..main:server` - FastMCP server instance for resource registration with decorator patterns
- `jesse_framework_mcp.embedded_content.workflows/` - embedded workflow directory containing markdown workflow files

**← Outbound:**
- Cline AI assistant - consuming workflow resources as slash commands through `file://workflows/{workflow_name}` URIs
- MCP clients - accessing individual workflow content through standardized resource protocol
- Development environments - using HTTP-formatted workflow content with CRITICAL criticality for strict adherence
- AI coding assistants - consuming workflow metadata through Cline-Slash-Command headers for command integration
- Workflow management systems - using workflow categorization and description metadata for organization

**⚡ System role and ecosystem integration:**
- **System Role**: Workflow resource provider within Jesse Framework MCP Server ecosystem, delivering embedded workflow content as HTTP-formatted resources with CRITICAL criticality for AI assistant integration and Cline slash command functionality
- **Ecosystem Position**: Core resource component serving AI-assisted development workflows with embedded content delivery, integrating with Cline through standardized MCP resource protocol and slash command headers
- **Integration Pattern**: Used by Cline AI assistant through resource URI requests with slash command integration, consumed by MCP clients for workflow access, and coordinated with HTTP formatter helpers for consistent content delivery with read-only access control

######### Edge Cases & Error Handling

The system handles missing embedded workflow files through try-catch blocks with descriptive error messages and proper exception propagation when workflows cannot be accessed from package content. Filename normalization manages both `.md` and extensionless workflow names through conditional extension handling and clean name extraction for slash command compatibility. Empty workflow content is detected through `.strip()` validation with specific error messages for whitespace-only files. Resource discovery handles missing embedded content directories through exception catching with detailed error context. Workflow metadata extraction provides fallback descriptions and categories through pattern matching when exact dictionary matches unavailable. Import compatibility manages Python version differences through try-catch import patterns with `importlib_resources` fallback for older Python versions. Progress reporting uses FastMCP Context with structured logging for debugging workflow processing issues and resource loading failures.

########## Internal Implementation Details

The module uses embedded content access through `importlib.resources.files()` with directory iteration and suffix filtering for `.md` file identification in workflow discovery. Workflow loading employs `resources.open_text()` with UTF-8 encoding and content validation through `.strip()` for empty file detection. Filename processing implements conditional extension handling with `.endswith('.md')` checks and clean name extraction through `.replace('.md', '')` for slash command compatibility. Metadata mapping uses dictionary lookups with exact matching followed by prefix-based pattern matching for workflow descriptions and categories. HTTP formatting includes specific additional headers like `Cline-Slash-Command`, `Workflow-Category`, and `Workflow-File` for enhanced Cline integration metadata. Error handling implements specific exception types with detailed error messages including workflow file names and operation context. Content delivery uses `writable=False` parameter for read-only access control while maintaining CRITICAL criticality classification for strict AI assistant adherence to workflow instructions.

########### Code Usage Examples

Basic workflow resource access demonstrates the primary consumption pattern for Cline slash command integration. This approach provides HTTP-formatted workflow content with CRITICAL criticality for strict AI assistant adherence.

```python
# Access JESSE workflow through MCP resource URI for Cline slash command integration
# Returns HTTP-formatted workflow content with CRITICAL criticality and Cline metadata
workflow_content = await mcp_client.read_resource("file://workflows/jesse_wip_task_create")
# Content includes Cline-Slash-Command header for /jesse_wip_task_create integration
```

Workflow discovery showcases the embedded content enumeration pattern for dynamic resource listing. This pattern enables MCP clients to discover available workflows without hardcoded file lists.

```python
# Discover available workflow files from embedded content for resource enumeration
# Scans embedded workflows directory and returns markdown file listings
workflow_files = await get_embedded_workflow_files()
# Returns list of .md workflow files for MCP resource discovery and Cline integration
```

---
*Generated: 2025-07-05T12:40:35Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/resources*
*Total Files: 8*
*Total Subdirectories: 0*

# End of resources_kb.md