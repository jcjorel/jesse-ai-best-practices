<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/

## Global Summary

#### Functional Intent & Features

This directory provides the core data model foundation for the Jesse Framework MCP Knowledge Bases Hierarchical Indexing System, delivering immutable configuration management, runtime context tracking, and comprehensive processing state coordination throughout hierarchical indexing workflows. The models package enables type-safe data structures with validation, thread-safe operations through frozen dataclasses, and comprehensive serialization capabilities supporting both configuration persistence and runtime monitoring. Key semantic entities include `IndexingConfig` frozen dataclass for immutable system configuration, `IndexingMode` enum for processing strategy selection, `DirectoryContext` and `FileContext` frozen dataclasses for hierarchical processing state, `ProcessingStatus` and `ChangeType` enums for workflow coordination, `ProcessingStats` mutable dataclass for real-time metrics collection, `IndexingStatus` for overall operation monitoring, `ChangeInfo` for incremental processing coordination, `Claude4SonnetModel.CLAUDE_4_SONNET` LLM integration, `get_project_root()` function for automatic configuration, `__post_init__()` validation methods, `to_dict()` and `from_dict()` serialization methods, `should_process_file()` and `should_process_directory()` filtering methods, and comprehensive parameter validation with descriptive error messages. The system supports zero-configuration startup with intelligent defaults while enabling full customization through JSON configuration files and configuration manager integration.

##### Main Components

The directory contains three primary Python modules organized into configuration and runtime context categories. The `indexing_config.py` module provides `IndexingConfig` frozen dataclass with 23 configuration parameters and `IndexingMode` string-based enum with three processing strategies (`FULL`, `INCREMENTAL`, `SELECTIVE`). The `knowledge_context.py` module delivers five data model classes including `FileContext` and `DirectoryContext` frozen dataclasses for processing state tracking, `ProcessingStats` and `IndexingStatus` mutable dataclasses for metrics collection, and `ChangeInfo` frozen dataclass for incremental processing coordination, along with `ProcessingStatus` and `ChangeType` enumerations for workflow management. The `__init__.py` module serves as the centralized package initialization providing unified access to all nine exported components through explicit import aggregation and `__all__` declaration for public API control.

###### Architecture & Design

The architecture implements a clear separation between immutable configuration data and mutable runtime state through distinct module organization and dataclass patterns. The design utilizes frozen dataclasses with `@dataclass(frozen=True)` for thread-safe configuration and context structures, while employing mutable dataclasses for real-time statistics tracking and operation monitoring. Key architectural patterns include the immutable configuration pattern with comprehensive validation at initialization, bottom-up hierarchical context assembly without parent-to-child dependencies, computed property patterns for derived statistics calculation, and centralized export aggregation through package initialization. The system integrates with existing Jesse Framework components through `Claude4SonnetModel` LLM configuration consistency and `get_project_root()` automatic path resolution, while supporting external system integration through comprehensive serialization capabilities and dictionary conversion methods.

####### Implementation Approach

The implementation strategy centers on frozen dataclass structures with field factories for mutable default values, ensuring thread safety while preventing shared reference issues between instances. Configuration validation employs comprehensive bounds checking in `__post_init__()` methods with descriptive error messages, including validation of file sizes, batch parameters, concurrency limits, and LLM settings. Context tracking uses computed properties with generator expressions and list comprehensions for memory-efficient statistics calculation across hierarchical structures. Serialization handling converts complex types including sets to lists, enums to string values, and Path objects to string representation for JSON compatibility. The system implements safe division handling in percentage calculations, recursive aggregation for directory-level metrics, and string-based enums for serialization compatibility and debugging clarity.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.llm.strands_agent_driver.models:Claude4SonnetModel` - LLM model configuration providing `CLAUDE_4_SONNET` constant for consistency
- `jesse_framework_mcp.helpers.path_utils:get_project_root` - project root detection for automatic knowledge directory configuration
- `dataclasses` (external library) - frozen and mutable dataclass decorators for structure definition and immutability
- `pathlib.Path` (external library) - cross-platform filesystem operations and path validation
- `datetime` (external library) - timestamp handling, comparison operations, and ISO format serialization
- `typing` (external library) - type annotations for Set, Optional, Dict, List, Any type hints
- `enum.Enum` (external library) - enumeration base classes for ProcessingStatus, ChangeType, and IndexingMode

**← Outbound:**
- `../indexing/hierarchical_indexer.py:HierarchicalIndexer` - consumes configuration and context models for processing coordination
- `../indexing/change_detector.py:ChangeDetector` - uses ChangeInfo and ChangeType for incremental processing workflows
- `../indexing/knowledge_builder.py:KnowledgeBuilder` - updates FileContext and DirectoryContext during content generation
- `../indexing/config_manager.py:IndexingConfigManager` - configuration manager consuming IndexingConfig for validation and loading
- `../../server.py:JesseFrameworkMCPServer` - uses IndexingStatus and ProcessingStats for operation monitoring and progress reporting
- JSON configuration files - serialized through to_dict() methods for user customization and persistence
- External monitoring systems - consume serialized statistics and status information for operational visibility

**⚡ System role and ecosystem integration:**
- **System Role**: Core data model foundation serving as the primary data contract for all Jesse Framework MCP knowledge base indexing operations, providing type-safe structures for configuration management and runtime state tracking
- **Ecosystem Position**: Central infrastructure component that all indexing workflows depend on for validated configuration parameters and structured context tracking, bridging between user-customizable configurations and runtime processing requirements
- **Integration Pattern**: Used by all indexing components during initialization and processing for parameter access and state management, consumed by MCP server for operation coordination and monitoring, and integrated with external systems through comprehensive serialization capabilities

######### Edge Cases & Error Handling

The system handles missing project root detection gracefully by catching exceptions in `__post_init__()` and maintaining `knowledge_output_directory` as `None` for backward compatibility. File access errors in filtering methods are managed through try-catch blocks returning `False` for inaccessible files to prevent processing failures. Parameter validation provides comprehensive bounds checking with descriptive error messages including positive value requirements for `max_file_size`, constraint validation for `chunk_overlap` relative to `chunk_size`, temperature range validation between 0.0 and 1.0, and non-negative requirements for all count parameters. Division by zero scenarios in percentage calculations return 0.0 when total counts are zero, preventing calculation errors in empty collections. Missing timestamp information is handled gracefully with None returns from duration calculation properties, supporting incomplete processing scenarios. Configuration loading raises `ValueError` when project root cannot be determined and no `knowledge_dir` is provided, ensuring proper error propagation for invalid initialization scenarios.

########## Internal Implementation Details

The frozen dataclass implementation uses `object.__setattr__()` in `__post_init__()` methods to modify immutable fields during initialization for default value assignment, specifically setting `knowledge_output_directory` to `project_root / '.knowledge/'` when project root is available. Default factory functions for sets use lambda expressions ensuring each instance receives independent collections, with `excluded_extensions` defaulting to 11 common file extensions and `excluded_directories` defaulting to 7 common directory names. Computed properties implement generator expressions and sum aggregation for memory-efficient calculation across large hierarchical structures, with recursive aggregation for directory-level metrics. The `to_dict()` methods handle complex type conversion including sets to lists, enums to string values, Path objects to string representation, and None value preservation for optional parameters. The `from_dict()` methods implement reverse conversion with defensive copying, proper set reconstruction from lists, enum conversion from string values, and Path object creation from string paths. String-based enums inherit from both `str` and `Enum` enabling direct string comparison and JSON serialization compatibility while maintaining enumeration benefits.

########### Usage Examples

**Configuration creation with validation and filtering demonstrates the comprehensive parameter management and file processing decision patterns:**

This example shows creating an IndexingConfig with custom parameters and using its filtering methods for processing decisions. The frozen dataclass ensures immutability while providing comprehensive validation and filtering capabilities.

```python
from jesse_framework_mcp.knowledge_bases.models import IndexingConfig, IndexingMode
from pathlib import Path

# Create immutable configuration with validation
config = IndexingConfig(
    max_file_size=1024 * 1024,  # 1MB limit
    batch_size=5,
    indexing_mode=IndexingMode.INCREMENTAL,
    knowledge_output_directory=Path("/custom/knowledge/path"),
    debug_mode=True
)

# Use configuration for processing decisions
if config.should_process_file(Path("src/main.py")):
    print("Processing file based on configuration rules")
```

**Hierarchical context tracking with statistics aggregation showcases the bottom-up processing pattern and comprehensive metrics collection:**

This pattern demonstrates building hierarchical directory contexts with child aggregation and real-time statistics tracking. The immutable context structures enable thread-safe operations during concurrent processing.

```python
from jesse_framework_mcp.knowledge_bases.models import (
    DirectoryContext, FileContext, ProcessingStatus, ProcessingStats
)
from datetime import datetime

# Create file contexts with processing state
file_context = FileContext(
    file_path=Path("src/component.py"),
    file_size=1024,
    last_modified=datetime.now(),
    processing_status=ProcessingStatus.COMPLETED,
    knowledge_content="Generated knowledge content"
)

# Build hierarchical directory context
directory_context = DirectoryContext(
    directory_path=Path("src/"),
    file_contexts=[file_context],
    processing_status=ProcessingStatus.PROCESSING
)

# Track comprehensive statistics
stats = ProcessingStats()
stats.total_files_discovered = 150
completion_rate = stats.files_completion_rate
```

**Configuration serialization and change tracking demonstrates persistence capabilities and incremental processing coordination:**

This example shows configuration serialization for persistence and change tracking for incremental processing workflows. The serialization maintains all configuration state while change tracking enables efficient incremental updates.

```python
from jesse_framework_mcp.knowledge_bases.models import ChangeInfo, ChangeType

# Serialize configuration for persistence
config_dict = config.to_dict()
restored_config = IndexingConfig.from_dict(config_dict)

# Track changes for incremental processing
change = ChangeInfo(
    path=Path("src/updated_file.py"),
    change_type=ChangeType.MODIFIED,
    old_path=Path("src/old_file.py"),
    timestamp=datetime.now()
)

# Load handler-specific configurations
project_config = IndexingConfig.load_for_handler("project-base")
```

## Subdirectory Knowledge Integration

*No subdirectories processed*

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/__init__.py

*Last Updated: 2025-07-05T14:34:31Z*

#### Functional Intent & Features

This file serves as the centralized package initialization module for the Knowledge Bases Hierarchical Indexing System data models, providing unified access to all configuration classes, runtime context structures, and processing state models used throughout the hierarchical indexing workflow and FastMCP integration. The module enables clean dependency management by exporting core data structures including configuration models, context tracking classes, and processing state enumerations through a standardized interface. Key semantic entities include `IndexingConfig` for system configuration, `IndexingMode` enumeration for processing modes, `DirectoryContext` for hierarchical directory processing state, `FileContext` for individual file processing tracking, `ChangeInfo` for incremental processing coordination, `IndexingStatus` for overall operation monitoring, `ProcessingStats` for comprehensive metrics collection, `ProcessingStatus` enumeration for workflow state management, `ChangeType` enumeration for change detection categories, and the `__all__` export list defining the public API surface. The system implements type-safe data structures with comprehensive validation, immutable configurations for thread safety, and clear separation between configuration and runtime context models supporting async operations throughout the indexing pipeline.

##### Main Components

The package exports nine core components through the `__all__` list, organized into two primary categories: configuration models and runtime context models. Configuration components include `IndexingConfig` class for system configuration management and `IndexingMode` enumeration for processing mode selection. Runtime context components encompass `DirectoryContext` for hierarchical directory processing state, `FileContext` for individual file processing tracking, `ChangeInfo` for incremental processing coordination, `IndexingStatus` for overall operation status monitoring, `ProcessingStats` for comprehensive metrics collection, `ProcessingStatus` enumeration for workflow state management, and `ChangeType` enumeration for change detection categorization. The module imports these components from two sibling modules: `.indexing_config` providing configuration data models and `.knowledge_context` supplying runtime context data models, establishing a clear architectural separation between configuration and operational state management.

###### Architecture & Design

The architecture implements a centralized export pattern with clear separation between configuration and runtime context models, enabling clean dependency management and preventing circular import issues. The design follows the package initialization pattern where all public components are imported from specialized modules and re-exported through a unified interface, providing consumers with a single import point for all data model requirements. The system uses explicit `__all__` declaration to control the public API surface and ensure only intended components are available through wildcard imports. The architectural separation between `.indexing_config` and `.knowledge_context` modules reflects the distinction between static configuration data and dynamic runtime state, supporting different lifecycle management patterns and serialization requirements throughout the indexing workflow.

####### Implementation Approach

The implementation uses Python's standard package initialization mechanism with explicit imports from sibling modules using relative import syntax (`.module_name`). The approach employs comprehensive export listing through `__all__` to define the public API surface and control component visibility. Import organization follows logical grouping with configuration models imported first from `.indexing_config`, followed by runtime context models from `.knowledge_context`, maintaining clear separation between static and dynamic data structures. The module maintains no internal state or business logic, serving purely as an aggregation and export point for data model components, ensuring lightweight initialization and minimal overhead during package import operations.

######## External Dependencies & Integration Points

**→ Inbound:**
- `.indexing_config:IndexingConfig` - system configuration class with validation and processing parameters
- `.indexing_config:IndexingMode` - enumeration defining processing modes for indexing operations
- `.knowledge_context:DirectoryContext` - hierarchical directory processing state and context management
- `.knowledge_context:FileContext` - individual file processing state tracking and metadata
- `.knowledge_context:ChangeInfo` - incremental processing coordination and change detection information
- `.knowledge_context:IndexingStatus` - overall operation status monitoring and progress tracking
- `.knowledge_context:ProcessingStats` - comprehensive metrics collection and performance analysis
- `.knowledge_context:ProcessingStatus` - workflow state management enumeration for processing coordination
- `.knowledge_context:ChangeType` - change detection categorization enumeration for incremental processing

**← Outbound:**
- `jesse_framework_mcp/knowledge_bases/indexing/hierarchical_indexer.py:HierarchicalIndexer` - consumes data models for processing coordination
- `jesse_framework_mcp/knowledge_bases/indexing/change_detector.py:ChangeDetector` - uses context models for change detection workflows
- `jesse_framework_mcp/knowledge_bases/indexing/knowledge_builder.py:KnowledgeBuilder` - imports models for content generation operations
- `jesse_framework_mcp/server.py:JesseFrameworkMCPServer` - uses models for MCP server operation and status reporting
- External applications - import models through Jesse Framework MCP for knowledge base operations

**⚡ System role and ecosystem integration:**
- **System Role**: Central data model registry for the Jesse Framework MCP knowledge base system, providing unified access to all configuration and runtime context structures
- **Ecosystem Position**: Core infrastructure component serving as the primary data contract interface between all indexing components and external consumers
- **Integration Pattern**: Used by all indexing components through direct imports, consumed by MCP server for operation coordination, and integrated with external applications requiring knowledge base data model access

######### Edge Cases & Error Handling

Import failures from either `.indexing_config` or `.knowledge_context` modules result in package initialization failure, preventing the entire models package from becoming available to consumers. Missing or corrupted sibling modules cause import errors that propagate to consuming applications, requiring proper error handling at the application level. Circular dependency scenarios between the exported models and consuming components are prevented through the package structure but could emerge from future architectural changes. Version mismatches between the initialization module and sibling modules could lead to API inconsistencies or missing component exports. The package provides no error handling mechanisms itself, relying on Python's import system to surface module loading issues and individual model classes to handle their specific validation and error scenarios.

########## Internal Implementation Details

The package uses Python's standard relative import mechanism with dot notation (`.module_name`) to reference sibling modules within the same package directory. Import statements are organized logically with configuration models imported first, followed by runtime context models, maintaining clear architectural separation. The `__all__` list uses explicit string literals for each exported component name, ensuring precise control over the public API surface and preventing accidental exposure of internal implementation details. Module-level imports are performed at package initialization time, making all components immediately available upon successful import without lazy loading or dynamic import mechanisms. The package maintains no internal state, configuration, or business logic, serving purely as an export aggregation point with minimal overhead and maximum compatibility across different Python environments.

########### Code Usage Examples

Standard package import demonstrates the unified access pattern for all knowledge base data models. This approach provides clean dependency management and consistent API access across the indexing system.

```python
# Import all data models through unified package interface
from jesse_framework_mcp.knowledge_bases.models import (
    IndexingConfig,
    IndexingMode,
    DirectoryContext,
    FileContext,
    ProcessingStatus,
    IndexingStatus
)

# Initialize configuration with processing parameters
config = IndexingConfig(
    knowledge_output_directory=Path("./knowledge"),
    indexing_mode=IndexingMode.INCREMENTAL
)
```

Selective component import enables targeted usage for specific functionality requirements. This pattern supports modular development and reduces import overhead for specialized use cases.

```python
# Import only required components for specific operations
from jesse_framework_mcp.knowledge_bases.models import ProcessingStats, ChangeInfo, ChangeType

# Create processing statistics tracker
stats = ProcessingStats()
stats.total_files_discovered = 100

# Track change information for incremental processing
change = ChangeInfo(
    path=Path("src/component.py"),
    change_type=ChangeType.MODIFIED
)
```

Package-level wildcard import brings in all components defined in `__all__` for comprehensive model access. This approach is suitable for development environments and comprehensive testing scenarios.

```python
# Wildcard import provides access to all exported models
from jesse_framework_mcp.knowledge_bases.models import *

# All nine components are now available in local namespace
directory_context = DirectoryContext(directory_path=Path("src/"))
file_context = FileContext(file_path=Path("src/main.py"), file_size=1024, last_modified=datetime.now())
indexing_status = IndexingStatus(overall_status=ProcessingStatus.PROCESSING)
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/indexing_config.py

*Last Updated: 2025-07-05T14:34:31Z*

#### Functional Intent & Features

This configuration data model provides immutable, type-safe configuration management for the Jesse Framework MCP knowledge base hierarchical indexing system, controlling all aspects of file processing, LLM integration, and special handling requirements. The module defines comprehensive configuration parameters through the `IndexingConfig` frozen dataclass with validation at initialization, supporting three distinct indexing modes (`FULL`, `INCREMENTAL`, `SELECTIVE`) via the `IndexingMode` enum. Key semantic entities include `IndexingConfig` frozen dataclass for immutable configuration, `IndexingMode` string-based enum for processing strategies, `Claude4SonnetModel.CLAUDE_4_SONNET` LLM model integration, `get_project_root()` function for automatic knowledge directory detection, `should_process_file()` and `should_process_directory()` filtering methods, `to_dict()` and `from_dict()` serialization methods, `load_for_handler()` class method for configuration manager integration, `__post_init__()` validation method, `dataclasses.dataclass` with `frozen=True` for immutability, `pathlib.Path` for file system operations, and comprehensive parameter validation with descriptive error messages. The system enables zero-configuration startup by defaulting `knowledge_output_directory` to `{PROJECT_ROOT}/.knowledge/` while supporting full customization through JSON configuration files and configuration manager integration.

##### Main Components

The module contains two primary classes: `IndexingMode` string-based enum defining three processing strategies (`FULL` for complete re-indexing, `INCREMENTAL` for changed files only, `SELECTIVE` for specific paths), and `IndexingConfig` frozen dataclass with 23 configuration parameters organized into categories including file processing configuration (`max_file_size`, `chunk_size`, `chunk_overlap`), batch processing configuration (`batch_size`, `max_concurrent_operations`), content filtering configuration (`excluded_extensions`, `excluded_directories`, `project_base_exclusions`), LLM configuration (`llm_model`, `temperature`, `max_tokens`), change detection configuration (`indexing_mode`, `timestamp_tolerance_seconds`), special handling flags (`enable_git_clone_indexing`, `enable_project_base_indexing`, `respect_gitignore`), performance configuration (`enable_progress_reporting`, `progress_update_interval`), error handling configuration (`max_retries`, `retry_delay_seconds`, `continue_on_file_errors`), knowledge output configuration (`knowledge_output_directory`), and debug configuration (`debug_mode`, `debug_output_directory`, `enable_llm_replay`). Supporting methods include `__post_init__()` for validation, `should_process_file()` and `should_process_directory()` for filtering, `to_dict()` and `from_dict()` for serialization, and `load_for_handler()` for configuration manager integration.

###### Architecture & Design

The architecture implements an immutable configuration pattern using `@dataclass(frozen=True)` to prevent runtime configuration modifications, with comprehensive validation occurring once at initialization through `__post_init__()` for performance optimization. The design separates concerns through distinct configuration categories with clear parameter grouping, while integrating with the existing `strands_agent_driver` Claude 4 Sonnet configuration for LLM consistency. Configuration management follows a hierarchical exclusion system with base exclusions applied universally and handler-specific exclusions (`project_base_exclusions`) applied conditionally. The system implements automatic default resolution for `knowledge_output_directory` using project root detection, falling back gracefully when project root cannot be determined. Serialization support enables configuration persistence and debugging through dictionary conversion with proper handling of complex types like sets and enums.

####### Implementation Approach

The implementation uses frozen dataclass with field factories for mutable default values like sets, ensuring each instance gets independent collections while maintaining immutability after initialization. Parameter validation employs comprehensive bounds checking in `__post_init__()` with descriptive error messages for debugging, including validation of file sizes, batch parameters, concurrency limits, LLM settings, and performance parameters. File and directory filtering uses set-based lookups for performance optimization in `should_process_file()` and `should_process_directory()` methods. Serialization handling converts sets to lists for JSON compatibility while preserving semantics, with enum values converted to string representation for safe serialization. The `from_dict()` class method implements reverse conversion with proper type handling for sets, enums, and Path objects. Configuration loading integrates with `IndexingConfigManager` through `load_for_handler()` class method, supporting auto-generation of missing configurations from centralized defaults.

######## External Dependencies & Integration Points

**→ Inbound:**
- `jesse_framework_mcp.llm.strands_agent_driver.models:Claude4SonnetModel` - LLM model configuration providing `CLAUDE_4_SONNET` constant
- `jesse_framework_mcp.helpers.path_utils:get_project_root` - project root detection for automatic knowledge directory configuration
- `dataclasses` (external library) - dataclass decorator and field factory for immutable configuration structure
- `pathlib.Path` (external library) - cross-platform path operations and validation
- `typing` (external library) - type annotations for `Set`, `Optional`, `Dict`, `Any` type hints
- `enum.Enum` (external library) - enumeration base class for `IndexingMode` string enum

**← Outbound:**
- `../indexing/config_manager.py:IndexingConfigManager` - configuration manager consuming `IndexingConfig` instances for validation and loading
- `../indexing/hierarchical_indexer.py` - hierarchical indexer consuming configuration for processing parameters and filtering rules
- JSON configuration files serialized through `to_dict()` method for user customization and persistence
- Knowledge base processing components consuming file and directory filtering methods

**⚡ System role and ecosystem integration:**
- **System Role**: Core configuration foundation defining all operational parameters for the Jesse Framework knowledge base indexing system, serving as the single source of truth for processing constraints and LLM integration settings
- **Ecosystem Position**: Central infrastructure component that all indexing operations depend on for validated configuration parameters, bridging between user-customizable JSON configurations and runtime processing requirements
- **Integration Pattern**: Used by indexing components during initialization for parameter access, configuration managers for validation and auto-generation, and serialization systems for configuration persistence and debugging workflows

######### Edge Cases & Error Handling

The system handles missing project root detection gracefully in `__post_init__()` by catching exceptions and maintaining `knowledge_output_directory` as `None` for backward compatibility. File access errors in `should_process_file()` are handled through try-catch blocks, returning `False` for inaccessible files to prevent processing failures. Parameter validation provides comprehensive bounds checking with descriptive error messages: `max_file_size` must be positive, `chunk_overlap` must be less than `chunk_size`, `temperature` must be between 0.0 and 1.0, and all count parameters must be non-negative. Configuration loading through `load_for_handler()` raises `ValueError` when project root cannot be determined and no `knowledge_dir` is provided. Serialization edge cases include handling `None` values for optional parameters and proper conversion of complex types like sets and Path objects. The frozen dataclass prevents accidental configuration modification after initialization, with `object.__setattr__()` used only during `__post_init__()` for default value assignment.

########## Internal Implementation Details

The frozen dataclass uses `object.__setattr__()` in `__post_init__()` to modify the immutable `knowledge_output_directory` field when setting the default value to `project_root / '.knowledge/'`. Default factory functions for sets use lambda expressions to ensure each instance gets independent collections: `excluded_extensions` defaults to 11 common file extensions, `excluded_directories` defaults to 7 common directory names. Parameter validation occurs in specific order: file processing parameters first, then batch processing, LLM parameters, and performance parameters, with early failure preventing invalid configuration creation. The `to_dict()` method handles complex type conversion: sets converted to lists, enums converted to string values, Path objects converted to string representation, with `None` values preserved for optional parameters. The `from_dict()` method implements reverse conversion with defensive copying to avoid modifying input dictionaries, proper set reconstruction from lists, enum conversion from string values, and Path object creation from string paths. Configuration manager integration uses dynamic imports to avoid circular dependencies.

########### Code Usage Examples

**Basic configuration creation with validation:**

This example demonstrates creating an IndexingConfig instance with custom parameters and automatic validation. The frozen dataclass ensures immutability while providing comprehensive parameter validation at initialization.

```python
from jesse_framework_mcp.knowledge_bases.models.indexing_config import IndexingConfig, IndexingMode
from pathlib import Path

# Create configuration with custom parameters
config = IndexingConfig(
    max_file_size=1024 * 1024,  # 1MB limit
    batch_size=5,
    indexing_mode=IndexingMode.INCREMENTAL,
    knowledge_output_directory=Path("/custom/knowledge/path"),
    debug_mode=True
)

# Configuration is immutable after creation
print(f"Batch size: {config.batch_size}")
print(f"Knowledge directory: {config.knowledge_output_directory}")
```

**File and directory filtering with configuration rules:**

This pattern shows how to use the configuration's filtering methods for file and directory processing decisions. The methods provide centralized filtering logic based on configuration parameters.

```python
from pathlib import Path

# Use configuration for file filtering decisions
test_file = Path("src/main.py")
test_dir = Path("node_modules/")

if config.should_process_file(test_file):
    print(f"Processing file: {test_file}")

if config.should_process_directory(test_dir):
    print(f"Processing directory: {test_dir}")
else:
    print(f"Skipping excluded directory: {test_dir}")
```

**Configuration serialization and loading from handler type:**

This example demonstrates configuration serialization for persistence and loading configurations for specific handler types. The serialization maintains all configuration state while the class method provides convenient handler-specific loading.

```python
# Serialize configuration to dictionary for persistence
config_dict = config.to_dict()
print(f"Serialized config keys: {list(config_dict.keys())}")

# Load configuration for specific handler type
project_config = IndexingConfig.load_for_handler("project-base")
git_config = IndexingConfig.load_for_handler("git-clones")

# Create configuration from dictionary (e.g., from JSON file)
restored_config = IndexingConfig.from_dict(config_dict)
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/knowledge_context.py

*Last Updated: 2025-07-05T14:34:31Z*

#### Functional Intent & Features

This file defines runtime context data models for the Jesse Framework MCP Knowledge Bases Hierarchical Indexing System, providing immutable context structures for directory processing, file analysis, change tracking, and indexing operation status throughout hierarchical processing workflows. The module enables comprehensive tracking of indexing operations through structured data models supporting thread-safe operations, serialization, and async processing patterns. Key semantic entities include `ProcessingStatus` enum with states (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`, `SKIPPED`), `ChangeType` enum for change detection (`NEW`, `MODIFIED`, `DELETED`, `MOVED`), `FileContext` frozen dataclass for individual file processing state, `DirectoryContext` frozen dataclass for hierarchical directory processing, `ChangeInfo` frozen dataclass for incremental processing coordination, `ProcessingStats` mutable dataclass for comprehensive metrics tracking, `IndexingStatus` mutable dataclass for overall operation status, `dataclasses` module for structure definition, `datetime` for timestamp handling, `pathlib.Path` for filesystem operations, and `typing` annotations for type safety. The system implements bottom-up hierarchical context assembly without parent-to-child dependencies while maintaining accurate processing statistics and progress reporting capabilities.

##### Main Components

The file contains five primary data model classes and two enumeration types providing comprehensive context tracking capabilities. The `ProcessingStatus` enum defines processing states with five values for workflow coordination, while `ChangeType` enum provides four change categories for incremental processing optimization. The `FileContext` frozen dataclass tracks individual file processing with properties including `file_path`, `file_size`, `last_modified`, `processing_status`, `knowledge_content`, error tracking, and timing information with computed properties `processing_duration` and `is_completed`. The `DirectoryContext` frozen dataclass manages hierarchical directory processing with `directory_path`, `file_contexts` list, `subdirectory_contexts` list, processing state, and computed properties `total_files`, `completed_files`, `completion_percentage`, and `is_ready_for_summary`. The `ChangeInfo` frozen dataclass captures change detection information with path tracking, timestamps, and `is_content_change` property. The `ProcessingStats` mutable dataclass provides comprehensive metrics tracking with file statistics, directory statistics, content processing metrics, performance timing, and error collection. The `IndexingStatus` mutable dataclass coordinates overall operation status with progress tracking and serialization capabilities.

###### Architecture & Design

The architecture implements immutable context structures using frozen dataclasses for thread-safe operations during concurrent processing, with clear separation between processing state tracking and configuration management. The design follows bottom-up hierarchical context assembly patterns where child contexts are processed independently before parent directory processing, eliminating parent-to-child dependencies and enabling efficient concurrent operations. Key design patterns include the frozen dataclass pattern for immutable context preservation, computed property patterns for derived statistics calculation, mutable statistics tracking for real-time updates, and comprehensive serialization support through `to_dict()` methods. The system uses string-based enums for serialization compatibility and debugging clarity, with status transitions supporting both successful and failed processing scenarios. Error handling is integrated throughout with optional error message fields and comprehensive error tracking in statistics objects.

####### Implementation Approach

The implementation uses frozen dataclasses with `@dataclass(frozen=True)` decorator for immutable context structures ensuring thread safety during concurrent processing operations. Computed properties leverage list comprehensions and generator expressions for efficient statistics calculation across hierarchical structures, with recursive aggregation for directory-level metrics. The system implements safe division handling in percentage calculations returning 0.0 for empty collections to prevent division by zero errors. Change detection uses timestamp-based comparison with `datetime` objects and optional path tracking for move operations. Statistics tracking employs mutable dataclasses with field factories for list initialization and real-time metric updates throughout processing workflows. Serialization support uses dictionary conversion with ISO timestamp formatting and comprehensive field inclusion for external system integration.

######## External Dependencies & Integration Points

**→ Inbound:**
- `dataclasses` (external library) - frozen and mutable dataclass decorators for structure definition and immutability
- `datetime` (external library) - timestamp handling, comparison operations, and ISO format serialization
- `pathlib` (external library) - Path objects for cross-platform filesystem operations and validation
- `typing` (external library) - type annotations including Dict, List, Optional, Set, Any for type safety
- `enum` (external library) - Enum base class for ProcessingStatus and ChangeType enumeration definitions

**← Outbound:**
- `jesse_framework_mcp/knowledge_bases/indexing/hierarchical_indexer.py:HierarchicalIndexer` - consumes context models for processing coordination
- `jesse_framework_mcp/knowledge_bases/indexing/change_detector.py:ChangeDetector` - uses ChangeInfo and ChangeType for incremental processing
- `jesse_framework_mcp/knowledge_bases/indexing/knowledge_builder.py:KnowledgeBuilder` - updates FileContext and DirectoryContext during processing
- `jesse_framework_mcp/server.py:JesseFrameworkMCPServer` - uses IndexingStatus for operation monitoring and progress reporting
- External monitoring systems - consume serialized statistics and status information through to_dict() methods

**⚡ System role and ecosystem integration:**
- **System Role**: Core data model foundation for the Jesse Framework MCP hierarchical indexing system, providing structured context tracking and statistics throughout all processing operations
- **Ecosystem Position**: Central infrastructure component supporting all indexing workflows, serving as the primary data contract between processing components and external monitoring systems
- **Integration Pattern**: Used by all indexing components for state management and progress tracking, consumed by MCP server for operation monitoring, and integrated with external systems through comprehensive serialization capabilities

######### Edge Cases & Error Handling

The system handles division by zero scenarios in percentage calculations by returning 0.0 when total counts are zero, preventing calculation errors in empty directory or file collection scenarios. Missing timestamp information is handled gracefully with None returns from duration calculation properties, supporting incomplete processing scenarios and timing failures. Error message tracking uses optional string fields allowing processing to continue without error information while preserving failure details when available. Completion status checking combines multiple criteria including both status enumeration and content validation, ensuring robust completion detection across different processing scenarios. Recursive statistics calculation handles empty subdirectory collections and missing child contexts through safe aggregation patterns. Serialization handles optional datetime fields with None checking and ISO format conversion, preventing serialization failures when timing information is incomplete.

########## Internal Implementation Details

The frozen dataclass implementation uses `@dataclass(frozen=True)` decorator creating immutable objects with hash support for set operations and dictionary keys. Computed properties use generator expressions and sum aggregation for memory-efficient calculation across large directory hierarchies. The `field(default_factory=list)` pattern initializes mutable collections preventing shared reference issues between dataclass instances. String-based enums inherit from both `str` and `Enum` enabling direct string comparison and JSON serialization compatibility. Error tracking uses list append operations in `add_error()` method maintaining chronological error order for debugging analysis. Statistics calculation properties implement safe division with zero checking and appropriate default values for edge cases. Serialization methods use dictionary comprehension and conditional formatting for optional fields, ensuring complete data preservation while handling None values appropriately.

########### Code Usage Examples

Basic file context creation and status tracking demonstrates the fundamental pattern for individual file processing state management. This approach provides comprehensive tracking throughout the processing lifecycle with immutable context preservation.

```python
# Create and track file processing context with comprehensive state management
from datetime import datetime
from pathlib import Path

file_context = FileContext(
    file_path=Path("src/components/button.py"),
    file_size=1024,
    last_modified=datetime.now(),
    processing_status=ProcessingStatus.PENDING
)

# Check processing completion with content validation
if file_context.is_completed:
    print(f"File processed: {file_context.processing_duration}s")
```

Directory context hierarchical assembly showcases the bottom-up processing pattern with recursive statistics calculation. This pattern enables comprehensive progress tracking across directory hierarchies without parent-to-child dependencies.

```python
# Build hierarchical directory context with child aggregation and progress tracking
directory_context = DirectoryContext(
    directory_path=Path("src/components/"),
    file_contexts=[file_context1, file_context2],
    subdirectory_contexts=[subdir_context1, subdir_context2],
    processing_status=ProcessingStatus.PROCESSING
)

# Calculate hierarchical completion metrics
total_files = directory_context.total_files
completion_rate = directory_context.completion_percentage
is_ready = directory_context.is_ready_for_summary
```

Comprehensive statistics tracking and serialization demonstrates real-time metrics collection with external system integration. This approach provides detailed performance analysis and monitoring capabilities throughout indexing operations.

```python
# Track processing statistics with comprehensive metrics and error handling
stats = ProcessingStats()
stats.processing_start_time = datetime.now()
stats.total_files_discovered = 150
stats.files_completed = 120
stats.files_failed = 5

# Add error information and calculate performance metrics
stats.add_error("Failed to process corrupted file: example.py")
completion_rate = stats.files_completion_rate
error_rate = stats.error_rate

# Serialize for external monitoring systems
stats_dict = stats.to_dict()
```

---
*Generated: 2025-07-05T14:34:31Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models*
*Total Files: 3*
*Total Subdirectories: 0*

# End of models_kb.md