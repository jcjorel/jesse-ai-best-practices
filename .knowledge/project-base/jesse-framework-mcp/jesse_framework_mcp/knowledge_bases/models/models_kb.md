<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/

## Global Summary

#### Functional Intent & Features

The `models/` directory serves as the centralized data model foundation for the Jesse Framework MCP's knowledge base hierarchical indexing system, providing comprehensive type-safe data structures for configuration management, runtime context tracking, and processing state coordination throughout indexing workflows. This directory enables immutable configuration management through frozen dataclasses, thread-safe runtime context tracking for concurrent operations, and comprehensive statistics collection for monitoring and debugging indexing operations. Key semantic entities include the `IndexingConfig` class with hierarchical configuration groups (`FileProcessingConfig`, `ContentFilteringConfig`, `LLMConfig`, `ChangeDetectionConfig`, `ErrorHandlingConfig`, `OutputConfig`, `DebugConfig`), runtime context models (`DirectoryContext`, `FileContext`, `ChangeInfo`, `IndexingStatus`, `ProcessingStats`), processing state enumerations (`ProcessingStatus`, `ChangeType`, `IndexingMode`), integration with `Claude4SonnetModel.CLAUDE_4_SONNET` for LLM configuration, serialization methods (`to_dict()`, `from_dict()`) for persistence and configuration manager integration, filtering utilities (`should_process_file()`, `should_process_directory()`), and automatic project root integration through `get_project_root()` for default knowledge directory setting to `{PROJECT_ROOT}/.knowledge/`. The system implements comprehensive validation at initialization, backward compatibility through property accessors, and unified package exports through `__init__.py` for clean dependency management across the indexing ecosystem.

##### Main Components

The directory contains three core Python modules providing distinct but complementary functionality for the indexing system. The `indexing_config.py` module defines configuration data models including the primary `IndexingConfig` frozen dataclass with seven hierarchical configuration groups, six specialized configuration dataclasses for different parameter domains, and the `IndexingMode` enum with processing strategies (`FULL`, `FULL_KB_REBUILD`, `INCREMENTAL`). The `knowledge_context.py` module provides runtime context data models including `DirectoryContext` and `FileContext` frozen dataclasses for hierarchical processing state, `ChangeInfo` for incremental processing coordination, `ProcessingStats` and `IndexingStatus` mutable dataclasses for metrics and monitoring, and `ProcessingStatus` and `ChangeType` enumerations for workflow coordination. The `__init__.py` package initialization module serves as the centralized export point, importing and re-exporting nine core components from the sibling modules to provide unified access to all data model classes and enumerations through a standardized interface.

###### Architecture & Design

The architecture implements a clear separation between static configuration data and dynamic runtime state through distinct modules, enabling different lifecycle management patterns and serialization requirements. The design follows frozen dataclass patterns for immutable configuration and context structures ensuring thread safety during concurrent processing, combined with mutable dataclasses for real-time statistics tracking and monitoring. The system uses hierarchical composition patterns where the main `IndexingConfig` class contains focused configuration objects for different concerns, while `DirectoryContext` manages hierarchical directory processing with bottom-up assembly patterns eliminating parent-to-child dependencies. The package structure implements centralized export patterns with explicit `__all__` declarations controlling the public API surface, preventing circular import issues and providing clean dependency management. Each data model follows comprehensive validation patterns through `__post_init__()` methods with descriptive error messages, integrated with automatic default setting for system integration points like project root detection.

####### Implementation Approach

The implementation employs frozen dataclasses with `@dataclass(frozen=True)` decorators creating immutable objects with hash support for set operations and dictionary keys, ensuring thread safety during concurrent indexing operations. Configuration validation uses comprehensive parameter checking with range validation for temperature settings (0.0-1.0), positive value validation for file sizes and batch parameters, and non-negative validation for retry settings. The filtering system implements efficient set-based membership testing for excluded extensions and directories with O(1) performance, combined with specialized logic for project-base exclusions through optional parameters. Serialization handles complex type conversion including sets to lists for JSON compatibility, enum values to strings for persistence, and Path objects to string representations with corresponding deserialization logic reconstructing proper types from JSON-compatible formats. Statistics calculation uses generator expressions and list comprehensions for memory-efficient computation across large directory hierarchies, with safe division handling preventing division by zero errors in percentage calculations.

######## External Dependencies & Integration Points

**→ Inbound:** [data model dependencies]
- `jesse_framework_mcp.llm.strands_agent_driver.models:Claude4SonnetModel` - LLM model constants for configuration defaults and validation
- `jesse_framework_mcp.helpers.path_utils:get_project_root` - project root detection for automatic knowledge directory configuration
- `dataclasses` (external library) - frozen and mutable dataclass decorators for structure definition and immutability
- `pathlib` (external library) - Path objects for cross-platform filesystem operations and validation
- `datetime` (external library) - timestamp handling, comparison operations, and ISO format serialization
- `typing` (external library) - type annotations including Dict, List, Optional, Set, Any for comprehensive type safety
- `enum` (external library) - Enum base classes for ProcessingStatus, ChangeType, and IndexingMode enumerations

**← Outbound:** [data model consumers]
- `../indexing/hierarchical_indexer.py:HierarchicalIndexer` - consumes all data models for processing coordination and state management
- `../indexing/config_manager.py:IndexingConfigManager` - uses IndexingConfig serialization methods for configuration persistence
- `../indexing/knowledge_builder.py:KnowledgeBuilder` - updates FileContext and DirectoryContext during content generation
- `../indexing/change_detector.py:ChangeDetector` - uses ChangeInfo and ChangeType for incremental processing workflows
- `../../server.py:JesseFrameworkMCPServer` - consumes IndexingStatus and ProcessingStats for operation monitoring
- `*.indexing-config.json` - JSON configuration files generated through IndexingConfig serialization methods

**⚡ System role and ecosystem integration:**
- **System Role**: Core data model foundation serving as the primary data contract for the entire Jesse Framework MCP knowledge base indexing system, defining all configuration parameters, runtime state structures, and processing coordination mechanisms
- **Ecosystem Position**: Central infrastructure component that bridges between configuration management, indexing operations, LLM integration, and external monitoring systems, enabling type-safe data flow throughout the indexing pipeline
- **Integration Pattern**: Used by all indexing components through direct imports and property access, consumed by MCP server for operation coordination, integrated with configuration managers through serialization methods, and supporting external applications requiring knowledge base data model access

######### Edge Cases & Error Handling

The system handles invalid configuration parameters through comprehensive validation in `__post_init__()` methods that raise `ValueError` with descriptive messages for out-of-range values, negative parameters, and invalid LLM settings. File and directory filtering methods include defensive checks for file system errors, handling `OSError` and `FileNotFoundError` exceptions gracefully by returning `False` for inaccessible files. Configuration serialization manages optional parameters through proper None checking, converting Path objects to strings safely, and handling complex type conversions between sets/lists and enums/strings with fallback behavior for missing data. Statistics calculation implements safe division handling returning 0.0 for empty collections to prevent division by zero errors, with None returns from duration calculations when timing information is incomplete. Import failures from sibling modules result in package initialization failure, requiring proper error handling at the application level, while circular dependency scenarios are prevented through the package structure design. Project root detection failures are handled gracefully by maintaining `None` values for knowledge directory configuration, enabling fallback behavior in consuming systems.

########## Internal Implementation Details

The configuration groups use `field(default_factory=...)` with lambda functions to create fresh instances of sets and configuration objects, preventing shared mutable state between dataclass instances. Default knowledge directory setting uses `object.__setattr__()` to modify frozen dataclasses during `__post_init__()`, creating new configuration instances with resolved project root paths. Property accessors provide direct access to nested configuration parameters without exposing hierarchical structure, maintaining backward compatibility during transition periods from flat to hierarchical configuration patterns. The filtering system uses set membership testing for O(1) performance with case-sensitive directory name comparison and lowercase extension comparison for consistent behavior across platforms. Serialization preserves complete configuration state through dictionary representation, handling complex types like `IndexingMode.value` for enum serialization and conditional string conversion for optional Path parameters. Statistics tracking employs mutable dataclasses with field factories for list initialization, enabling real-time metric updates throughout processing workflows with chronological error tracking and recursive aggregation for directory-level metrics.

########### Usage Examples

This example demonstrates comprehensive configuration creation and validation with hierarchical parameter organization. The code shows how to initialize configurations with custom settings while leveraging automatic validation and default setting mechanisms.

```python
from jesse_framework_mcp.knowledge_bases.models import (
    IndexingConfig, FileProcessingConfig, LLMConfig, IndexingMode
)

# Create hierarchical configuration with custom processing parameters
file_config = FileProcessingConfig(max_file_size=1024*1024, batch_size=5)
llm_config = LLMConfig(temperature=0.2, max_tokens=15000)

config = IndexingConfig(
    handler_type="git-clones",
    file_processing=file_config,
    llm_config=llm_config,
    indexing_mode=IndexingMode.INCREMENTAL
)

# Access through both hierarchical and flat property patterns
print(f"Max file size: {config.file_processing.max_file_size}")
print(f"Max file size (flat): {config.max_file_size}")
```

This example shows runtime context tracking and statistics collection throughout processing workflows. The code demonstrates hierarchical context assembly with comprehensive progress monitoring and error tracking capabilities.

```python
from jesse_framework_mcp.knowledge_bases.models import (
    DirectoryContext, FileContext, ProcessingStatus, ProcessingStats
)

# Create file processing contexts with comprehensive state tracking
file_context = FileContext(
    file_path=Path("src/component.py"),
    file_size=1024,
    last_modified=datetime.now(),
    processing_status=ProcessingStatus.COMPLETED,
    knowledge_content="Generated analysis content"
)

# Build hierarchical directory context with progress calculation
directory_context = DirectoryContext(
    directory_path=Path("src/"),
    file_contexts=[file_context],
    processing_status=ProcessingStatus.PROCESSING
)

# Track comprehensive processing statistics with error handling
stats = ProcessingStats()
stats.total_files_discovered = 100
stats.files_completed = 85
completion_rate = stats.files_completion_rate
```

## Subdirectory Knowledge Integration

*No subdirectories processed*

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/__init__.py

*Last Updated: 2025-07-05T18:37:47Z*

#### Functional Intent & Features

This file serves as the centralized package initialization module for the Knowledge Bases Hierarchical Indexing System data models, providing unified access to all configuration classes, runtime context structures, and processing state models used throughout the hierarchical indexing workflow and FastMCP integration. The module enables clean dependency management by exporting core data structures including configuration models, context tracking classes, and processing state enumerations through a standardized interface. Key semantic entities include `IndexingConfig` for system configuration, `IndexingMode` enumeration for processing modes, `DirectoryContext` for hierarchical directory processing state, `FileContext` for individual file processing tracking, `ChangeInfo` for incremental processing coordination, `IndexingStatus` for overall operation monitoring, `ProcessingStats` for comprehensive metrics collection, `ProcessingStatus` enumeration for workflow state management, `ChangeType` enumeration for change detection categories, and the `__all__` export list defining the public API surface. The system implements type-safe data structures with comprehensive validation, immutable configurations for thread safety, and clear separation between configuration and runtime context models supporting async operations throughout the indexing pipeline.

##### Main Components

The package exports nine core components through the `__all__` list, organized into two primary categories: configuration models and runtime context models. Configuration components include `IndexingConfig` class for system configuration management and `IndexingMode` enumeration for processing mode selection. Runtime context components encompass `DirectoryContext` for hierarchical directory processing state, `FileContext` for individual file processing tracking, `ChangeInfo` for incremental processing coordination, `IndexingStatus` for overall operation status monitoring, `ProcessingStats` for comprehensive metrics collection, `ProcessingStatus` enumeration for workflow state management, and `ChangeType` enumeration for change detection categorization. The module imports these components from two sibling modules: `.indexing_config` providing configuration data models and `.knowledge_context` supplying runtime context data models, establishing a clear architectural separation between configuration and operational state management.

###### Architecture & Design

The architecture implements a centralized export pattern with clear separation between configuration and runtime context models, enabling clean dependency management and preventing circular import issues. The design follows the package initialization pattern where all public components are imported from specialized modules and re-exported through a unified interface, providing consumers with a single import point for all data model requirements. The system uses explicit `__all__` declaration to control the public API surface and ensure only intended components are available through wildcard imports. The architectural separation between `.indexing_config` and `.knowledge_context` modules reflects the distinction between static configuration data and dynamic runtime state, supporting different lifecycle management patterns and serialization requirements throughout the indexing workflow.

####### Implementation Approach

The implementation uses Python's standard package initialization mechanism with explicit imports from sibling modules using relative import syntax (`.module_name`). The approach employs comprehensive export listing through `__all__` to define the public API surface and control component visibility. Import organization follows logical grouping with configuration models imported first from `.indexing_config`, followed by runtime context models from `.knowledge_context`, maintaining clear separation between static and dynamic data structures. The module maintains no internal state or business logic, serving purely as an aggregation and export point for data model components, ensuring lightweight initialization and minimal overhead during package import operations.

######## External Dependencies & Integration Points

**→ Inbound:**
- `.indexing_config:IndexingConfig` - system configuration class with validation and processing parameters
- `.indexing_config:IndexingMode` - enumeration defining processing modes for indexing operations
- `.knowledge_context:DirectoryContext` - hierarchical directory processing state and context management
- `.knowledge_context:FileContext` - individual file processing state tracking and metadata
- `.knowledge_context:ChangeInfo` - incremental processing coordination and change detection information
- `.knowledge_context:IndexingStatus` - overall operation status monitoring and progress tracking
- `.knowledge_context:ProcessingStats` - comprehensive metrics collection and performance analysis
- `.knowledge_context:ProcessingStatus` - workflow state management enumeration for processing coordination
- `.knowledge_context:ChangeType` - change detection categorization enumeration for incremental processing

**← Outbound:**
- `jesse_framework_mcp/knowledge_bases/indexing/hierarchical_indexer.py:HierarchicalIndexer` - consumes data models for processing coordination
- `jesse_framework_mcp/knowledge_bases/indexing/change_detector.py:ChangeDetector` - uses context models for change detection workflows
- `jesse_framework_mcp/knowledge_bases/indexing/knowledge_builder.py:KnowledgeBuilder` - imports models for content generation operations
- `jesse_framework_mcp/server.py:JesseFrameworkMCPServer` - uses models for MCP server operation and status reporting
- External applications - import models through Jesse Framework MCP for knowledge base operations

**⚡ System role and ecosystem integration:**
- **System Role**: Central data model registry for the Jesse Framework MCP knowledge base system, providing unified access to all configuration and runtime context structures
- **Ecosystem Position**: Core infrastructure component serving as the primary data contract interface between all indexing components and external consumers
- **Integration Pattern**: Used by all indexing components through direct imports, consumed by MCP server for operation coordination, and integrated with external applications requiring knowledge base data model access

######### Edge Cases & Error Handling

Import failures from either `.indexing_config` or `.knowledge_context` modules result in package initialization failure, preventing the entire models package from becoming available to consumers. Missing or corrupted sibling modules cause import errors that propagate to consuming applications, requiring proper error handling at the application level. Circular dependency scenarios between the exported models and consuming components are prevented through the package structure but could emerge from future architectural changes. Version mismatches between the initialization module and sibling modules could lead to API inconsistencies or missing component exports. The package provides no error handling mechanisms itself, relying on Python's import system to surface module loading issues and individual model classes to handle their specific validation and error scenarios.

########## Internal Implementation Details

The package uses Python's standard relative import mechanism with dot notation (`.module_name`) to reference sibling modules within the same package directory. Import statements are organized logically with configuration models imported first, followed by runtime context models, maintaining clear architectural separation. The `__all__` list uses explicit string literals for each exported component name, ensuring precise control over the public API surface and preventing accidental exposure of internal implementation details. Module-level imports are performed at package initialization time, making all components immediately available upon successful import without lazy loading or dynamic import mechanisms. The package maintains no internal state, configuration, or business logic, serving purely as an export aggregation point with minimal overhead and maximum compatibility across different Python environments.

########### Code Usage Examples

Standard package import demonstrates the unified access pattern for all knowledge base data models. This approach provides clean dependency management and consistent API access across the indexing system.

```python
# Import all data models through unified package interface
from jesse_framework_mcp.knowledge_bases.models import (
    IndexingConfig,
    IndexingMode,
    DirectoryContext,
    FileContext,
    ProcessingStatus,
    IndexingStatus
)

# Initialize configuration with processing parameters
config = IndexingConfig(
    knowledge_output_directory=Path("./knowledge"),
    indexing_mode=IndexingMode.INCREMENTAL
)
```

Selective component import enables targeted usage for specific functionality requirements. This pattern supports modular development and reduces import overhead for specialized use cases.

```python
# Import only required components for specific operations
from jesse_framework_mcp.knowledge_bases.models import ProcessingStats, ChangeInfo, ChangeType

# Create processing statistics tracker
stats = ProcessingStats()
stats.total_files_discovered = 100

# Track change information for incremental processing
change = ChangeInfo(
    path=Path("src/component.py"),
    change_type=ChangeType.MODIFIED
)
```

Package-level wildcard import brings in all components defined in `__all__` for comprehensive model access. This approach is suitable for development environments and comprehensive testing scenarios.

```python
# Wildcard import provides access to all exported models
from jesse_framework_mcp.knowledge_bases.models import *

# All nine components are now available in local namespace
directory_context = DirectoryContext(directory_path=Path("src/"))
file_context = FileContext(file_path=Path("src/main.py"), file_size=1024, last_modified=datetime.now())
indexing_status = IndexingStatus(overall_status=ProcessingStatus.PROCESSING)
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/indexing_config.py

*Last Updated: 2025-07-05T18:37:47Z*

#### Functional Intent & Features

The `indexing_config.py` file serves as the comprehensive configuration data model for the Jesse Framework MCP's knowledge base hierarchical indexing system, providing immutable type-safe configuration management with validation at initialization through frozen dataclasses. This module enables centralized control of all indexing parameters including file processing constraints, LLM integration settings, and specialized handling requirements, evidenced by the main `IndexingConfig` class with hierarchical configuration groups and the `IndexingMode` enum with values `FULL`, `FULL_KB_REBUILD`, and `INCREMENTAL`. Key semantic entities include configuration dataclasses like `FileProcessingConfig`, `ContentFilteringConfig`, `LLMConfig`, `ChangeDetectionConfig`, `ErrorHandlingConfig`, `OutputConfig`, and `DebugConfig`, integration with `Claude4SonnetModel.CLAUDE_4_SONNET` for LLM configuration, utility methods `should_process_file()` and `should_process_directory()` for filtering decisions, and serialization methods `to_dict()` and `from_dict()` for persistence and configuration manager integration. The system implements automatic default knowledge directory setting to `{PROJECT_ROOT}/.knowledge/` through `get_project_root()` integration and provides backward compatibility through property accessors for flat configuration access patterns.

##### Main Components

The file contains the primary `IndexingConfig` frozen dataclass with seven hierarchical configuration groups, six specialized configuration dataclasses (`FileProcessingConfig`, `ContentFilteringConfig`, `LLMConfig`, `ChangeDetectionConfig`, `ErrorHandlingConfig`, `OutputConfig`, `DebugConfig`) that organize related parameters, and the `IndexingMode` enum defining processing strategies. Core methods include `__post_init__()` for validation and default setting, filtering methods `should_process_file()` and `should_process_directory()` for processing decisions, serialization methods `to_dict()` and `from_dict()` for configuration persistence, and the class method `load_for_handler()` for configuration manager integration. The class provides comprehensive property accessors for backward compatibility, enabling flat access to hierarchically organized configuration parameters.

###### Architecture & Design

The architecture follows a hierarchical frozen dataclass pattern with specialized configuration groups that organize related parameters into logical domains, enabling maintainable configuration management while preserving immutability after initialization. The design implements a composition pattern where the main `IndexingConfig` class contains focused configuration objects for different concerns, combined with property accessors that provide backward compatibility during the transition from flat to hierarchical configuration structures. The system uses defensive validation through `__post_init__()` that checks all parameters at creation time, integrated with automatic default setting for the knowledge output directory using project root detection. Each configuration group follows the frozen dataclass pattern ensuring immutability while providing clear separation of concerns between file processing, content filtering, LLM integration, change detection, error handling, output management, and debug functionality.

####### Implementation Approach

The implementation employs frozen dataclasses with `field(default_factory=...)` for complex default values like sets and nested configuration objects, ensuring proper initialization without shared mutable state between instances. Configuration validation uses comprehensive parameter checking in `__post_init__()` with descriptive error messages for invalid values, including range validation for temperature (0.0-1.0), positive value validation for file sizes and batch parameters, and non-negative validation for retry settings. The filtering system implements efficient set-based membership testing for excluded extensions and directories, with specialized logic for project-base exclusions through optional `project_base_exclusions` parameter. Serialization handles complex type conversion including sets to lists for JSON compatibility, enum values to strings, and Path objects to string representations, with corresponding deserialization logic in `from_dict()` that reconstructs proper types from JSON-compatible formats.

######## External Dependencies & Integration Points

**→ Inbound:** [configuration model dependencies]
- `jesse_framework_mcp.llm.strands_agent_driver.models:Claude4SonnetModel` - LLM model constants for configuration defaults
- `jesse_framework_mcp.helpers.path_utils:get_project_root` - project root detection for default knowledge directory
- `dataclasses` (external library) - frozen dataclass implementation for immutable configuration
- `pathlib` (external library) - path handling and validation for directory configuration
- `typing` (external library) - type annotations for configuration parameters
- `enum` (external library) - IndexingMode enumeration for processing strategies

**← Outbound:** [configuration consumers]
- `../indexing/config_manager.py:IndexingConfigManager` - configuration loading and validation through from_dict method
- `knowledge_bases/indexing/` - indexing operations consuming configuration parameters through property accessors
- `*.indexing-config.json` - JSON configuration files generated through to_dict serialization
- `hierarchical_indexer.py` - indexing operations using filtering methods and processing parameters

**⚡ System role and ecosystem integration:**
- **System Role**: Central configuration model that defines all parameters for knowledge base indexing operations, serving as the single source of truth for indexing behavior across the Jesse Framework MCP system
- **Ecosystem Position**: Core data model that bridges between configuration management, indexing operations, and LLM integration, enabling type-safe configuration with validation
- **Integration Pattern**: Used by indexing handlers through property access, configuration managers through serialization methods, and validation systems through filtering methods, with automatic integration to project structure through default directory setting

######### Edge Cases & Error Handling

The system handles invalid configuration parameters through comprehensive validation in `__post_init__()` that raises `ValueError` with descriptive messages for out-of-range values, negative parameters, and invalid LLM settings. File and directory filtering methods include defensive checks for file system errors, handling `OSError` and `FileNotFoundError` exceptions gracefully by returning `False` for inaccessible files. Configuration serialization handles optional parameters through proper None checking, converting Path objects to strings safely, and managing complex type conversions between sets/lists and enums/strings. The `from_dict()` method provides robust deserialization with fallback defaults for missing parameters, proper type conversion from JSON-compatible formats, and validation through normal dataclass initialization. Project root detection failures are handled gracefully by maintaining `None` values for knowledge directory configuration, enabling fallback behavior in consuming systems.

########## Internal Implementation Details

The configuration groups use `field(default_factory=...)` with lambda functions to create fresh instances of sets and configuration objects, preventing shared mutable state between `IndexingConfig` instances. Default knowledge directory setting uses `object.__setattr__()` to modify the frozen dataclass during `__post_init__()`, creating a new `OutputConfig` instance with the resolved project root path. Property accessors provide direct access to nested configuration parameters without exposing the hierarchical structure, maintaining backward compatibility during the transition period. The filtering system uses set membership testing for O(1) performance on excluded extensions and directories, with case-sensitive directory name comparison and lowercase extension comparison for consistent behavior. Serialization preserves all configuration state through complete dictionary representation, handling complex types like `IndexingMode.value` for enum serialization and conditional string conversion for optional Path parameters.

########### Code Usage Examples

This example demonstrates creating and validating a basic indexing configuration with custom parameters. The code shows how to initialize the configuration with hierarchical groups and access parameters through both hierarchical and flat property access patterns.

```python
from pathlib import Path
from jesse_framework_mcp.knowledge_bases.models.indexing_config import (
    IndexingConfig, FileProcessingConfig, LLMConfig, IndexingMode
)

# Create configuration with custom file processing settings
file_config = FileProcessingConfig(max_file_size=1024*1024, batch_size=5)
llm_config = LLMConfig(temperature=0.2, max_tokens=15000)

config = IndexingConfig(
    handler_type="git-clones",
    file_processing=file_config,
    llm_config=llm_config
)

# Access through both hierarchical and flat patterns
print(f"Max file size: {config.file_processing.max_file_size}")
print(f"Max file size (flat): {config.max_file_size}")
print(f"LLM model: {config.llm_model}")
```

This example shows configuration serialization and deserialization for persistence and configuration management integration. The code demonstrates the complete round-trip process for configuration storage and loading.

```python
# Serialize configuration to dictionary for JSON storage
config_dict = config.to_dict()
print(f"Serialized config: {config_dict['handler_type']}")

# Deserialize configuration from dictionary (e.g., from JSON file)
loaded_config = IndexingConfig.from_dict(config_dict)
print(f"Loaded handler: {loaded_config.handler_type}")

# Use filtering methods for file processing decisions
test_file = Path("example.py")
if loaded_config.should_process_file(test_file):
    print(f"Will process: {test_file}")

# Load configuration for specific handler using convenience method
project_config = IndexingConfig.load_for_handler("project-base")
print(f"Project config mode: {project_config.indexing_mode}")
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/knowledge_context.py

*Last Updated: 2025-07-05T18:37:47Z*

#### Functional Intent & Features

This file defines runtime context data models for the Jesse Framework MCP Knowledge Bases Hierarchical Indexing System, providing immutable context structures for directory processing, file analysis, change tracking, and indexing operation status throughout hierarchical processing workflows. The module enables comprehensive tracking of indexing operations through structured data models supporting thread-safe operations, serialization, and async processing patterns. Key semantic entities include `ProcessingStatus` enum with states (`PENDING`, `PROCESSING`, `COMPLETED`, `FAILED`, `SKIPPED`), `ChangeType` enum for change detection (`NEW`, `MODIFIED`, `DELETED`, `MOVED`), `FileContext` frozen dataclass for individual file processing state, `DirectoryContext` frozen dataclass for hierarchical directory processing, `ChangeInfo` frozen dataclass for incremental processing coordination, `ProcessingStats` mutable dataclass for comprehensive metrics tracking, `IndexingStatus` mutable dataclass for overall operation status, `dataclasses` module for structure definition, `datetime` for timestamp handling, `pathlib.Path` for filesystem operations, and `typing` annotations for type safety. The system implements bottom-up hierarchical context assembly without parent-to-child dependencies while maintaining accurate processing statistics and progress reporting capabilities.

##### Main Components

The file contains five primary data model classes and two enumeration types providing comprehensive context tracking capabilities. The `ProcessingStatus` enum defines processing states with five values for workflow coordination, while `ChangeType` enum provides four change categories for incremental processing optimization. The `FileContext` frozen dataclass tracks individual file processing with properties including `file_path`, `file_size`, `last_modified`, `processing_status`, `knowledge_content`, error tracking, and timing information with computed properties `processing_duration` and `is_completed`. The `DirectoryContext` frozen dataclass manages hierarchical directory processing with `directory_path`, `file_contexts` list, `subdirectory_contexts` list, processing state, and computed properties `total_files`, `completed_files`, `completion_percentage`, and `is_ready_for_summary`. The `ChangeInfo` frozen dataclass captures change detection information with path tracking, timestamps, and `is_content_change` property. The `ProcessingStats` mutable dataclass provides comprehensive metrics tracking with file statistics, directory statistics, content processing metrics, performance timing, and error collection. The `IndexingStatus` mutable dataclass coordinates overall operation status with progress tracking and serialization capabilities.

###### Architecture & Design

The architecture implements immutable context structures using frozen dataclasses for thread-safe operations during concurrent processing, with clear separation between processing state tracking and configuration management. The design follows bottom-up hierarchical context assembly patterns where child contexts are processed independently before parent directory processing, eliminating parent-to-child dependencies and enabling efficient concurrent operations. Key design patterns include the frozen dataclass pattern for immutable context preservation, computed property patterns for derived statistics calculation, mutable statistics tracking for real-time updates, and comprehensive serialization support through `to_dict()` methods. The system uses string-based enums for serialization compatibility and debugging clarity, with status transitions supporting both successful and failed processing scenarios. Error handling is integrated throughout with optional error message fields and comprehensive error tracking in statistics objects.

####### Implementation Approach

The implementation uses frozen dataclasses with `@dataclass(frozen=True)` decorator for immutable context structures ensuring thread safety during concurrent processing operations. Computed properties leverage list comprehensions and generator expressions for efficient statistics calculation across hierarchical structures, with recursive aggregation for directory-level metrics. The system implements safe division handling in percentage calculations returning 0.0 for empty collections to prevent division by zero errors. Change detection uses timestamp-based comparison with `datetime` objects and optional path tracking for move operations. Statistics tracking employs mutable dataclasses with field factories for list initialization and real-time metric updates throughout processing workflows. Serialization support uses dictionary conversion with ISO timestamp formatting and comprehensive field inclusion for external system integration.

######## External Dependencies & Integration Points

**→ Inbound:**
- `dataclasses` (external library) - frozen and mutable dataclass decorators for structure definition and immutability
- `datetime` (external library) - timestamp handling, comparison operations, and ISO format serialization
- `pathlib` (external library) - Path objects for cross-platform filesystem operations and validation
- `typing` (external library) - type annotations including Dict, List, Optional, Set, Any for type safety
- `enum` (external library) - Enum base class for ProcessingStatus and ChangeType enumeration definitions

**← Outbound:**
- `jesse_framework_mcp/knowledge_bases/indexing/hierarchical_indexer.py:HierarchicalIndexer` - consumes context models for processing coordination
- `jesse_framework_mcp/knowledge_bases/indexing/change_detector.py:ChangeDetector` - uses ChangeInfo and ChangeType for incremental processing
- `jesse_framework_mcp/knowledge_bases/indexing/knowledge_builder.py:KnowledgeBuilder` - updates FileContext and DirectoryContext during processing
- `jesse_framework_mcp/server.py:JesseFrameworkMCPServer` - uses IndexingStatus for operation monitoring and progress reporting
- External monitoring systems - consume serialized statistics and status information through to_dict() methods

**⚡ System role and ecosystem integration:**
- **System Role**: Core data model foundation for the Jesse Framework MCP hierarchical indexing system, providing structured context tracking and statistics throughout all processing operations
- **Ecosystem Position**: Central infrastructure component supporting all indexing workflows, serving as the primary data contract between processing components and external monitoring systems
- **Integration Pattern**: Used by all indexing components for state management and progress tracking, consumed by MCP server for operation monitoring, and integrated with external systems through comprehensive serialization capabilities

######### Edge Cases & Error Handling

The system handles division by zero scenarios in percentage calculations by returning 0.0 when total counts are zero, preventing calculation errors in empty directory or file collection scenarios. Missing timestamp information is handled gracefully with None returns from duration calculation properties, supporting incomplete processing scenarios and timing failures. Error message tracking uses optional string fields allowing processing to continue without error information while preserving failure details when available. Completion status checking combines multiple criteria including both status enumeration and content validation, ensuring robust completion detection across different processing scenarios. Recursive statistics calculation handles empty subdirectory collections and missing child contexts through safe aggregation patterns. Serialization handles optional datetime fields with None checking and ISO format conversion, preventing serialization failures when timing information is incomplete.

########## Internal Implementation Details

The frozen dataclass implementation uses `@dataclass(frozen=True)` decorator creating immutable objects with hash support for set operations and dictionary keys. Computed properties use generator expressions and sum aggregation for memory-efficient calculation across large directory hierarchies. The `field(default_factory=list)` pattern initializes mutable collections preventing shared reference issues between dataclass instances. String-based enums inherit from both `str` and `Enum` enabling direct string comparison and JSON serialization compatibility. Error tracking uses list append operations in `add_error()` method maintaining chronological error order for debugging analysis. Statistics calculation properties implement safe division with zero checking and appropriate default values for edge cases. Serialization methods use dictionary comprehension and conditional formatting for optional fields, ensuring complete data preservation while handling None values appropriately.

########### Code Usage Examples

Basic file context creation and status tracking demonstrates the fundamental pattern for individual file processing state management. This approach provides comprehensive tracking throughout the processing lifecycle with immutable context preservation.

```python
# Create and track file processing context with comprehensive state management
from datetime import datetime
from pathlib import Path

file_context = FileContext(
    file_path=Path("src/components/button.py"),
    file_size=1024,
    last_modified=datetime.now(),
    processing_status=ProcessingStatus.PENDING
)

# Check processing completion with content validation
if file_context.is_completed:
    print(f"File processed: {file_context.processing_duration}s")
```

Directory context hierarchical assembly showcases the bottom-up processing pattern with recursive statistics calculation. This pattern enables comprehensive progress tracking across directory hierarchies without parent-to-child dependencies.

```python
# Build hierarchical directory context with child aggregation and progress tracking
directory_context = DirectoryContext(
    directory_path=Path("src/components/"),
    file_contexts=[file_context1, file_context2],
    subdirectory_contexts=[subdir_context1, subdir_context2],
    processing_status=ProcessingStatus.PROCESSING
)

# Calculate hierarchical completion metrics
total_files = directory_context.total_files
completion_rate = directory_context.completion_percentage
is_ready = directory_context.is_ready_for_summary
```

Comprehensive statistics tracking and serialization demonstrates real-time metrics collection with external system integration. This approach provides detailed performance analysis and monitoring capabilities throughout indexing operations.

```python
# Track processing statistics with comprehensive metrics and error handling
stats = ProcessingStats()
stats.processing_start_time = datetime.now()
stats.total_files_discovered = 150
stats.files_completed = 120
stats.files_failed = 5

# Add error information and calculate performance metrics
stats.add_error("Failed to process corrupted file: example.py")
completion_rate = stats.files_completion_rate
error_rate = stats.error_rate

# Serialize for external monitoring systems
stats_dict = stats.to_dict()
```

---
*Generated: 2025-07-05T18:37:47Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models*
*Total Files: 3*
*Total Subdirectories: 0*

# End of models_kb.md