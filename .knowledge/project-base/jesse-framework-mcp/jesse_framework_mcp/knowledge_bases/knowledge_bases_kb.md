<!-- ⚠️ DO NOT EDIT MANUALLY! DOCUMENT AUTOMATICALLY GENERATED! ⚠️ -->
<!-- This file is automatically generated by the JESSE Knowledge Base system. -->
<!-- Manual edits will be overwritten during the next generation cycle. -->
<!-- To modify content, update the source files and regenerate the knowledge base. -->
# Directory Knowledge Base {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/

## Global Summary

#### Functional Intent & Features

This directory implements the core Knowledge Bases Hierarchical Indexing System for the Jesse Framework MCP Server, providing comprehensive orchestration of LLM-powered content analysis, cache-first processing optimization, and Plan-then-Execute architecture for reliable knowledge base generation. The system enables automated conversion of source code repositories into structured markdown knowledge bases through bottom-up hierarchical processing, utilizing `HierarchicalIndexer` for workflow orchestration, `KnowledgeBuilder` for Claude 4 Sonnet integration, `FileAnalysisCache` for performance optimization, and `RebuildDecisionEngine` for centralized decision-making. Key semantic entities include `FastMCP` server integration, `register_knowledge_bases_tools` and `register_knowledge_bases_resources` functions, `IndexingConfig` configuration management, `DirectoryContext` and `FileContext` runtime tracking, `ExecutionPlan` and `AtomicTask` execution modeling, `ProcessingStatus` and `IndexingMode` enumerations, `DecisionReport` and `RebuildDecision` audit structures, `TruncationDetectedError` handling, `EnhancedPrompts` LLM templates, `KnowledgeFileGenerator` output creation, `DebugHandler` interaction capture, `MarkdownParser` AST manipulation, `GitCloneHandler` and `ProjectBaseHandler` specialized processing, `mistletoe` parsing integration, `StrandsClaude4Driver` LLM operations, `Claude4SonnetConfig` model configuration, and comprehensive change detection with selective cascading rebuilds through continuation-based retry mechanisms and defensive programming patterns ensuring reliable operation across diverse filesystem configurations and LLM processing scenarios.

##### Main Components

The directory contains three primary implementation categories organized around MCP integration, core indexing functionality, and supporting infrastructure. The MCP integration layer includes `tools.py` providing `knowledge_bases_index_trigger`, `knowledge_bases_status`, and `knowledge_bases_search` tool implementations, `resources.py` exposing `jesse://knowledge_bases/config/default`, `jesse://knowledge_bases/templates/usage_examples`, and `jesse://knowledge_bases/documentation/system_overview` resource endpoints, and `__init__.py` centralizing package exports for clean dependency management. The core indexing functionality encompasses the `indexing/` subdirectory containing 14 specialized modules including `hierarchical_indexer.py` for Plan-then-Execute orchestration, `knowledge_builder.py` for LLM-powered content analysis, `file_analysis_cache.py` for performance optimization, `rebuild_decision_engine.py` for centralized decision logic, `execution_engine.py` and `plan_generator.py` for atomic task processing, `knowledge_prompts.py` for specialized LLM templates, `knowledge_file_generator.py` for template-based output, `debug_handler.py` for interaction capture, `markdown_parser.py` for AST-based document manipulation, `config_manager.py` for auto-generation capabilities, `defaults.py` for handler-specific templates, and `special_handlers.py` for git-clone and project-base scenarios. The supporting infrastructure includes the `models/` subdirectory with comprehensive data structures through `IndexingConfig`, `DirectoryContext`, `FileContext`, `DecisionReport`, `ExecutionPlan`, and related validation models, plus empty `tests/` directory representing future testing capabilities.

###### Architecture & Design

The architecture implements a sophisticated Plan-then-Execute pattern separating decision-making from execution through distinct phases: Discovery builds complete directory hierarchies, Decision Analysis generates comprehensive rebuild reports, Plan Generation converts decisions into atomic tasks with dependencies, and Atomic Execution performs dependency-aware task processing. The design emphasizes cache-first processing strategies through `FileAnalysisCache` integration, avoiding unnecessary LLM calls when source files remain unchanged, and implements continuation-based retry mechanisms instead of fresh conversation restarts, providing 90%+ token savings through intelligent response completion and overlap detection. The system uses fail-fast principles with `TruncationDetectedError` preventing artifact creation when LLM output is incomplete, separates concerns between LLM operations, content processing, cache management, and debug handling through dedicated component classes, and employs hierarchical configuration management with specialized settings for different processing modes including project-base, git-clones, and pdf-knowledge handlers. The architecture implements selective cascading where content-driven rebuilds automatically trigger ancestor directory rebuilds while avoiding unnecessary sibling processing, uses immutable data model foundations through frozen dataclasses ensuring thread safety and preventing runtime modifications, and provides comprehensive MCP integration through `FastMCP` tool and resource registration patterns with HTTP-formatted responses maintaining JESSE Framework consistency.

####### Implementation Approach

The implementation utilizes async-first patterns throughout with `asyncio` concurrency control and `FastMCP` Context integration for progress reporting, implementing cache-first processing that checks `FileAnalysisCache` before making LLM calls with selective caching based on compliance review outcomes and timestamp-based staleness detection. The system employs intelligent response merging for continuation scenarios, detecting overlapping content at merge boundaries and removing duplicate sentences through sentence-level analysis, while handling empty files using filesystem metadata through `Path.stat().st_size` for efficient detection without content reading. Content extraction uses string processing to remove LLM-generated headers while preserving legitimate section structure through pattern matching and AST-based manipulation via `mistletoe` integration. The bounded loop reviewer workflow applies iterative corrections with configurable maximum iterations to prevent infinite loops while ensuring content compliance, and knowledge file generation uses template-based approaches through `KnowledgeFileGenerator` with alphabetical sorting and complete rebuild strategies. Debug handling provides comprehensive interaction capture with replay functionality for consistent testing workflows and deterministic debugging scenarios, while configuration management implements auto-generation of missing JSON files from centralized Python defaults with comprehensive `Pydantic` validation for type-safe parameter management.

######## External Dependencies & Integration Points

**→ Inbound:**
- `fastmcp.FastMCP` (external library) - MCP server framework enabling tool and resource registration with async execution patterns
- `fastmcp.Context` (external library) - Progress reporting and logging interface for real-time user feedback during operations
- `jesse_framework_mcp.llm.strands_agent_driver.StrandsClaude4Driver` - Claude 4 Sonnet LLM integration driver for content analysis
- `jesse_framework_mcp.llm.strands_agent_driver.Claude4SonnetConfig` - LLM configuration model for analysis task parameters
- `jesse_framework_mcp.llm.strands_agent_driver.models.Claude4SonnetModel` - Official Claude 4 Sonnet model identifiers
- `jesse_framework_mcp.helpers.async_http_formatter.format_http_response` - HTTP response formatting utility for JESSE Framework consistency
- `jesse_framework_mcp.helpers.path_utils.get_portable_path` - Cross-platform path handling for knowledge base generation
- `jesse_framework_mcp.helpers.path_utils.get_project_root` - Project root detection for automatic configuration defaulting
- `jesse_framework_mcp.helpers.mistletoe_spacing` - Spacing preservation utilities for markdown manipulation
- `mistletoe` (external library) - AST-based markdown parsing and rendering for document structure manipulation
- `pydantic` (external library) - Configuration validation and type safety for hierarchical parameter management
- `asyncio` (external library) - Async programming patterns for concurrent LLM operations and file processing
- `pathlib` (external library) - Cross-platform file operations and path handling throughout the system
- `json` (external library) - Configuration serialization and debug metadata management
- `logging` (external library) - Structured logging for operations, error tracking, and debugging workflows
- `datetime` (external library) - Timestamp tracking and processing duration calculations
- `hashlib` (external library) - Content hashing for interaction identification and duplicate detection

**← Outbound:**
- `jesse_framework_mcp.main.JesseFrameworkMCPServer` - MCP server consuming package exports for knowledge base functionality integration
- `jesse_framework_mcp.server` - Server initialization consuming tool and resource registration functions
- `External MCP clients` - Consuming registered tools and resources through FastMCP protocol for knowledge base operations
- `generated/knowledge_files/*.md` - Structured knowledge files in markdown format consumed by knowledge management systems
- `generated/cache_files/*.analysis.md` - Cached analysis files for performance optimization and incremental processing
- `generated/debug_artifacts/` - Debug interaction files for replay, analysis, and troubleshooting workflows
- `*.indexing-config.json` - Auto-generated configuration files for user customization and system setup
- `Development tools` - Importing knowledge base components for automated documentation and maintenance workflows
- `Configuration systems` - Using IndexingConfig and IndexingMode for system setup and parameter management
- `Monitoring systems` - Accessing ProcessingStats and ExecutionResults for performance analysis and optimization

**⚡ System role and ecosystem integration:**
- **System Role**: Core knowledge base processing engine for the Jesse Framework MCP Server, serving as the primary interface between source content repositories and structured knowledge base generation with comprehensive caching, optimization, and Plan-then-Execute workflow coordination
- **Ecosystem Position**: Central infrastructure component in the knowledge management pipeline, bridging raw source files with LLM-powered analysis through hierarchical indexing workflows while providing standardized MCP tool and resource interfaces for external system integration
- **Integration Pattern**: Used by MCP server during initialization for tool and resource registration, consumed by external MCP clients through protocol-standard interfaces, integrated with development workflows for automated knowledge base maintenance, and coordinated with FastMCP Context for progress reporting to human operators during long-running indexing operations

######### Edge Cases & Error Handling

The system handles comprehensive edge cases including empty file scenarios with infinite rebuild loop prevention through standardized analysis generation, missing project root detection with setup guidance generation, filesystem permission issues with graceful degradation, and AWS credential validation with warning-level reporting for missing configurations. Error handling covers `FastMCP` decorator unwrapping failures, LLM driver initialization errors, cache staleness validation, and HTTP formatting edge cases including Unicode content handling and byte-perfect content-length calculations. The framework validates truncation detection through multiple strategies including programmatic marker checking with `--END OF LLM OUTPUT--` detection, LLM reviewer validation for structural compliance, and continuation-based recovery mechanisms using conversation ID preservation for 90%+ token savings. Concurrent operation safety is ensured through upfront cache structure preparation via `FileAnalysisCache.prepare_cache_structure()`, race condition detection, and semaphore-based resource management through `asyncio.Semaphore` concurrency control. Configuration validation includes unsupported handler type scenarios with descriptive error messages listing valid options, invalid JSON parsing with comprehensive field-level error reporting, and Pydantic model validation errors with detailed context information. The system provides comprehensive orphaned file detection with safety validation preventing accidental deletion of valid content through `is_safe_to_delete` metadata flags, handles circular dependency prevention in task execution through depth-first search algorithms, and manages filesystem errors during knowledge file writing with proper directory creation and structured error reporting.

########## Internal Implementation Details

The `FileAnalysisCache` uses HTML comment metadata blocks with `CACHE_VERSION = "1.0"` for future compatibility and includes portable source file paths using `get_portable_path()` for cross-environment compatibility, while the `DebugHandler` maintains pipeline stage organization through `PIPELINE_STAGES` dictionary with five distinct processing stages and uses hash-based interaction identification combining prompt content hashes with timestamps. The `ExecutionEngine` maintains internal state through three sets tracking completed, failed, and running tasks with `asyncio.Semaphore` concurrency control, while the `KnowledgeBuilder` implements dual truncation detection strategy combining programmatic marker checking with LLM reviewer validation, using conversation ID preservation for continuation-based retry mechanisms. The `MarkdownParser` leverages `mistletoe` line_number attributes for spacing-aware document manipulation and token-level AST manipulation for structure preservation, while configuration management uses deep copying for template immutability and hierarchical validation through nested Pydantic models. The system employs predictable filename generation based on normalized paths and pipeline stages, comprehensive metadata embedding for task execution context including file characteristics and decision reasoning, and performance tracking through counters and timing measurements across all major operations. Internal mechanisms include `datetime.now()` for processing timing, recursive directory traversal through specialized handler methods, status mapping between `ExecutionResults` and `IndexingStatus` formats for API compatibility, and resource management through cleanup methods delegating to component-specific resource cleanup procedures.

########### Usage Examples

**Basic hierarchical indexing workflow initialization and execution:**

This example demonstrates the complete workflow for initializing and executing hierarchical knowledge base indexing with progress reporting and error handling, showcasing the Plan-then-Execute architecture coordination.

```python
from pathlib import Path
from fastmcp import Context
from jesse_framework_mcp.knowledge_bases import (
    HierarchicalIndexer, IndexingConfig, IndexingMode
)

# Initialize hierarchical indexer with comprehensive configuration
config = IndexingConfig(
    handler_type="project-base",
    indexing_mode=IndexingMode.INCREMENTAL,
    knowledge_output_directory=Path(".knowledge"),
    max_concurrent_operations=4,
    continue_on_file_errors=True
)
indexer = HierarchicalIndexer(config)

# Execute complete indexing workflow with progress reporting
async def run_knowledge_indexing():
    ctx = Context()
    source_root = Path("./src")
    status = await indexer.index_hierarchy(source_root, ctx)
    print(f"Indexing completed: {status.overall_status}")
    print(f"Files processed: {status.processing_stats.files_completed}")
    print(f"LLM calls made: {status.processing_stats.llm_calls_made}")
    return status
```

**MCP server integration with tool and resource registration:**

This example shows how to integrate the knowledge bases system with a FastMCP server, registering both tools for manual operations and resources for configuration access.

```python
from fastmcp import FastMCP
from jesse_framework_mcp.knowledge_bases import (
    register_knowledge_bases_tools,
    register_knowledge_bases_resources
)

# Initialize FastMCP server with knowledge base functionality
server = FastMCP("Jesse Framework MCP")

# Register knowledge base tools for manual indexing operations
register_knowledge_bases_tools(server)

# Register knowledge base resources for configuration access
register_knowledge_bases_resources(server)

# Tools now available: knowledge_bases_index_trigger, knowledge_bases_status, knowledge_bases_search
# Resources now available: jesse://knowledge_bases/config/default, jesse://knowledge_bases/templates/usage_examples
```

**Cache-first processing with LLM integration and debug capture:**

This example demonstrates leveraging the cache-first processing strategy for individual file analysis with Claude 4 Sonnet integration and comprehensive debug capture for troubleshooting.

```python
from jesse_framework_mcp.knowledge_bases.indexing import (
    KnowledgeBuilder, FileAnalysisCache, DebugHandler
)
from jesse_framework_mcp.knowledge_bases.models import FileContext

# Initialize knowledge builder with cache optimization and debug capture
config = IndexingConfig(debug_enabled=True, enable_replay=True)
builder = KnowledgeBuilder(config)
await builder.initialize()

# Process individual file with cache-first strategy and debug capture
file_context = FileContext(
    file_path=Path("example.py"),
    file_size=1024,
    last_modified=datetime.now()
)

# Check cache first, then process with LLM if needed
cached_analysis = await builder.analysis_cache.get_cached_analysis(
    file_context.file_path, source_root
)

if cached_analysis:
    result = cached_analysis
    print("Using cached analysis")
else:
    result = await builder.build_file_knowledge(file_context, ctx, source_root)
    print(f"Generated new analysis: {result.processing_status}")
```

**Plan-then-Execute architecture with atomic task processing:**

This example demonstrates the Plan-then-Execute architecture for converting decisions into atomic tasks with dependency management and concurrent execution coordination.

```python
from jesse_framework_mcp.knowledge_bases.indexing import (
    RebuildDecisionEngine, PlanGenerator, ExecutionEngine
)

# Phase 1: Generate comprehensive decision report
decision_engine = RebuildDecisionEngine(config)
decision_report = await decision_engine.analyze_hierarchy(
    root_context, source_root, ctx
)

# Phase 2: Convert decisions to atomic execution plan
plan_generator = PlanGenerator(config)
execution_plan = await plan_generator.create_execution_plan(
    root_context, decision_report, source_root, ctx
)

# Phase 3: Execute plan with dependency-aware task processing
execution_engine = ExecutionEngine(config)
results = await execution_engine.execute_plan(execution_plan, ctx)

print(f"Plan executed: {len(results.completed_tasks)} completed")
print(f"LLM calls made: {results.llm_calls_made}")
print(f"Total duration: {results.total_duration:.1f}s")
```

## Subdirectory Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/indexing/
*Last Updated: 2025-07-07T10:06:45Z*

This directory implements the core hierarchical knowledge base indexing system for the Jesse Framework MCP Server, providing comprehensive orchestration of LLM-powered content analysis, cache-first processing optimization, and Plan-then-Execute architecture for reliable knowledge base generation. The system enables automated conversion of source code repositories into structured markdown knowledge bases through bottom-up hierarchical processing, utilizing `HierarchicalIndexer` for workflow orchestration, `KnowledgeBuilder` for Claude 4 Sonnet integration, `FileAnalysisCache` for performance optimization, and `RebuildDecisionEngine` for centralized decision-making. Key semantic entities include `ExecutionEngine`, `PlanGenerator`, `AtomicTask`, `DirectoryContext`, `FileContext`, `IndexingConfig`, `ProcessingStatus`, `DecisionReport`, `TruncationDetectedError`, `EnhancedPrompts`, `KnowledgeFileGenerator`, `DebugHandler`, `MarkdownParser`, `GitCloneHandler`, `ProjectBaseHandler`, `mistletoe` AST parsing, `StrandsClaude4Driver`, `Claude4SonnetConfig`, `FastMCP` Context integration, and specialized handlers for different content scenarios. The architecture implements comprehensive change detection, selective cascading rebuilds, continuation-based retry mechanisms, and defensive programming patterns ensuring reliable operation across diverse filesystem configurations and LLM processing scenarios.

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/models/
*Last Updated: 2025-07-07T10:06:45Z*

Comprehensive data model foundation for the Jesse Framework MCP's Knowledge Bases Hierarchical Indexing System, providing type-safe configuration management, runtime context tracking, decision modeling, and execution planning through immutable dataclass structures. The system delivers centralized model definitions enabling consistent data contracts across all indexing components, comprehensive validation at initialization time, and serialization support for external system integration. Enables developers to implement robust knowledge base indexing workflows with structured configuration management, hierarchical processing state tracking, audit trail maintenance, and Plan-then-Execute architecture coordination. Key semantic entities include `IndexingConfig` for system configuration with handler-specific templates, `DirectoryContext` and `FileContext` for hierarchical processing state, `DecisionReport` and `RebuildDecision` for centralized decision logic, `ExecutionPlan` and `AtomicTask` for atomic task execution, `ProcessingStatus` and `IndexingMode` enumerations for state management, `@dataclass(frozen=True)` for immutable structures, `field(default_factory=datetime.now)` for automatic timestamp tracking, and comprehensive validation through `__post_init__()` methods ensuring data integrity across all model types.

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/tests/
*Last Updated: 2025-07-07T10:06:45Z*

*No detailed content available from tests_kb.md*

## File Knowledge Integration

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/__init__.py

*Last Updated: 2025-07-07T10:06:45Z*

#### Functional Intent & Features

This file serves as the package initialization module for the Jesse Framework Knowledge Bases Hierarchical Indexing System, providing centralized FastMCP tool and resource registration for automated knowledge base maintenance throughout the `.knowledge/` directory hierarchy using leaf-first processing strategy. The module enables comprehensive knowledge base management through standardized MCP interfaces, implementing the Hierarchical Semantic Context pattern with bottom-up assembly and no parent-to-child context flow. Key semantic entities include `register_knowledge_bases_tools` function for MCP tool registration, `register_knowledge_bases_resources` function for MCP resource registration, `HierarchicalIndexer` class for core processing orchestration, `IndexingConfig` and `IndexingMode` for configuration management, `__all__` export list defining public API surface, `__version__` string for package versioning, `FastMCP` integration patterns, `strands_agent_driver` LLM integration, leaf-first hierarchical processing strategy, change detection and incremental updates, and specialized handling for git-clones and project-base scenarios. The system implements async-first design following Jesse Framework standards with comprehensive error handling and defensive programming patterns.

##### Main Components

The package exports five core components through the `__all__` list: `register_knowledge_bases_tools` function for registering MCP tools with FastMCP server, `register_knowledge_bases_resources` function for registering MCP resources, `HierarchicalIndexer` class providing the core indexing orchestration capabilities, `IndexingConfig` class for system configuration management, and `IndexingMode` enumeration for processing strategy selection. The module imports these components from specialized submodules including `.tools` for MCP tool implementations, `.resources` for MCP resource interfaces, `.indexing` for core hierarchical processing logic, and `.models` for data structures and configuration. Package metadata includes `__version__ = "1.0.0"` for version tracking and comprehensive docstring describing key features including leaf-first hierarchical processing, FastMCP tool integration, Strands Agent Driver LLM integration, change detection capabilities, and special handling scenarios.

###### Architecture & Design

The architecture implements a centralized package initialization pattern with clear separation between tool registration, resource registration, and core processing functionality. The design follows FastMCP-first architecture with tool and resource registration patterns, implementing the Hierarchical Semantic Context pattern for structured knowledge file maintenance. Key design patterns include the package initialization pattern for centralized component exports, async-first architecture following Jesse Framework standards, bottom-up assembly pattern with no parent-to-child context flow, defensive programming with comprehensive error handling, and modular component organization separating tools, resources, indexing logic, and data models. The system uses explicit `__all__` declaration to control public API surface and maintain clean dependency management across the knowledge base system components.

####### Implementation Approach

The implementation uses Python's standard package initialization mechanism with explicit imports from specialized submodules using relative import syntax. The approach employs centralized component aggregation through `__all__` list definition, enabling clean external access to all knowledge base functionality through a single import point. Component organization follows functional separation with tools, resources, indexing logic, and models grouped into distinct modules for maintainability and clear responsibility boundaries. The module maintains no internal state or business logic, serving purely as an aggregation and export point for knowledge base components. Version management uses semantic versioning with `__version__` string for package tracking and compatibility management. Documentation follows comprehensive docstring patterns describing system capabilities and key features for developer understanding.

######## External Dependencies & Integration Points

**→ Inbound:**
- `.tools:register_knowledge_bases_tools` - MCP tool registration function for manual indexing operations and system monitoring
- `.resources:register_knowledge_bases_resources` - MCP resource registration function for configuration and documentation access
- `.indexing:HierarchicalIndexer` - core indexing orchestrator providing hierarchical processing capabilities
- `.models:IndexingConfig` - configuration data model for system parameter management
- `.models:IndexingMode` - enumeration defining processing strategies for indexing operations

**← Outbound:**
- `jesse_framework_mcp/main.py:JesseFrameworkMCPServer` - MCP server consuming package exports for knowledge base functionality integration
- `jesse_framework_mcp/server.py` - server initialization consuming tool and resource registration functions
- External MCP clients - consuming registered tools and resources through FastMCP protocol
- Development tools - importing knowledge base components for automated documentation and maintenance workflows
- Configuration systems - using IndexingConfig and IndexingMode for system setup and parameter management

**⚡ System role and ecosystem integration:**
- **System Role**: Central package interface for the Jesse Framework knowledge base indexing system, providing unified access to all knowledge base functionality including tools, resources, and core processing capabilities
- **Ecosystem Position**: Core infrastructure component serving as the primary entry point for knowledge base operations within the Jesse Framework MCP ecosystem
- **Integration Pattern**: Used by MCP server during initialization for tool and resource registration, consumed by external systems through standardized MCP interfaces, and integrated with development workflows for automated knowledge base maintenance

######### Edge Cases & Error Handling

Import failures from any of the four core submodules result in package initialization failure, preventing the entire knowledge base system from becoming available. Missing or corrupted submodules cause import errors that propagate to the MCP server initialization, requiring proper error handling at the server level. Circular dependency scenarios between exported components are prevented through the package structure but could emerge from future architectural changes. Version compatibility issues between the package and its submodules could lead to API inconsistencies or missing functionality. The package provides no error handling mechanisms itself, relying on Python's import system to surface module loading issues and individual components to handle their specific error conditions. Tool and resource registration failures during MCP server initialization would prevent knowledge base functionality from being available to external clients.

########## Internal Implementation Details

The package uses Python's standard relative import mechanism with dot notation to reference submodules within the same package directory. Import statements are organized logically with tool registration first, followed by resource registration, core indexing logic, and data models, maintaining clear architectural layering. The `__all__` list uses explicit string literals for each exported component name, ensuring precise control over the public API surface and preventing accidental exposure of internal implementation details. Module-level imports are performed at package initialization time, making all components immediately available upon successful import without lazy loading or dynamic import mechanisms. The package maintains comprehensive documentation through docstring with feature descriptions and architectural overview for developer understanding. Version management follows semantic versioning principles with string-based version identifier for compatibility tracking.

########### Code Usage Examples

Basic package import demonstrates the unified access pattern for all knowledge base functionality. This approach provides clean dependency management and consistent API access across the Jesse Framework MCP system.

```python
# Import all knowledge base components through unified package interface
from jesse_framework_mcp.knowledge_bases import (
    register_knowledge_bases_tools,
    register_knowledge_bases_resources,
    HierarchicalIndexer,
    IndexingConfig,
    IndexingMode
)

# Initialize MCP server with knowledge base functionality
server = FastMCP("jesse-framework-mcp")
register_knowledge_bases_tools(server)
register_knowledge_bases_resources(server)
```

Selective component import enables targeted usage for specific functionality requirements. This pattern supports modular development and reduces import overhead for specialized use cases.

```python
# Import only required components for specific operations
from jesse_framework_mcp.knowledge_bases import HierarchicalIndexer, IndexingConfig

# Create configuration and indexer for direct usage
config = IndexingConfig(indexing_mode=IndexingMode.INCREMENTAL)
indexer = HierarchicalIndexer(config)

# Execute hierarchical indexing operation
status = await indexer.index_hierarchy(Path("./knowledge"), ctx)
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/resources.py

*Last Updated: 2025-07-07T10:06:45Z*

#### Functional Intent & Features

This module provides FastMCP resource interfaces for the Knowledge Bases Hierarchical Indexing System, enabling standardized access to system configuration, usage templates, and documentation through MCP resource endpoints. The functional intent centers on exposing read-only system information through HTTP-formatted responses that maintain consistency with JESSE Framework patterns. Key semantic entities include `FastMCP` server integration, `IndexingConfig` configuration models, `format_http_response` HTTP formatting utilities, and three primary resource endpoints: `jesse://knowledge_bases/config/default`, `jesse://knowledge_bases/templates/usage_examples`, and `jesse://knowledge_bases/documentation/system_overview`. The module implements comprehensive resource registration patterns supporting configuration analysis, workflow template provision, and system documentation access for effective knowledge base system utilization.

##### Main Components

The module contains four primary components: `register_knowledge_bases_resources()` function serving as the central resource registration orchestrator, `knowledge_bases_default_config()` resource handler providing access to default `IndexingConfig` parameters, `knowledge_bases_usage_examples()` resource handler delivering practical usage templates and workflow examples, and `knowledge_bases_system_overview()` resource handler exposing comprehensive system architecture documentation. Each resource handler implements async response patterns with comprehensive error handling and HTTP-formatted output generation.

###### Architecture & Design

The architecture follows FastMCP resource registration patterns with decorator-based resource endpoint definition and centralized registration through the main orchestrator function. Design principles emphasize read-only resource access ensuring system configuration integrity, HTTP-formatted responses maintaining JESSE Framework consistency, and comprehensive resource coverage supporting both configuration analysis and usage guidance. The structure implements separation of concerns with distinct resource handlers for configuration, templates, and documentation, each maintaining independent error handling and response formatting.

####### Implementation Approach

The implementation utilizes FastMCP's `@server.resource()` decorator pattern for endpoint registration with URI-based resource identification following `jesse://knowledge_bases/` namespace conventions. Each resource handler implements try-catch error handling with detailed logging through the `logger` instance, JSON serialization for structured data responses, and `format_http_response()` utility integration for consistent HTTP formatting. The approach emphasizes comprehensive data provision with metadata enrichment, practical example structuring, and detailed documentation assembly for effective system understanding and utilization.

######## External Dependencies & Integration Points

**→ Inbound:**
- `.models.IndexingConfig` - Configuration data model providing system parameter defaults and serialization
- `..helpers.async_http_formatter.format_http_response` - HTTP response formatting utility ensuring JESSE Framework consistency
- `fastmcp.FastMCP` (external library) - MCP server framework enabling resource registration and endpoint management
- `json` (standard library) - JSON serialization for configuration data and response formatting
- `logging` (standard library) - Error tracking and operational logging

**← Outbound:**
- MCP client applications consuming `jesse://knowledge_bases/*` resource endpoints
- JESSE Framework components requiring knowledge base configuration and usage guidance
- Development tools and documentation systems accessing system overview resources

**⚡ System role and ecosystem integration:**
- **System Role**: Serves as the primary MCP resource interface layer for the Knowledge Bases Hierarchical Indexing System, bridging internal configuration and documentation with external MCP client access
- **Ecosystem Position**: Core integration component enabling standardized access to system information and usage guidance through FastMCP resource protocol
- **Integration Pattern**: Consumed by MCP clients, development tools, and JESSE Framework components requiring read-only access to system configuration, templates, and documentation

######### Edge Cases & Error Handling

Error handling implements comprehensive exception catching with detailed logging through `logger.error()` calls including stack traces via `exc_info=True`. Each resource handler provides graceful degradation returning HTTP 500 responses with structured error information including error messages and exception details. Edge cases include `IndexingConfig` instantiation failures handled through default configuration fallback, JSON serialization errors managed through exception catching, and resource access failures providing clear guidance through formatted error responses with actionable error details.

########## Internal Implementation Details

Internal mechanisms utilize `IndexingConfig().to_dict()` method for configuration serialization, structured data assembly with metadata enrichment for comprehensive resource responses, and consistent error logging patterns across all resource handlers. The implementation maintains response data structuring with description fields, usage guidance, and customization notes for enhanced resource value. Resource URI patterns follow hierarchical organization with `config/`, `templates/`, and `documentation/` path segments enabling logical resource categorization and discovery.

########### Code Usage Examples

**Resource registration in FastMCP server initialization:**
```python
from fastmcp import FastMCP
from jesse_framework_mcp.knowledge_bases.resources import register_knowledge_bases_resources

server = FastMCP("knowledge-bases-server")
register_knowledge_bases_resources(server)
```

**Accessing default configuration resource:**
```python
# MCP client resource access
config_resource = await client.read_resource("jesse://knowledge_bases/config/default")
config_data = json.loads(config_resource)["configuration"]
```

**Resource response structure example:**
```python
# Typical resource response format
response_data = {
    "configuration": config_data,
    "description": "Default configuration for Knowledge Bases Hierarchical Indexing System",
    "usage": "These parameters control indexing behavior, LLM integration, and processing constraints"
}
```

### {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases/tools.py

*Last Updated: 2025-07-07T10:06:45Z*

#### Functional Intent & Features

The `tools.py` file serves as the FastMCP tools integration layer for the Jesse Framework MCP's knowledge base hierarchical indexing system, providing standardized MCP tool interfaces for manual indexing operations, system status monitoring, and search capabilities through the FastMCP server framework. This module enables user-initiated knowledge base operations through MCP protocol integration, evidenced by the `register_knowledge_bases_tools()` function that registers three tools with the FastMCP server and the global `_current_indexer` variable for operation coordination. Key semantic entities include `FastMCP` server integration, `@server.tool()` decorators for tool registration, `Context` parameter for progress reporting, `HierarchicalIndexer` for core processing operations, `IndexingConfig` and `IndexingMode` for configuration management, `format_http_response()` for consistent response formatting, tool functions `knowledge_bases_index_trigger()`, `knowledge_bases_status()`, and `knowledge_bases_search()`, and comprehensive error handling with HTTP status codes (400, 404, 409, 500, 501). The system implements async-first architecture supporting concurrent operations with real-time feedback through FastMCP Context integration and HTTP-formatted responses following JESSE Framework patterns.

##### Main Components

The file contains the primary `register_knowledge_bases_tools()` function that serves as the central tool registration point, three MCP tool implementations as nested functions within the registration function, and a global `_current_indexer` variable for operation state management. The `knowledge_bases_index_trigger()` tool provides manual indexing capabilities with configurable parameters including `target_path`, `indexing_mode`, `enable_git_clone_indexing`, and `enable_project_base_indexing`. The `knowledge_bases_status()` tool offers real-time status monitoring and statistics retrieval for ongoing and completed indexing operations. The `knowledge_bases_search()` tool serves as a placeholder for future search functionality with parameters for `query`, `search_scope`, and `max_results`. Each tool implements comprehensive error handling, progress reporting through FastMCP Context, and HTTP-formatted response generation for consistency with JESSE Framework patterns.

###### Architecture & Design

The architecture follows a centralized tool registration pattern where all MCP tools are defined as nested functions within the `register_knowledge_bases_tools()` function, enabling clean encapsulation and shared access to the global indexer state. The design implements async-first patterns throughout with all tool functions declared as async and using await for I/O operations and progress reporting. The system uses a global state management approach through the `_current_indexer` variable to coordinate operations and prevent concurrent indexing conflicts. Each tool follows a consistent three-section documentation pattern as specified in JESSE_CODE_COMMENTS.md, with tool intent, design principles, and implementation details clearly separated. The architecture integrates HTTP response formatting through the `format_http_response()` helper function, ensuring consistent response structures across all tools with appropriate HTTP status codes and content types.

####### Implementation Approach

The implementation uses FastMCP's `@server.tool()` decorator pattern for tool registration with descriptive names and documentation strings that appear in MCP client interfaces. Tool parameter validation employs early validation patterns with immediate HTTP error responses for invalid inputs, including IndexingMode validation and path existence checking. The system implements conflict detection through global state checking, preventing concurrent indexing operations by returning HTTP 409 Conflict responses when operations are already in progress. Progress reporting uses FastMCP Context methods (`ctx.info()`, `ctx.error()`) for real-time user feedback during long-running operations. Response generation follows a consistent pattern using `format_http_response()` with appropriate HTTP status codes, structured data payloads, and JSON content types for successful operations, while error responses include detailed error information and debugging context.

######## External Dependencies & Integration Points

**→ Inbound:** [MCP tools integration dependencies]
- `fastmcp:Context` - progress reporting and user feedback during tool execution
- `fastmcp.server:FastMCP` - MCP server framework for tool registration and execution
- `.indexing:HierarchicalIndexer` - core indexing orchestrator for processing operations
- `.models:IndexingConfig` - configuration data model for indexing parameters
- `.models:IndexingMode` - enumeration for processing mode validation
- `..helpers.async_http_formatter:format_http_response` - HTTP response formatting for consistency
- `pathlib` (external library) - cross-platform path operations for tool parameters
- `asyncio` (external library) - async programming patterns for concurrent operations
- `logging` (external library) - structured logging for tool operation tracking

**← Outbound:** [MCP tools consumers]
- `FastMCP server instances` - consume registered tools through MCP protocol integration
- `MCP clients` - invoke tools through standardized MCP tool interface protocol
- `Jesse Framework MCP server` - integrates tools into broader MCP server functionality
- `User interfaces` - access tools through MCP-compatible clients and applications

**⚡ System role and ecosystem integration:**
- **System Role**: MCP protocol bridge that exposes knowledge base indexing functionality through standardized tool interfaces, enabling user-initiated operations and system monitoring within the Jesse Framework MCP ecosystem
- **Ecosystem Position**: Interface layer component that connects FastMCP server infrastructure with core indexing functionality, serving as the primary user interaction point for knowledge base operations
- **Integration Pattern**: Used by MCP server during initialization through tool registration, consumed by MCP clients through protocol-standard tool invocation, and integrated with core indexing system through HierarchicalIndexer coordination

######### Edge Cases & Error Handling

The system handles invalid indexing mode parameters through `IndexingMode` enum validation, returning HTTP 400 Bad Request responses with detailed error messages listing valid modes. Concurrent operation conflicts are managed through global indexer state checking, preventing multiple simultaneous indexing operations by returning HTTP 409 Conflict responses. File system validation includes path existence checking and directory validation, returning HTTP 404 Not Found for missing paths and HTTP 400 Bad Request for non-directory targets. Exception handling uses comprehensive try-catch blocks with structured logging through the logger instance and detailed error responses including exception details and context information. The search tool handles future functionality through HTTP 501 Not Implemented responses, maintaining interface consistency while indicating planned feature status. Tool execution failures result in HTTP 500 Internal Server Error responses with detailed error information and debugging context for troubleshooting.

########## Internal Implementation Details

The global `_current_indexer` variable uses Optional typing to handle uninitialized states and provides thread-safe access patterns for operation coordination. Tool registration uses FastMCP's decorator pattern with nested function definitions, enabling shared access to the global indexer state while maintaining clean encapsulation. Response data structures follow consistent patterns with status fields, operation metadata, statistics dictionaries, and error arrays limited to 10 entries for response size management. Progress reporting integrates FastMCP Context methods throughout tool execution, providing real-time feedback during long-running indexing operations. HTTP response formatting uses the `format_http_response()` helper with consistent status codes, structured payloads, and appropriate content type headers. Error handling includes comprehensive exception logging with stack traces and structured error responses containing error messages, details, and context information for debugging and user guidance.

########### Code Usage Examples

This example demonstrates the tool registration process and integration with a FastMCP server instance. The code shows how to register all knowledge base tools with proper server configuration and logging setup.

```python
from fastmcp.server import FastMCP
from jesse_framework_mcp.knowledge_bases.tools import register_knowledge_bases_tools

# Initialize FastMCP server and register knowledge base tools
server = FastMCP("Jesse Framework MCP")
register_knowledge_bases_tools(server)

# Tools are now available for MCP client invocation
# - knowledge_bases_index_trigger
# - knowledge_bases_status  
# - knowledge_bases_search
```

This example shows how MCP clients would invoke the indexing trigger tool with various configuration options. The code demonstrates the parameter structure and expected response format for successful indexing operations.

```python
# MCP client tool invocation example (conceptual)
response = await mcp_client.call_tool(
    "knowledge_bases_index_trigger",
    {
        "target_path": "./src/",
        "indexing_mode": "incremental", 
        "enable_git_clone_indexing": True,
        "enable_project_base_indexing": False
    }
)

# Expected response structure
{
    "status": "completed",
    "target_path": "/absolute/path/to/src/",
    "indexing_mode": "incremental",
    "statistics": {...},
    "completion_percentage": 100.0,
    "operation_summary": {
        "total_files_discovered": 150,
        "files_completed": 145,
        "files_failed": 5
    }
}
```

---
*Generated: 2025-07-07T10:06:45Z*
*Source Directory: {PROJECT_ROOT}/jesse-framework-mcp/jesse_framework_mcp/knowledge_bases*
*Total Files: 3*
*Total Subdirectories: 3*

# End of knowledge_bases_kb.md